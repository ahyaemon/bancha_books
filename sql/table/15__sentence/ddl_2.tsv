id	book_id	sentence	heading
1000	3	分別のある行動	5
	3	Seb Rose	6
	3	どんなに余裕あるように見えたスケジュールでも、実際に作業を始めれば、必ずどこかで追い詰められた状態になるものです。	7
	3	そして、同じことを「正しくやる方法」と「手早くやる方法」があれば、後者のほうが魅力的に見えてしまうことはよくあります。	7
	3	後者を選べば、後で修正が必要になるとわかっていても、その時は「必ず、すぐに修正しよう」と自分に誓うでしょう。	7
	3	プロジェクトチームのメンバーや、顧客などに修正を約束することもあります。	7
	3	約束した時点ではもちろん、絶対に約束を守るつもりでいます。	7
	3	次のイテレーションなどが修正のチャンスなのですが、実際にイテレーションが始まると、また新たな問題が起きてそちらに注力してしまい、結果、修正が不可能になってしまうことも多いのです。	7
	3	このように先送りされていく修正作業のことを「技術的負債(Technical debt)」などと呼ぶことがあります。	7
	3	当然、好ましいものではありません。	7
	3	Martin Fowlerは特に、今述べたような技術的負債のことを「故意の技術的負債」と読んでおり、故意でない、「不注意から発生する技術的負債」とは区別すべきであると言っています。	7
	3		7
	3	技術的負債は、その名の通り、借金のようなものです。	7
	3	短期的には利益になりますが、完済するまで利息を払い続けなくてはなりません。	7
	3	早くできるからと手を抜いてコードを書くと、機能追加やコードのリファクタリングが難しくなります。	7
	3	新たな不具合を生む温床となり、テストケースの価値を損なう原因にもなります。	7
	3	長く放置するほど害は大きくなるでしょう。	7
	3	ようやく元々の問題を解決したら、その問題が原因で生まれた新たな問題が山積みになっていた、ということになりかねません。	7
	3	問題が放置されていたために、正しい設計の選択が出来ないこともあります。	7
	3	リファクタリングや修正の難しいコードを仕方なく次々に書いてしまうこともあるでしょう。	7
	3	実のところ、事態が極端に悪化してしまい、もう他にどうすることも出来ない状況に陥ってはじめて、元々の問題の修正に取り組み始める、そんなことが多いのです。	7
	3	その頃には、修正は極めて難しくなっています。	7
	3	修正しようにも膨大な時間がかかるため、あるいはリスクが高すぎるため、手のうちようがないこともよくあります。	7
	3		7
	3	納期に間に合わせるため、ほんの少しの機能追加のため、どうしても技術的負債が生じてしまう、ということがあります。	7
	3	そうならないように努力はしなくてはいけないのですが、どうしてもそうせざるをえないことがあります。	7
	3	その場合は、あえて技術的負債を抱える道をとる以外ないでしょう。	7
	3	しかし(ここからが何より大事です)、技術的負債の存在は常に忘れないようにし、できるだけ早く返済すべきです。	7
	3	さもなければ事態は急速に悪化していきます。	7
	3	やむなく妥協をする判断を下した時は、すぐにタスクカードに書く、問題管理システムへの登録をする、などの対処をし、技術的負債の存在が忘れられないようにしておくべきでしょう。	7
	3		7
	3	次のイテレーションでの返済をスケジュールに組み込むことができれば、コストは最小限に抑えられます。	7
	3	負債を放置すれば、利息が発生します。	7
	3	この利息を常にトラッキングし、コストを明確にする必要があります。	7
	3	そうすれば、技術的負債が事業価値にどれほど大きな影響を及ぼすかが意識され、返済のための作業の優先順位が自然に上がることになるはずです。	7
	3	利息の計算、トラッキングをどうするかは、プロジェクトごとに違うでしょうが、トラッキングをしなくてはならない、ということだけは、どのプロジェクトでも同じです。	7
	3		7
	3	技術的負債はできるだけ早く返済する。	7
	3	分別のある人ならそうするはずです。	7
	3		7
	3		7
	3	関数型プログラミングを学ぶことの重要性	5
	3	Edward Garson	6
	3	最近プログラミングコミュニティでは、再び関数型プログラミングへの関心が高まっています。	7
	3	その理由としては、業界全体でマルチコアへの移行が進んでいる、ということもあるでしょう。	7
	3	移行によって生じる新たな課題への対処に、関数型パラダイムの保つ特性がうまく合致することが明らかになってきたからです。	7
	3	たしかにそれも重要な理由です。	7
	3	しかし、仮にそれだけなら、私がここでわざわざ「あなたも関数型プログラミングを学ぶべき」という文章を書くこともなかったと思います。	7
	3		7
	3	関数型プログラミングのパラダイムを十分に学べば、その知識、技術は、マルチコアへの対応以外にも幅広く役立つでしょう。	7
	3	まず、自分の書くコードの品質を大きく高めることができます。	7
	3	重要なのは、「参照透過性(referential transparency)」が向上するということです。	7
	3		7
	3	参照透過性が高い、というのは非常に素晴らしいことです。	7
	3	参照透過性が高いとは、関数がどこでいつ呼び出されようと、入力が同じであれば、常に得られる結果がおなじになる、ということを意味します。	7
	3	つまり、関数の評価結果が状態変化の副作用に左右されるということが少ない(あるいは、まったくない)ということです。	7
	3		7
	3	手続き型プログラミングに不具合が生じる原因となりやすいのが、「可変(mutable)な変数」です。	7
	3	本書の読者なら、ある変数の値が、状況によって予期したとおりにならず、その理由を調べた経験が少なからずあるでしょう。	7
	3	「可視性セマンティクス(visibility semantics)」などが、そうした目に見えにくい不具合を減らす上で役立つことはありますし、少なくとも、不具合の箇所の絞り込みにかなり役立つのは間違いないでしょう。	7
	3	しかし、ここで本当に問題なのは、そもそも、変数の値が変わってしまうような設計をしてしまったことです。	7
	3		7
	3	そういう設計を防ぐために参考になるものは、業界全体を見渡してもあまり見つからないことは確かです。	7
	3	オブジェクト指向言語の入門書などには、変数の値が変わる設計を、暗黙のうちに助長してしまっているものもあります。	7
	3	比較的「長生き」するオブジェクトたちが、互いの値や状態を変えるメソッド(mutator methods)を次々に呼び出す、というようなプログラム例が図解入りで載っていたりするからです。	7
	3	これはとても危険です。	7
	3		7
	3	しかし、適切なテスト駆動設計をすれば、特に「オブジェクトではなく、ロールのモックを作成すること」を心がけるようにすれば、不要な可変性は、設計から排除できるでしょう。	7
	3		7
	3	大事なことは、可変なメンバー変数の参照が必要になるような設計をしないことです、それよりも、小さな関数を数多く作り、個々の役割を限定するほうが得策です。	7
	3	個々の関数は、自らに渡される引数にのみ作用するようにします。	7
	3	そうすれば不具合は減り、おそらくデバッグも簡単になるでしょう。	7
	3	この設計では、仮に変数に不適切な値が入ったとしても、その箇所を特定するのが容易になるからです。	7
	3	そうでない設計では、不適切な代入がどのようなコンテキストで行われたかを推測する、ということまで必要になる恐れがあります。	7
	3	このように参照透過性の高いプログラムを書くのがごく当たり前のことだからです。	7
	3		7
	3	もちろん、参照透過性を高めることがどんな状況でも好ましいというわけではありません。	7
	3	参照透過性を高めるようなスタイルは、オブジェクト指向システムの場合、ユーザインターフェース開発よりも、例えばドメインモデル開発において(つまり、コラボレーションがビジネスルールの複雑さの低減に役立つような場合に)好結果につながりやすいようです。	7
	3		7
	3	関数型プログラミングのパラダイムについてよく学ぶことで、関数型言語での開発以外の場面にも、学んだことをうまく応用できるようになるでしょう。	7
	3	オブジェクト指向システムであっても、参照透過性を高めることができれば、利益は大きいはずです。	7
	3	一般的に信じられているよりも、オブジェクト指向システムと関数型システムの間に違いはありません。	7
	3	中には、「突き詰めれば、関数型プログラミングとオブジェクト指向プログラミングは、どちらもお互いの鏡像にすぎない」などという人もいます。	7
	3	「陰と陽」のような関係、といってもいいかもしれません。	7
	3		7
	3		7
	3	ユーザが何をするかを観察する（あなたはユーザではない）	5
	3	Giles Colborne	6
	3	私達はどうしても、誰もが自分と同じようなものの見方や考え方をするはずと思っていしまいがちです。	7
	3	しかし実際には、ものの見方や考え方はひとによって大きく違っています。	7
	3	こういう誤った思い込みのことを心理学では「偽の合意効果」とよびます。	7
	3	自分と考え方や行動が違っている人を見た時、私たちは(多くの場合は無意識に)、そういう人たちを、なにか問題のある人、というふうに評価してしまいがちです。	7
	3		7
	3	ユーザの身になって考えるということがなかなか出来ないプログラマが多いですが、その理由もこの「先入観」にあると言っていいでしょう。	7
	3	ユーザはプログラマのようには物を考えません。	7
	3	そもそも、プログラマに比べてコンピューターを使う時間が圧倒的に少ないのです。	7
	3	また、コンピューターが中でどう動いてるのかを知らないし、知りたいとも思いません。	7
	3	プログラマなら日頃から当然のように馴染んでいる「問題解決のテクニック」がいろいろありますが、それに頼ることもできません。	7
	3	プログラマならば、ユーザインターフェースをいじるうちはお決まりのパターンや変化、ヒントなどを嗅ぎ取りますが、一般のユーザはそんなことはできません。	7
	3		7
	3	ユーザが何をどう考えるかを知るには、ユーザそのものを観察するのが一番です。	7
	3	自分が今開発中のソフトウェアを使ってユーザに何か作業をしてもらい、その様子を見るのです。	7
	3	その作業は、できるだけ本物の業務の中にありそうなものにします。	7
	3	これは例えば「列の数字を足して合わせていく」というような作業のことです。	7
	3	「先月の自分の出費を計算する」ならもっといいですね。	7
	3	しかし「スプレッドシートの特定のセルを選択して、SUM式を入力してください」というような、詳しすぎる指示は避けましょう。	7
	3	あなたは途中で作業に割り込んだり、手助けをしたりしてはいけません。	7
	3	観察しながら、絶えず「なぜ、この人はこういうことをするのだろう？」、「なぜ、こうはしないのだろう？」と考えるのです。	7
	3		7
	3	観察していて最初に気づくのは、おそらく「ユーザは基本的にだいたい同じようなことをする」ということでしょう。	7
	3	作業を進める順序も、どこで間違えるかも、ほぼ同じなのです。	7
	3	つまりソフトウェアは、こういったユーザの基本的な振る舞いを踏まえて設計する必要があるということです。	7
	3	これは、会議室で「ユーザは多分、こうするから・・・」などと想像で話し合うのとは全く違います。	7
	3	単なる想像を基話し合っていても、ユーザが何を求めているか、明確なことは何もわからず、結局複雑で使いづらいものが出来てしまうでしょう。	7
	3	ユーザを直接観察すれば、それを防ぐことができるのです。	7
	3		7
	3	ユーザがどうしていいかわからず立ち往生する場面も何度か目撃することになるでしょう。	7
	3	そういう時プログラマならば、視点を変え、別の使い方を試します。	7
	3	しかしユーザはそうはいきません。	7
	3	立ち往生したユーザは視野を狭めてしまうため、画面の別のどこかにある解決策を見つけることがとても困難になります。	7
	3	このため、ヘルプはユーザインターフェースの不親切さの解決にならないのです。	7
	3	問題解決のための指示、ヘルプテキストなどは、問題が起きているまさにその箇所に表示されないと意味がありません。	7
	3	ユーザの視野が狭くなってしまっているので、ヘルプメニューよりもツールチップのほうが有用なのです。	7
	3		7
	3	ユーザは、自分の目的がどうにか達せられれば、それでよしとします。	7
	3	効率よくやろうとはあまり考えません。	7
	3	なんとか目的を達せられる方法を1つ発見すれば、ずっとその方法に固執します。	7
	3	それがいかに非効率な方法だろうと、容易には変えようとしないのです。	7
	3	ショートカットが2つも3つもよういされていたとしても、たして意味はなく、それより、見てすぐに分かる方法が1つ用意されている方がありがたいと感じます。	7
	3		7
	3	ユーザが「こうしたい」と口で言ったことと、実際にやっていることが食い違っていることにもあなたは気づくでしょう。	7
	3	これも非常に厄介な問題です。	7
	3	ユーザが何を求めているかを知ろうとすれば、普通、彼らの言葉を頼りにするからです。	7
	3	実は、ユーザが求めているものを正しく知るには、言葉を聞くよりも、彼らの行動を観察するほうがいいのです。	7
	3	彼らの求めるものを頭で考えて1日過ごすより、わずか1時間でも観察をしたほうが得るものは多いでしょう。	7
	3		7
	3		7
	3	コーディング規約を自動化する	5
	3	Filip van Leanen	6
	3	あなたも見たことがある光景かもしれませんが、新しいプロジェクトが立ち上がる時というのは、みんな「抱負」を持つものです。	7
	3	ああも使用、こうもしよう、と希望に燃えるのです。	7
	3	そういう抱負は、多くの場合ドキュメントにまとめられます。	7
	3	たとえば「このプロジェクトでは、一定の規約に従ってコーディングをする」ということが決定され、その規約がドキュメントにまとめられたりするのです。	7
	3	キックオフミーティングでは、プロジェクトリーダーがドキュメントの内容を承認し、プロジェクトのメンバーの多く、時には全員が、その規約を守ることに賛成します。	7
	3	しかし、いざプロジェクトが開始されると、こうした最初の抱負は徐々に顧みられなくなっていきます。	7
	3	そしてプロジェクト完了時には、規約など全く無視された無秩序なコードが、なぜそうなったのか誰にも理由がわからないまま、納品されてしまいます。	7
	3		7
	3	一体、どこでおかしくなってしまうのでしょうか。	7
	3	おそらく、すでにキックオフミーティングの時点でおかしくなっていたのだと思います。	7
	3	プロジェクトチームの中に、実はコーディング規約に無関心な人や、なぜ規約が必要なのかを理解していない人がいたのでしょう。	7
	3	もっとひどい場合には、内心全く規約に賛同しておらず、はじめから守らずに作業をするつもりでいた人もいるかもしれません。	7
	3	規約には賛成で必要な理由もわかっていたけれど、納期に間に合わせなくては、というプレッシャーに負けて、守ることをあきらめた、という人もいたでしょう。	7
	3	規約に従い「美しい」コードが書けても、高機能を求める顧客の歓心を買うことはできません。	7
	3	それに、一定の規約に従ってコードを書くというのは、自動化をしない限り、かなり面倒なことです。	7
	3	クラスのインデントを整え、見やすく混乱しにくくするというだけでも、手作業でやろうとすれば意外に大変なことは、自分のでやってみればすぐに分かります。	7
	3		7
	3	では、そういう問題がありながら、そもそもなぜ、コーディングに規約を設けようなどと思うのか。	7
	3	その目的の1つは「誰も、自分の書いたコードを「私物化」できないようにする」ということです。	7
	3	みんなが、自分の担当部分のコードを好き勝手な形式で書くと、どうしてもその箇所はその人のコードになってしまいます。	7
	3	逆に、その箇所も均一な形式で書いてあれば、私物化という事態にはなりにくいでしょう。	7
	3	その他、開発者がアンチパターンを使ってしまうことでしょう実、ありがちなバグを防ぐという目的もあります。	7
	3	コーディング規約に従うことで、プロジェクトの全体としての進行を円滑にし、開発速度を一定に保ちやすくします。	7
	3	ただし重要なのは、プロジェクトに参加する全員が同じ規約に従わなくてはならないということです。	7
	3	―他の開発者が皆4タブのインデントを使用しているのに、1人だけ3タブのインデントを使ったのでは意味がありません。	7
	3		7
	3	コーディング規約の遵守に役立つツールは多数存在します。	7
	3	そうしたツールには、規約をドキュメント化する機能、規約からの逸脱を報告する機能などがあります。	7
	3	ただし、そういうツールを使えば問題が全て解決するわけではありません。	7
	3	コーディング規約は可能な限り、自動的、かつ強制的に守られるようにすべきでしょう。	7
	3	具体的には次のような方法が有効です。	7
	3		7
	3	以上のことを、重要なプロジェクトでは必ず実践するようにするのです。	7
	3	ただし、守るべき規約が全て自動的に守られるような仕組みを作ることはほぼ不可能でしょう。	7
	3	警告や修正を自動化出来ないルールがある場合は、自動化の仕組みに加えて、ガイドラインの準備が重要になってきます。	7
	3	とはいえこの場合は、自分を含めチームのメンバーたちが、おそらく規約を忠実には守らないだろうと考えておくべきでしょう。	7
	3		7
	3	もう1つ大切なのは、コーディング規約は固定的ではなく、変化していくべき、ということです。	7
	3	プロジェクトが進行していけば、そのプロジェクトで求められるものも変わってきます。	7
	3	はじめのうちは懸命と思えたことが数カ月後にはそうでなくなっている、ということもあるのです。	7
	3		7
	3		7
	3	美はシンプルさに宿る	5
	3	Jørn Ølmheim	6
	3	1つのプラトンの言葉を引用します。	7
	3	ソフトウェア開発に携わる人ならばぜひ知っておくべき言葉、常に心に留めておくべき言葉だと思います。	7
	3		7
	3	この言葉には、ソフトウェア開発において大事にすべきことが見事に要約されていると思います。	7
	3		7
	3	プログラマがコードを書くときに留意すべきことはいくつかありますが、まとめればだいたい次のようになるでしょう。	7
	3		7
	3	プラトンの言葉が教えてくれるのは、シンプルであることを心がければ、上のすべてが達成されるということです。	7
	3		7
	3	4つ目の「美しさ」とは何でしょうか。	7
	3	コードが美しいとはどういう意味7日は、曖昧で、なかなか明確にはわかりません。	7
	3	美しいかどうかは、どうしても主観的な判断になります。	7
	3	何を美しいと感じるかは、その人の経験や思考に大きく影響されるでしょう。	7
	3	美しさにかぎらず、感じ方というのは、どうしても一人一人違ってしまいます。	7
	3	たとえば、いわゆる「芸術家」の美的感覚(少なくとも「美しさ」に対する考え方)は、きっと科学者とは違っているでしょう。	7
	3	芸術を学んだ人が「ソフトウェアの美しさ」という言葉を聞けば、それは芸術作品のような美しさのことだと思うでしょう。	7
	3	一方、科学を学んだ人は「ソフトウェアの美しさ」と聞くと、対称性や黄金比の話をしていると思うかもしれません。	7
	3	あるいは、できるだけコードの書き方を定型化すること、と解釈するかもしれません。	7
	3	私の経験から言うと、両者の間で最も違っているのが、「シンプルさ」というものに対する考え方のようです。	7
	3		7
	3	これまでに見たことがあるソースコードをどれでもいいので、頭に思い浮かべてみてください。	7
	3	他人の書いたコードをあまりみたことがないという人は、ページを一旦閉じ、オープンソースソフトウェアのソースコードを今すぐどこからか入手して、内容をよく見てください。	7
	3	冗談抜きで、今すぐです。	7
	3	検索すればすぐに見つかります。	7
	3	言語は問いません。	7
	3	できれば著名なプログラマの書いたソースコードがよいでしょう。	7
	3		7
	3	私はこれまでに、優れている、美しいと思えるコードを多数見てきました。	7
	3	そこには、必ずいくつか共通の特徴があると気づきました。	7
	3	その中でも特に重要なのが「シンプルである」ということです。	7
	3	アプリケーションやシステムが全体としてどれほど複雑であっても、個々の部分を取り出してみると、全てシンプルになっています。	7
	3	単一の責務を持ったオブジェクトは、メソッドも全て機能が絞りこまれており、名前を見ればすぐに、持っている機能がわかるようになっています。	7
	3	「メソッドのコードはどれも5行から10行くらいの長さにすべき」と言うと、あまりに極端な意見だと思う人もいるでしょう。	7
	3	言語によっては、その長さにすることが非常に難しい物もあります。	7
	3	しかし、それでも、それぐらいの短さを目指すべきだと私は思うのです。	7
	3		7
	3	美しいコードとは、突き詰めれば、シンプルなコードのことです。	7
	3	システムを構成する各部分が全てシンプルで、個々の部分が担う責務も最小限に抑えられていて、部分どうしの関連もシンプル、そんなコードですシンプルできれいなコードになっていればテストもしやすく、開発速度を落とさずに長期間に渡る保守が可能になります。	7
	3		7
	3	美は、シンプルなものから生じ、シンプルなものに宿るのです。	7
	3		7
	3		7
	3	リファクタリングの際に注意すべきこと	5
	3	Rajith Attapattu	6
	3	私達プログラマには必ず、既存のコードの「リファクタリング」が必要になる時がやってきます。	7
	3	ただ、リファクタリングをする前にいくつか考えてほしいことがあります。	7
	3	次に書くようなことに注意すれば、自分を含め、開発に関わる全ての人の時間と労力を大幅に節約できるでしょう。	7
	3		7
	3		7
	3	共有は慎重に	5
	3	Udi Dahan	6
	3	それは私が社会に出て最初に関わったプロジェクトでのことでした。	7
	3	まだ大学を出たてで、自分の能力を証明したくてしょうがなかった頃です。	7
	3	毎晩夜遅くまで会社に残り、既存のコードを読んで色々なことを学んでいました。	7
	3	そして私は初めて仕事を任された時、担当部分の作業にこれまで自分の学んできたことをどうしても実践してみたくなったのです。	7
	3	それは、コメントを入れること、ログをとること、そして、内容が似通っているコードを出来るだけライブラリ化することでした。	7
	3	しかし、意気揚々と臨んだコードレビューで私は思い知らされることになります。	7
	3	コードの再利用を容易に促進すると、かえってひんしゅくを買ってしまうのだ、ということを。	7
	3		7
	3	どうしてそういうことになったのでしょうか。	7
	3	だいがくでは「再利用」を優れたソフトウェア開発プロジェクトの象徴として教わってきました。	7
	3	どんな論文や教科書を読んでもそう書いてあったし、経験豊富なプロのソフトウェア技術者もそう語っていたのに、それらは全部間違いだった、ということでしょうか。	7
	3		7
	3	考えた結果わかったのは、私が1つ重大なことを見逃していた、ということです。	7
	3		7
	3	それは「コンテキスト」です。	7
	3		7
	3	例えばシステム内に同様の処理を行う部分が2つあったとしても、両社のシステムにおける役割が大きく異なっていれば、再利用によるメリットは小さいのです。	7
	3	私がコードをライブラリ化するまで、そのコードを利用する部分間に依存関係は全くありませんでした。	7
	3	元々の成り立ちが全然違うコードだったのです。	7
	3	したがって、状況やニーズが変われば、その後各部分のロジックには全く別の変更が必要になる可能性が高いということです。	7
	3	たとえコードが4行ほどのもので、行っていることが同じだったとしても、それはたまたま一時的にそうなっていただけのことです。	7
	3	私が入ってくるより前は、むしろ一致していないほうが普通だったのです。	7
	3		7
	3	私がコードをライブラリ化してしまったことで、それを利用する部分には依存関係が生じました。	7
	3	まるで、一本の靴紐を、両足の靴に通したような状態になったのです。	7
	3	ライブラリのコードを1行変更しただけで、その影響は複数箇所に及びます。	7
	3	互いに独立していた時なら、該当部分の保守コストは無視できるほど小さかったのに、ライブラリ化してから、変更の度に大きな手間をかけてテストをする必要が生じました。	7
	3		7
	3	私は、システムを構成するコードの絶対的な行数は減らしたのですが、依存しあう部分を増やしてしまったわけです。	7
	3	依存関係が生じる場合には、そのコンテキストが重要になります。	7
	3	依存関係が生じても、狭い範囲でのことならば、さほど問題は生じず、共有のメリットのほうが大きくなったでしょう。	7
	3	しかし、広範囲での依存関係が生じると、システムの様々な部分がそれに巻き込まれることになり、ライブラリのコード自体は良く出来ていても、デメリットのほうが大きくなります。	7
	3		7
	3	こういうミスはとても厄介です。	7
	3	「再利用」は一般的に良いこととされており、たしかに基本的には良いことだからです。	7
	3	コンテキストさえ適切なら、間違いなく有効です。	7
	3	私は今では、システム全体の構造がわからないうちは、コードの共有を容易に進めたりはしません。	7
	3	まずはぶぶんどうしの関係をよく見て、どこをライブラリ化すべきかを慎重に考えます。	7
	3		7
	3	「共有は慎重に。	7
	3	事前のコンテキスト確認を忘れずに」ということですね。	7
	3		7
	3		7
	3	ボーイスカウト・ルール	5
	3	Robert C. Martin	6
	3	ボーイスカウトには大切なルールがあります。	7
	3	それは、「来た時よりも美しく」です。	7
	3	たとえ自分が来た時にキャンプ場が汚くなっていたとしても、そしてたとえ汚したのが自分でなかったとしても、綺麗にしてからその場を去る、というルールです。	7
	3	そうやって、次にキャンプに来る人達が気持ちよく過ごせるようにするのです(このルールは元々、ボーイスカウトの父と呼ばれるロバート・スティーブンソン・スミス・ベーデン=パウエルの「自分が最初に見た時よりも、世界をいい場所にすべく努力しよう」という言葉から来ています)。	7
	3		7
	3	これに倣ってコーディングに関しても同じルールを定めるとしたら「モジュールをチェックインする際には、必ずチェックアウト時よりも美しくする」となります。	7
	3	最初にそのモジュールを書いたのが誰であるかに関係なく、皆がそうやって、たとえ少しずつでもモジュールを改善する努力を続けたとしたら、その結果どういうことが起きると思いますか?。	7
	3	この簡単なルールをとても守れないような難しいものだとは思っていません。	7
	3	何もすべてのモジュールをチェックイン前に完璧なものにせよと言っているのではなく、チェックアウト時より少しでも良い物にしようと言っているだけなのです。	7
	3	モジュールに新たなコードを加える場合には、もちろんそのコードを「美しく」します。	7
	3	既存のコードを触る場合には、チェックイン前にどこか1箇所でいいので改善しましょう。	7
	3	変数名をより適切なものに変えたり、大きい関数を2つの小さくよりシンプルな関数に分割する、というのでもいいのです。	7
	3	循環参照を解消するというのでもいいですし、インターフェースを追加することでポリシーと実装を切り離すというのでもいいでしょう。	7
	3		7
	3	正直に言うならば、これは誰もが守るべき当然の礼儀ではないかと思います。	7
	3	トイレに行ったら手を洗う、ゴミは床に散らかさずにゴミ箱にきちんと捨てる、というのと同じ類のことではないでしょうか。	7
	3	実際、コードに「汚い」部分を残したままにすることは、ゴミを撒き散らすのと同じくらい、社会的に受け入れがたいことです。	7
	3	誰から見ても「してはならないこと」なのです。	7
	3		7
	3	そしてこれは礼儀以上の話でもあります。	7
	3	他人が書いたコードを改善しようと思えば、自分の担当部分のコードを改善する場合とは全く違った配慮が必要になります。	7
	3	チームのメンバーが互いに助け合い、そして互いのコードを綺麗にするのです。	7
	3	ボーイスカウト・ルールを守るのは、それが自分だけではなく、皆のためになるからです。	7
	3		7
	3		7
	3	他人よりまず自分を疑う	5
	3	Allan Kelly	6
	3	プログラマというものは(つまりわたしたちは)自分の書いたコードに何か誤りがあるとは、なかなか考えようとしない人種です。	7
	3	現に問題が起きていても、それが自分のせいだと思うことは滅多になく、「きっとコンパイラのせいだろう」などと思ったりします。	7
	3		7
	3	しかし実際には、コンパイラやインタプリタ、OS、アプリケーションサーバ、データベース、メモリマネージャなど、システムソフトウェアのバグで問題が発生するということは、極めて稀なのです(ほぼないと言っていいでしょう)。	7
	3	もちろんシステムソフトウェアにもバグはあるものですが、責任を押し付けたがる人が期待するよりは、はるかに少ないと言えます。	7
	3		7
	3	私が「本当にコンパイラのバグが問題の原因だった」というけいけんをしたのはたった1度だけで、ループ変数の最適化に関わるバグでした。	7
	3	それよりも、コンパイラあるいはOSのバグのせいだとばかり考えて時間を無駄にした回数のほうがずっと多いのです。	7
	3	自分の時間、サポート担当の時間、管理者の時間をさんざん無駄にした挙句、結果は自分のミスが原因だったと判明して力が抜けたということが何度もありました。	7
	3		7
	3	多くの人に使われているツール、「枯れた」ツール、様々なテクノロジスタックに採用されているツールは、必然的に品質が上がっています。	7
	3	つまり、何か問題が起きた時にこうしたツールの品質を疑ってもあまり意味が無いということです。	7
	3	もちろん、初期リリースや、世界中でも利用者が少ないツール、めったにダウンロードされないツール、バージョン0.1、オープンソースのソフトウェアなどであれば疑う意味はあるかもしれません(商用ソフトウェアのαバージョンなども同様です)。	7
	3		7
	3	コンパイラにバグがほぼ無いのだとしたら、コンパイラの誤りを証明するよりも、自分のコードのバグを見つけることに時間とエネルギーを注いだほうがずっと良いということになります。	7
	3	自分の書いたコードを疑い、デバッグに関して一般に「すべき」と言われていることをやってみましょう。	7
	3	具体的には、問題箇所を切り分け、呼び出し先をスタブに置き換え、テストを書いてみる、といったことをまず行います。	7
	3	呼び出しの作法、共有ライブラリ、バージョン番号のチェックも忘れずに行いましょう。	7
	3	作業内容をチームの他のメンバーに説明してみましょう。	7
	3	スタック破損や変数の方の不一致を見張りましょう。	7
	3	マシンやビルド設定を変えて、例えばデバッグ用、リリース用両方の環境で実行してみましょう。	7
	3		7
	3	このとき重要なのは前提条件を考えることです。	7
	3	何を当然とみなすかは人によって違っています。	7
	3	自分と他人では違っているでしょう。	7
	3	たとえ同様のツールであっても、提供するベンダが違えば前提条件は違っているでしょうし、たとえ提供するベンダは同じでも、違うツールならば、やはり前提条件が違っていると考えられます。	7
	3		7
	3	問題発見の報告を受けたが、それを自分で再現できない場合には、報告者が実際にどういうことをしているのか、その現場を見るべきです。	7
	3	ひょっとすると、あなたが想像もしなかったようなことをしている可能性があります。	7
	3	予想とは全く違った発想、違った順番で行動していることがあり得るのです。	7
	3		7
	3	私は、何か問題が起きた時には必ず真っ先に自分の書いたコードのバグを疑うことにしています。	7
	3	自分のコードを徹底的に調べて、それでもバグが見つからなかった時、初めてコンパイラのバグを疑い、スタック汚染を調査します、たとえば「トレースコードを加えてみたら、問題箇所があちこちいどうしていくのがわかった」という場合なら、自分のコード以外を疑ってもいいでしょう。	7
	3		7
	3	マルチスレッドがらみの問題も厄介なバグの原因になりやすく、マシンの前で叫び声を上げたまま白髪になりかねません。	7
	3	「コードはできるだけシンプルにすべき」と常に言われますが、マルチスレッド環境においてこの言葉は何倍も重要です。	7
	3	スレッド間の整合性に関わるバグを、一般的なデバッグ作業やユニットテストで見つけ出すことは困難です。	7
	3	設計をシンプルにするということが何より大切になるのです。	7
	3		7
	3	システムに何か問題が起きて、それをコンパイラやOSのせいにしたくなった時は、シャーロック・ホームズの「完全にありえないことをすべて取り除いていけば、残ったものがいかに信じがたいものでも、事実に違いない」という言葉を思い出すといいでしょう。	7
	3	同じく探偵のダークジェントリーも「あり得ないことを全部排除して残ったものは、どんなに信じがたくても、間違いなく真実だ」と言っていますが、ホームズのほうが通りはいいでしょう。	7
	3		7
	3		7
	3	ツールの選択は慎重に	5
	3	Giovanni Asproni	6
	3	昨今では、アプリケーションを全くのゼロ方開発することは稀です。	7
	3	通常は、既存のツール(コンポーネント、ライブラリ、フレームワークなど)を組み合わせて作ります。	7
	3	それは次のような理由からです。	7
	3		7
	3	ただ、既存のツールを適切に組み合わせることは、実は容易なことではありません。	7
	3	事前に十分な検討が必要でしょう。	7
	3	その際には、以下の様なことに留意すべきです。	7
	3		7
	3	ここまであげてきたような問題の発生を防ぐために、私は「まずは最低限のツールだけを導入する」という戦略を採っています。	7
	3	よく検討して、どうしても必要と判断したものだけに絞り込んで導入するのです。	7
	3	通常、初期の段階で重視するのは、「インフラ関連の低水準プログラミングの手間を省き、問題の発生を防ぐ」ということです。	7
	3	たとえば分散アプリケーションを開発するなら直接ソケットを扱うのではなくミドルウェアを利用する、ということです。	7
	3	その後も必要になったタイミングで新たなツールを追加していきます。	7
	3	新たにツールを追加する際には、ツールをビジネスドメインオブジェクトから隔離するためのインターフェースやレイヤを導入すれば、ツールの変更が必要になった時の手間が最小限に抑えられるでしょう。	7
	3	最後に、ここまで話してきたアプローチには良い副作用があります。	7
	3	当初の予測よりも導入するツールが少なくて済、アプリケーションも肥大せずに済むのです。	7
	3		7
	3		7
	3	ドメインの言葉を使ったコード	5
	3	Dan North	6
	3	たとえば、コードベースの中に、次のようなコードが見つかったとします。	7
	3		7
	3	だんだんわかってきました。	7
	3	どうやら、あるトレーダーが、あるポートフォリオにアクセスできるか否かを確認するためのコードのようです。	7
	3	そして、これから同じコードを(もっと言えば、ほとんど同じで実は細部が微妙に違っているようなコードを)あちこちで見ることになるのでしょう。	7
	3	たとえば特定のポートフォリオにアクセスできるかだけを確認するなどです。	7
	3		7
	3	では、次のような書き方ではどうでしょうか。	7
	3		7
	3	ここで問題なのは、読者が実際に扱うコードが、上の2つの打ちどちらに近いかということです。	7
	3		7
	3	かつてプログラミングに使えるデータ構造は、非常に基本的なものに限られていました。	7
	3	ビットかバイトかキャラクタです(正確にはすべてがバイトだったのですが、表面上、文字や記号として扱うこともできました)。	7
	3	数値の扱いはやや面倒でした。	7
	3	コンピュータでは2進数が基礎となり、10進数をそのまま扱うことが出来ないからです。	7
	3	このため、何種類かの浮動小数点型を使い分けるということをしてきました。	7
	3	その後、配列や文字列(文字列も正確には配列の一種)、さらにスタックやキュー、ハッシュ、リンクリスト、スキップリスト、その他にも現実世界には存在しないような面白いデータ構造が加わりました。	7
	3	コンピュータサイエンスの世界は、現実世界を制限のあるデータ構造にどう対応付け表現するのかという問題にずっと取り組んできました。	7
	3	心のベテラン技術者なら、取り組み歴史がどのようなものだったのかを語れるでしょう。	7
	3		7
	3	プログラムに暗黙の了解部分があると、他の人が見た時、それがわからずに苦労することになります。	7
	3	暗黙の了解の部分などは作らず、できるだけ明確にしておくべきでしょう。	7
	3	あるキーを手がかりに取得した別のキーを使って存在チェックをするというのは、明解だとはとても言えません。	7
	3	そんなコードを見て、すぐに「なるほど、このコードは利害衝突を阻止するためのビジネスルールの実装だな」などと直感する人はそういないでしょう。	7
	3		7
	3	コードがどのような概念を表現しているのかは、できるかぎりひと目で分かるようにしておくべきです。	7
	3	そうすれば、他のプログラマがコードを見るときに、いちいち「まず、必要な概念を理解してから、それに当てはまるコードを探す」などということをしなくても、何が書いてあるのかすぐに理解できます。	7
	3	また、ドメインモデルが成長した時に(あなたのドメイン理解が深まる度に)コードをそれに合わせて進化させることが可能になります。	7
	3	さらにカプセル化も十分ならば、特定のビジネスルールに対応するコードを1箇所に集中させることが出来ます。	7
	3	コードを修正する際も、他のコードへの影響を心配する必要がないので、誰にも迷惑をかけずに修正が出来るのです。	7
	3		7
	3	何ヶ月か時間が経ってからコードを見たプログラマは、きっと最初にコードを書いた人に感謝するでしょう。	7
	3	そしてそのプログラマは、最初にコードを書いた本人かもしれないのです。	7
	3		7
	3		7
	3	コードは設計である	5
	3	Ryan Brush	6
	3	想像してみてください。	7
	3	ある朝目覚めた時、建設業の世界に世紀の大革命が起きていたとしたら。	7
	3	信じがたいほど仕事が速く、コストの安いロボットたちがすべての作業をしてくれるようになっていたとしたら。	7
	3	ロボットたちは素材をなにもないところから合成できる上、働くためのエネルギーコストもほぼゼロです。	7
	3	そしてなにか不具合があっても自分で自分を修理できます。	7
	3	更に素晴らしいのは、正確な図面をこちらで用意する必要がないということです。	7
	3	おおまかな青写真さえ渡しておけば、ロボットたちはそれを元に人間の介入なしに作業ができるのです。	7
	3	つまり建設コストを無視できるほど小さく出来るよいうことです。	7
	3		7
	3	もしそんなことが起きたら、建設業者にどれほどの影響が及ぼすかはすぐにわかるでしょう。	7
	3	影響は実際の建設を行う施工業者だけにとどまりません。	7
	3	さらに「上流」にも影響は及ぶでしょう。	7
	3	施工のコストがゼロに近くなった時、建築士、設計士と呼ばれる人たちの仕事はどう変わるでしょうか。	7
	3	今はまだ、ある建設プロジェクトに投資するか否かを決める前に、物理的な模型を作るか、コンピュータでモデルを作るかして、事前に細かく検討を重ねる必要があります。	7
	3	しかし、施工のコストが実質上ゼロになったとしたら、誰がわざわざそんなことをするでしょうか。	7
	3	設計がずさんで途中で工事がうまく行かなくなってもどこが問題だったのかを確かめ、また魔法のロボットたちにゼロから新しい建物をつくらせればいいだけなら大した問題ではありません。	7
	3	事前に模型やモデルを作るようなやり方は廃れることになります。	7
	3	代わりに、十分な設計をしないまま作り始め、何度も失敗しながら改良を重ね、徐々に完成に近づけていく、というやり方が主流になります。	7
	3	そういうやり方をしたとしても、少なくとも出来上がったものの表面だけを見る限り、設計を十分にしてから作り始めた場合との違いはほとんどわからないでしょう。	7
	3		7
	3	作業にどのくらい時間を要するか、事前に予測するようなことは急激にヘルに違いありません。	7
	3	建設にかかるコストは、設計にかかるコストよりも容易に計算できます。	7
	3	建設コストは、資材や部品の単価、組立作業にかかるコストなどが判れば、あとはそれを掛け算足し算するだけで大体わかるからです。	7
	3	そして、この計算しやすいコストが限りなくゼロに近づいていくとしたら、コストの読みにくい設計作業に時間をかけるインパクトが相対的に大きくなるでしょう。	7
	3	その結果、設計には時間をかけずとにかく早く作る、という方法が採られるようになり、作業がいつからいつまでかかるのかを正確に予測してスケジュールを立てるよいう方法は採られなくなります。	7
	3		7
	3	もちろん、資本主義社会ですから厳しい競争原理はそのまま残ります。	7
	3	建築コストが事実上ゼロになれば、その後は、設計の作業をほかより早く完了させられる企業が市場で優位に立つでしょう。	7
	3	設計の早さが、企業の競争力の源泉になるわけです。	7
	3	出来上がったものを設計に詳しくない人間が見ても、設計が良いか悪いかはよくわかりません。	7
	3	早くできる方が明らかに有利だとなれば、必然的に、素人目にわかるような問題がなければよしとされることが増えるでしょう。	7
	3		7
	3	人の生死に関わるようなプロジェクトでは、もっと慎重な設計が行われることもあると思います。	7
	3	しかし、多くの場合、十分な設計はなされず、そのせいで消費者が苦しむことが増えます。	7
	3	購入した建物にあれこれ問題が起きるからです。	7
	3	でも、企業側は、ロボットさえ派遣してしまえば、安く簡単に修理、修復できるのでそれでよいと考えます。	7
	3	結局、建設コストの劇的な低下により品質が低下するという、直感に反した事態を招くことになっていますのです。	7
	3		7
	3	本書の読者は、この話を聞いても驚かないかもしれません。	7
	3	同じことはすでにソフトウェアの世界で起きているからです。	7
	3	私たちは、「コードを書くことは設計をすることである」ということ(機械的な作業などではなく、創造的な仕事なのだということ)を肝に銘じる必要があります。	7
	3	それをよく考えれば、ソフトウェア開発がなぜ今、危機に陥ってるのか、その理由がわかるでしょう。	7
	3	何より危機に陥っているのは設計です。	7
	3	作る人間の能力を超えるほどの高度な製品、複雑な設計が求められていて、しかも製品を早く市場に出せという圧力が強いような状況では、設計が不十分なまま製品が作られることがどうしても多くなるのです。	7
	3		7
	3	はたしてどうすればいいのでしょう。	7
	3	ヒントは、先に書いた建設業の世界にあるのではないか、と私は思います。	7
	3	建設の世界では「模型」を作りますが、これはソフトウェア開発における「自動テスト」にあたると考えます。	7
	3	多数の過酷なテストに耐えるものであると証明されない限り、設計が完了したとはみなされないようにするのです。	7
	3	テストをより有効なものにするためには、大規模システムの巨大な状態空間に圧倒されないような方法を考える必要がありますが、言語や設計手法の改善を図れば、きっと希望が見えてくるでしょう。	7
	3	決して忘れてはならないのは、優れた設計には優れた設計のできる「人間」が要る、ということです。	7
	3	そういう人間になるためには、技術の習得のため相当の努力が必要になります。	7
	3	コーディング能力も例外ではありません。	7
	3		7
	3		7
	3	コードレイアウトの重要性	5
	3	Steve Freeman	6
	3	もう何年も前のことですが、私は以前、COBOLを使ったシステム開発に関わっていたことがあります。	7
	3	そのシステムでは、十分な理由がない限りインデントを変更してはならない、という規則になっていました。	7
	3	誰かが余分なインデントを入れてしまったために、システムに以上が起きたということが以前あったためです。	7
	3	この規則は、適切なコードレイアウトにしないとコードの意味が誤解されやすい場合にも、例外なく守らなければならないことになっていました。	7
	3	その結果実際に誤解を招くことがよくあったので、私達は常に不安に苛まれ、慎重にコードを読んでいました。	7
	3	この規則はプログラマにとって大きな足かせになっていたし、それによるコストも大変なものだったろうと思います。	7
	3		7
	3	プログラマは仕事の時間を、実際にコードをタイプすることよりも、コードを探すことと読むことに費やしている、そんな調査結果もあるようです。	7
	3	修正すべき箇所はないか、あるとすればどこか、それを確認する時間のほうが長いということです。	7
	3	そこで私は何とかこの「探したり読んだり」の効率化を図りたいと考えました。	7
	3	私の考えた効率化作は次の3つです。	7
	3		7
	3	目立たない部分を作る: 人間は視覚的なパターンマッチングはとても得意です(サバンナでライオンの姿を見つけなくてはいけなかった過去の名残かもしれません)。	7
	3	そこで私は、コードの中でも、ドメインに直接関係のない部分(商用プログラミング言語のコードでは必ず発生する、いわゆる「偶発的複雑性」の部分)を、他の部分より目立たせないようにするという方法を考えました。	7
	3	そういう部分の書き方のパターンをみな同じにすることにしたのです。	7
	3	同じように書かれている部分が続くと、それはまるで「背景」のように見えます。	7
	3	見た目が似ているコードは動きも似ているという原則が徹底されていれば、違いをすぐに見つけることが出来ます。	7
	3	人間の視覚は、他と違っている場所をすぐに見つけられるようにできているからです。	7
	3	私は、1つのクラス、1つのコンパイル単位の中での構成要素、つまり、定数、フィード、パブリックメソッド、プライベートメソッドなどをどうレイアウトするかを定めた規則を設け、それを常に守るようにしています。	7
	3		7
	3	レイアウトに語らせる: コードを構成する各部分には、それがどんなもので、どんな役割を持っているかがすぐに分かるような名前をつけるべき、私達はそう教えられてきました。	7
	3	でも大事なのは名前だけではありません。	7
	3	見てすぐわかるコードを書くためにはレイアウトも重要です。	7
	3	そのためにまずすべきことは、フォーマッタを使用することについて、開発チームのメンバーの同意を得て、各構成要素のフォーマットのルールを決め、それが自動的に守られるようにすることです。	7
	3	そして、細かい部分はコーディング中に各自が手で調整することにします。	7
	3	まれに意見の不一致が見られることもありますが、各自の意見の不一致は、すぐに「手で調整」方式に収束するはずです。	7
	3	フォーマッタは人間の意図を含んではくれません(以前、私は実際にフォーマッタを書いたことがありますが、本当にそうです)。	7
	3	重要な事は、コードの(要素としての)改行、および、(インデント等による)グルーピングは、言語の構文を満たすだけでなく、何らかの意図を表している必要があるということです(私は自動コードフォーマッタに頼りすぎるきらいがありましたが、Kevin MacGuireがその呪縛から解き放ってくれました)。	7
	3		7
	3	コンパクトにまとめる： 画面に1度に表示できるものが多くなれば、スクロール量やファイルの切り替えが少なくて済みます。	7
	3	つまり「コンテキストが分断される」ことが減るわけです。	7
	3	頭のなかに保持しておかねばならない情報も減ります。	7
	3	長いコメントを入れたり、ホワイトスペースを多く入れたりすることは、名前に8文字の制限があった時代、ラインプリンタの時代には意味がありました。	7
	3	ですが、今やシンタックスハイライトやクロスリンクなどの機能が使えるIDEの時代です。	7
	3	つまりディスプレイの制約の方が大きいのです。	7
	3	できるだけ多くの要素を一度に見渡せた方が、コードは理解しやすくなります。	7
	3	別の言い方をするなら、レイアウトはコードの理解を助けるために行うべきで、コードの理解を助けること以上は求めてはいないということです。	7
	3		7
	3	以前プログラムにあまり詳しくない友人から「コンピュータのプログラムは詩みたいに見える」と言われたことがあります。	7
	3	ほんとうに素晴らしいコードを見た時は、私も同じように感じたことがありました。	7
	3	書かれた文字が全て何かしらの目的を持っていて、しかも見るだけでその目的がどういうものなのかすぐに分かる、そんなコードでした。	7
	3	ただ、プログラムを書く作業には詩を書くようなロマンティックなイメージはないので、それが残念ですね。	7
	3		7
	3		7
	3	コードレビュー	5
	3	Mattias Karlsson	6
	3	コードレビューは一般的に「実施すべきもの」とされています。	7
	3	なぜでしょうか。	7
	3	コードの質を上げ、欠陥を減らすためでしょう。	7
	3	しかし、目的はそれだけとは限りません。	7
	3		7
	3	プログラマの中には、コードレビューを毛嫌いする人が多くいます。	7
	3	おそらく過去に、コードレビューでなにか嫌な経験をしたことがあるのでしょう。	7
	3	全コードが社会規定のレビューを担当するのはだいたいアーキテクトやリードデベロッパです。	7
	3	「アーキテクトがすべてをレビューする」というプラクティスです。	7
	3	そうすることが企業の「ソフトウェア開発工程マニュアル」などで規定されていれば、プログラマはその規定にしたがう他ありません。	7
	3		7
	3	そのような厳しく堅苦しいレビューが必要な企業も中にはあります。	7
	3	しかし、大半の企業ではそうではありません。	7
	3	どうしても非生産的になってしまうからです。	7
	3	この種のレビューを実施すると、レビューを受けている側は、まるで自分が軍法会議にでもかけられているように感じます。	7
	3	またレビュー担当者はコードを読むための時間を確保しなくてはならず、しかも対象システムの知識を細部に至るまで常に最新の状態に保つことを強いられます。	7
	3	レビューが工程の中でボトルネックとなってしまい、やがてプロセスそのものが瓦解(かがい)してしまうことにもなりかねません。	7
	3		7
	3	コードレビューの目的は、ただコードの誤りを修正するだけではありません。	7
	3	重要なのは、チーム全員に同じ知識を共有させること、またコーディングにおいて全員が守るべきガイドラインを確立することです。	7
	3	自分の書いたコードを他のプログラマと共有することで「コードの共同所有(collective code ownership)」が可能になります。	7
	3	レビュー実施にあたっては、担当者をチームのメンバーから無作為に選び、他のメンバーの協力も得て順にコードを確認していく、という方法を採るといいでしょう。	7
	3	レビュー担当者は単に誤りを探すのではなく、個々のコードについて学び、理解することを心がけましょう。	7
	3		7
	3	レビューにおいては、みんな友好的な態度をとるべきです。	7
	3	コードについて何か意見を述べるときは建設的であるように心がけ、辛辣(しんらつ)な批判は絶対に避けましょう。	7
	3	また組織内での上下関係がレビュー結果に影響することがないよう、個々のレビュー担当者の役割、権限は予め明確に決めておきます。	7
	3	たとえば、ドキュメント担当、例外担当、機能担当といった具合に担当範囲を分けるのがいいでしょう。	7
	3	これは1人あたりの負担を減らすことにもつながります。	7
	3		7
	3	コードレビューは曜日を決めて毎週実施するといいと思います。	7
	3	その曜日には、2時間ほどかけてレビューミーティングをするのですが、レビューの対象者となる人はミーティングごとに順に変えていきます。	7
	3	一巡したらまた最初から、ということにすればいいでしょう。	7
	3		7
	3	レビュー担当者の役割もミーティングごとに毎回変えるべきです。	7
	3	チームのなかに新人がいるときは、その人も是非、レビューに参加してもらいます。	7
	3	新人には経験はありませんが、大学を卒業して日が浅い分、まだ学んだことがかなり記憶に残っているでしょう。	7
	3	その知識の御蔭で違った視点が得られる場合もあります。	7
	3	もちろん、経験と知識の抱負な人にレビューに加わってもらうべきなのは言うまでもありません。	7
	3	彼らは、誤りの混入しやすいコードをいち早く、しかも正確に見つけることができます。	7
	3	さらに、コードレビューの進行をスムーズにするためには、コーディングが常に一定のルールに従って行われる体制作りも大切でしょう。	7
	3	ルールが守られているかどうかは、コーディング中にツールで自動チェックされるようにしておきます。	7
	3	その体制ができていれば、コードレビューでフォーマットについて議論する必要はなくなります。	7
	3		7
	3	おそらくコードレビューを成功させるために最も有効な方法は、レビューを楽しいものにすることです。	7
	3	レビューで最も大事なのは人です。	7
	3	もしレビューが辛く退屈なものだったとしたら、誰も進んでレビューに参加する気にはならないはずです。	7
	3	できるだけ砕けた雰囲気になるよう心がけ、主目的をメンバー内で知識を共有することに置くようにするといいでしょう。	7
	3	厳しい言葉の飛び交うレビューより、昼食やお菓子を食べながらのレビューのほうがいいと思います。	7
	3		7
	3		7
	3	コードの論理的検証	5
	3	Yechiel Kimchi	6
	3	ソフトウェアに誤りがないことを論理的に検証するための「形式的証明(formal proof)」という手法があります。	7
	3	しかし形式的証明を手作業でやろうとすると、コードそのものを書くより手間がかかり、しかもその際にミスが起きる恐れもあります。	7
	3	自動ツールが使えればそのほうが望ましいのは確かですが、いつもそれが可能とは限りません。	7
	3	ここは間を取って、半形式的証明とでも呼べる方法をお話ししましょう。	7
	3		7
	3	まずすべきことは、対象となるコードを全て短いセクション(1行、ファンクションコール1つだけのブロックから10行くらいのブロックまで)に分割することです。	7
	3	そうして短く切った上で、個々のセクションが正しいかどうかをチーム内で話し合うのです。	7
	3	その場合、どのセクションについても、メンバーの中で最も懐疑的な態度の人が正しいと納得すれば、一応「正しい」とみなしていいでしょう。	7
	3		7
	3	コードをセクションに分ける際には、まずセクションの終端までの間で、プログラムのステート(プログラムカウンタや、すべての「生きた」オブジェクトの持つ値)が、簡単に説明できるようになっていることが重要です。	7
	3	また、セクションの中での機能(状態変化)は1つのタスク(仕事)に絞りこまれていて、これも簡単に説明できることが大切です。	7
	3	このガイドラインを守ると、検証が容易になり、関数の事前条件や事後条件、ループやクラス(のインスタンス)の普遍条件(invariant)といった概念の意味を統一することにもつながります。	7
	3	これも、もちろん検証を容易にすることに役立つわけですが、セクションに変更を加える際に、他への影響を考えずに済むという意味でも、絶対に必要なことと言えます。	7
	3		7
	3	よく知られていて、一般的に良いとされている(しかし実際にはあまり実践されていない)コーディングプラクティスの多くは、コードの論理的検証を容易にする上でもやはり役立ちます。	7
	3	これは逆に言えば、論理的検証を楽にしようと努力するだけで、コードのスタイルや構造の改善につながるということです。	7
	3	実践すべきコーディングプラクティスの例を次にあげておきます。	7
	3	当然のことながら、こうしたプラクティスが守られているか否かは、多くの場合、静的コード解析によって自動的にチェックできます。	7
	3		7
	3	コード正しさを論理的に検証すると同時に、コードの内容についても検証をし、チーム内で話し合うようにすれば、より理解を深めるのに役立ちます。	7
	3	自分が理解したことを互いに伝え合えば、全員にとって利益になるでしょう。	7
	3		7
	3		7
	3	コメントについてのコメント	5
	3	Cal Evans	6
	3	私が大学に入ったばかりの頃の話です。	7
	3	プログラミングの授業の1時間目、先生からBASICのコーディングシートが2枚配られ、黒板には「ボウリングのスコアを10個入力し、平均を求めるプログラムを書け」という指示が書かれました。	7
	3	それだけ書くと先生は教室を出て行ってしまいました。	7
	3	そんなに難しい課題ではありません。	7
	3	最終的にどんなコードを書いたかは忘れましたが、FOR/NEXTループを使って書いて、全部で15行あるかないかだったと思います。	7
	3	若い人は「コーディングシート」と言われてもわからないかもしれません。	7
	3	昔は、まずコードを紙に手で書いてからコンピュータに入力していたのです。	7
	3	1回に入力できる量は70行くらいに制限されていました。	7
	3	その時は、どうしてシートを2枚渡されたのかわからずに戸惑ったのを覚えています。	7
	3	よくわからないので、1枚目に下書きをして、2枚目に清書をすることにしました(私は字が恐ろしく汚いのです)。	7
	3	きれいにかけているということで少しは評価があがるかな、と期待もしていました。	7
	3		7
	3	次の授業のはじめに課題が返ってきたのですが、見て驚きました。	7
	3	合格点ぎりぎりの評価だったのです(後から思うと、それは私の大学生活を暗示していたのかもしれません)。	7
	3	そして、私がせっかくきれいに書いたコードの上には、こう走り書きしてありました。	7
	3	「コメントは入れないのですか?」。	7
	3	そのコードがどういうもので、どういう目的で書いたものなのかは、もちろん先生と私にはよくわかっていました。	7
	3	しかし、その2人だけがわかればいい、というものではなかったのです。	7
	3	その課題で私が学んだのは「コードは、次に見る人がすぐに理解できるように書く」ということでした。	7
	3	これは今後も決して忘れることはないでしょう。	7
	3		7
	3	コメントは悪ではありません。	7
	3	有効なものです。	7
	3	そして分岐やループなどと同様、プログラミングには必須の要素と言えます。	7
	3	ある程度以上新しいプログラミング言語には、一定の形式で書かれたコメントを基に自動的にAPIドキュメントを生成するツール(例：javadoc)などが用意されています。	7
	3	まずはじめにこういうツールを利用するのが良いでしょう。	7
	3	しかし、それだけではまだ十分とはいえません。	7
	3	プログラムのコードには「このコードはどういう目的で書かれたものか」のせつめいをするコメントを入れるべきなのです。	7
	3	「書くのに苦労したコードは、読むのにも苦労する」という格言がありますが、読むのに苦労するようなコードをコメントもつけずに放置すれば、顧客にも、自分の働く会社にも、同僚にも、そして将来の自分にも害を及ぼす事になります。	7
	3		7
	3	ただし、コメントは多く入れればいいというものではありません。	7
	3	コメントを入れるのは、あくまでコードをわかりやすくするためです。	7
	3	コメントを入れたことで帰ってコードがわかりにくくなっては意味が無いのです。	7
	3	必要にして十分な量のコメントを、適切な場所に入れること。	7
	3	「このコードで何がしたいのか」を読む人にわかってもらうこと、それが大事です。	7
	3	まずヘッダコメントには「プログラマがコード本体をまったく読まなくても利用することはできる」というくらいの情報を盛り込みます。	7
	3	そしてインラインコメントには、自分の次にコードを見て修正や拡張をする人の助けとなるような情報を適宜(てきぎ)盛り込みましょう。	7
	3		7
	3	随分前ですが、こんなことがありました。	7
	3	その時、私は上の人間に腹を立てていました。	7
	3	あるコードに関して彼らが採用を決めた設計がどうしても良いと思えなかったからです。	7
	3	若いプログラマにはありがちなことです。	7
	3	その設計を使用せよ、ということはメールで指示されたのですが、怒りのあまり、私はそのメールの文面をコードのヘッダコメントにコピー&ペーストしてしまいました。	7
	3	そして後になって、そのコードをコミット後にレビューするのは、まさにメールを送ってきた上司である、ということがわかったのです。	7
	3	そのとき初めて、CLM(Career-Limiting Move：出世の妨げとなるような行動)という言葉の意味が実感を伴って理解できたのでした。	7
	3		7
	3		7
	3	コードに書けないことのみをコメントにする	5
	3	Kevlin Henney	6
	3	「理論と実践は違う」とよく言われますが、その逃いは、自分で何かを実践してみると本当によくわかります。	7
	3	これは、コードにつけるコメントについても当てはまることです。	7
	3	コードにコメントをつけるのは、理論的には良いこととされています。	7
	3	「これはどういう処理をするコードなのか」をコメントで詳しく説明するのは、良いこと、役に収つこととされているのです。	7
	3	しかし実際には、コメントを入れたことがかえって害になる場合もよくあるのです。	7
	3	世の中には「文章術」というものがありますが、コメントにも良いコメントを書くための文章術があるのです。	7
	3	中でも特に大事なのは、コメントに「書かなくてよいこと」を見極める技術でしょう。	7
	3		7
	3	文法的に誤ったコードを書けば、コンパイラやインタープリタ等のツールがエラーを発生させ、それを知らせてくれます。	7
	3	またコードに機能的な問題があれば、レビューや静的分析で発見されることもあるし、製品になってユーザが日々使う中で発見されることもあります。	7
	3	しかし、コメントはどうでしょうか。	7
	3	「プログラム書法」という本の中で、著者ののLernighanとPlaugerは「たとえコメントを入れても、それが不適切なものであれば価値はゼロ(あるいはマイナス)である」と述べています。	7
	3	そして、そうした不適切なコメントは不適切なコードとは違い、修正されたり削除されたりすることは少なく、コードベースにいつまでも残ってしまうことが多いのです。	7
	3	不適切なコメントが残っていれば、誰かがコードを見る度に集中力が削がれたり、誤った情報を与えてしまうことさえあります。	7
	3	ほんのわずかでも、絶えず、プログラマにとって思考の妨げとなってしまうわけです。	7
	3		7
	3	書いていることが技術的に誤っているわけではないが、コードに何か価値を加えるわけでもない、そういうコメントは、一種の「ノイズ」とみなすことができます。	7
	3	コードに書かれていることをただオウム返しにするだけで、何の情報もつけ加えていないコメントはノイズでしょう。	7
	3	プログラミング言語で一度書いたことを、もう一度自然言語で言ったからといって、正しさが増すなどということはありません。	7
	3	コメントの部分は、実行されるわけではないので、ノイズのようなコメントは、コードを読む時にも実行する時にも、まったく役に立たないわけです。	7
	3	また、コメントの内容は、あっという間に陳腐化する、という点、にも注意が必要です。	7
	3	たとえば、コートがとのバージョンなのかを知らせるコメントや、「どのバージョンでどういう修正を加えたか」という属鹿を入れてコメントアウトされたコードなどがよくありますが、そのような情報はバージョン管理システムを使えば(るかに合理的に)得ることができます。	7
	3		7
	3	ノイズのようなコメント、情報の誤ったコメントがコードベースに大量にあると、やがてプログラマはコメントのすべてを無視するようになります。	7
	3	ただ読み飛ばすという人もいれば、コメントが画面から消えるよう対策を講じる人もいます。	7
	3	プログラマという人種は皆、問題を回避することに長けています。	7
	3	自分にとって害になり得るものの存在を察知すれば、すぐにそれを避ける方法を見つけ出します。	7
	3	コメントの部分を「折り畳める」よ うにしたり、あるいはコメント部分の色を背景と同じにして見えなくしてしまうこともできます。	7
	3	コメントをフィルタリングするスクリプトを書く人もいるでしょう。	7
	3	しかし、プログラマのせっかくの能力をそんなことに使うのは無駄です。	7
	3	それに中には本当に価値のある、重要なコメントもあるはずなので、それを見逃すのは問題です。	7
	3	こういう問題を防ぐには、コメントを通常のコードとまったく同じように考えて扱うことが重要になってきます。	7
	3	すべてのコメントを読む人にとって価値のあるものにし、そうでないものは即座に削除するか書き直すべきであるということです。	7
	3		7
	3	「読む人にとって価値がある」とは具体的にはどういう意味でしょうか。	7
	3	それは、コードには書いていないことや、コードには書けないことが書いである、ということです。	7
	3	本来コードを見ればわかるはずのことをコメントに書かなくてはならないのは、コードの構造や書き方を見直す必要があるということです。	7
	3	メソッドやクラスの名前がわかりにくいからコメントを書くというのなら、名前を変えてしまった方がいいでしょう。	7
	3	関数が長くて分かりにくいせいでコメントが要るのなら、関数を小さく分割して、どういう関数かがすぐに分かる名前を個々につける方がいいでしょう。	7
	3	コード自身にできる限り「語らせる」ようにするのです。	7
	3	どうしてもコードに語らせることが不可能な時に、語らせたかったものとコードとのギャップこそコメントに書くのです。	7
	3	コードに「書いていないこと」ではなく、コードに「書けないこと」のみをコメントにするのです。	7
	3		7
	3		7
	3	学び続ける姿勢	5
	3	Clint Shank	6
	3	いま私たちは実に面白い時代に生きています。	7
	3	ソフトウェア開発を仕事にする人は世界中に存在しています。	7
	3	自分と同じくらいの能力を持った人は、どこにでも、いくらでもいる、そう実感することも多いのではないでしょうか。	7
	3	そういう状況で自分の市場競争力を維持するためには、「学び続ける姿勢」がとても重要です。	7
	3	学ぶことを止めれば、早晩、恐竜のように滅びてしまうことになるでしょう。	7
	3	ずっと同じ仕事にしがみついていると、いずれ必要とされなくなる日が来ます。	7
	3	自分の仕事が、よりコストの安い誰かにアウトソースされることもありえます。	7
	3		7
	3	学び続ける、と言うのは簡単ですが、具体的にはどうすればいいのでしょうか。	7
	3	社員のスキルセット拡大のために費用を負担してトレーニングを受けさせてくれる気前のいい会社もありますが、社員のトレーニングのためにわざわざ時間やお金を使うことは一切しない、という会社も多いでしょう。	7
	3	やはり会社は当てにせず、自らのカで学んでいくのだ、と思っていた方が確かでしょう。	7
	3	学び、続ける姿勢を保つための手段をあげておきましょう。	7
	3	インターネットを利用すれば無料で済むものも多いです。	7
	3		7
	3	映画「マトリックス」のネオのように、必要な情報があれば即時に脳にダウンロードするような能力が私たちにもあればいいのですが、あいにくそんな能力はありません。	7
	3	時間をかけ、努力して学ぶしかないのです。	7
	3	とはいえ、起きている時間のすべてを学ぶことに向けることは不可能だしそんな必要はありません。	7
	3	そのほんの一部でも、たとえば週に1回1時問でも、何もしないよりはずっと良いでしょう。	7
	3	人間には日々の業務とは関係ないことをする時があってもいいし、むしろそうあるべきでしょう。	7
	3		7
	3	技術はすごい速さで変化していきます。	7
	3	学ばなければ置いていかれるのは確実です。	7
	3		7
	3		7
	3	誰にとっての「利便性」か	5
	3	Gregor Hohpe	6
	3	優れたAPI の設計の重要性、そして難しさについては、これまで多くのことが語られてきました。	7
	3	最初から適切なAPIを作ることは難しく、しかし後からAPIに変更を加えることはもっと難しい。	7
	3	まるで子育てのような難しさ、と言っていいでしょう。	7
	3	経験を積んだプログラマならほぼ皆知っていることでしょうが、優れたAPIとは、まず抽象度がどこをとっても一様であり、その上で、整合性、対称性を備えているものです。	7
	3	優れたAPIはプログラミング言語のボキャブラリーを充実させ、言語に豊かな表現力を与えるものでもあります。	7
	3	しかし、そうした原則を十分に意識していたとしても、適切なAPIができるとは限りません。	7
	3	甘い物は身体に必要だが食べ過ぎると成長によくない、というのと同様に、原則にとらわれすぎるとかえって悪い結果を招くことがあるのです。	7
	3		7
	3	こう書いただけだと暖昧でよくわからないと思いますので、具体例をあげることにしましょう。	7
	3	以下の3つは、どれもAPIを設計する人が実際の作業時に言いそうなことです。	7
	3	そして、どの意見も「その方が利便性が高い」という理由で正当化されやすいのです。	7
	3		7
	3	どれも善意から出た意見なのは確かです。	7
	3	しかし、こういう意見に従ってAPIを作ると困ったことが起こります。	7
	3	それは、「APIを使用したコードが非常に読みにくくなってしまう」ということです。	7
	3	たとえば、メソッド呼び出しのコードがこんなふうになります。	7
	3		7
	3	このコードが何を意味するのか、APIの内部の実装を知らない人にはおそらくわからないはずです。	7
	3	ドキュメントを調べて何とか判ればまだ良い方でしょう。	7
	3	このメソッドは、たしかに利便性を考えて設計されているのですが、それはメソッドを「実装する側にとっての利便性」であり、決して「呼び出す側にとっての利便性」ではないのです。	7
	3	「することはほとんど同じなのに、2種類の呼び出しを使うのは不便ではないか」というのは、要するに呼び出すす側にとって不便というのではなく、コードを書く自分が、内容のほとんど同じメソッドを2つ書くのが「面倒」という意味なのです。	7
	3	冗長で、不整合で、美しくないものを作りたくない、という意図は、基本的に間違っていません。	7
	3	しかし落ち着いてより深く考えるならば、それらの対偶にあるのは効率的、整合性、美しさです。	7
	3	必ずしも「利便性」ではありません。	7
	3	APIを作るというのは、複雑な処理を隠蔽するということです。	7
	3	これは正確には、APIを作る側が、複雑な処理を隠すために面倒な作業を引き受けなくてはならないということです。	7
	3	そうしなくては優れたAPIなどできません。	7
	3	作る側にとってみれば、考え抜かれたメソッドをいくつも書くよりも、大きなメソッドを1つ書く方が「使利」です。	7
	3	しかしそれは使う側にとって「便利」でしょうか?。	7
	3		7
	3	すばやくデプロイ、こまめにデプロイ	5
	3	Steve Berczuk	6
	3	インストールやデプロイに関わる作業というものはどうしても後回しにされ、プロジェクトの終了間際になってから始めることになりがちです。	7
	3	インストールツールを書く作業を丸投げされたリリースマネージャが、その作業を「必要悪」として考えている、などということも珍しくありません。	7
	3	レビューやデモで、デプロイやインストールが一応正しくできていることを確認はするのですが、そのための環境が単なる「間に合わせ」で、適切なものでないことも多いのです。	7
	3	これでは、チームのメンパーは、デプロイのプロセスやデフロイ先の環境などに関してまったく学ぶことができませんし、改善したいときには手遅れということになってしまうでしょう。	7
	3		7
	3	インストール/デプロイ作業こそが、顧客がはじめて製品に触れる機会です。	7
	3	この作中自体は簡単なものかもしれませんが、信頼できる(少なくともデバッグしやすい)本番環境を作り上げるための第一歩です。	7
	3	顧客が実際に使うのはデプロイされたソフトウェアです。	7
	3	デプロイの際にアプリケーションが正しく設定できなければ、顧客は本格的に使い始める前に、製品に対して疑いを持ってしまうでしょう。	7
	3		7
	3	プロジェクトの最初の段階からインストールプロセスに関する作業を始めていれば、十分な時間を確保し、製品の開発サイクルに連動してプロセスを進化させていくこともできるでしょう。	7
	3	アプリケーションのコードを、あらかじめインストールやデプロイが簡単にできるよう考えて書くこともできます。	7
	3	クリーンな環境でインストールやデプロイのプロセスを定期的に走らせテストしていれば、コードが開発環境やテスト環境に依存したものになるのを防ぐこともできます。	7
	3		7
	3	デプロイ関連の作業を後回しにすると、コードが開発環境やテスト環境に依存したものになりやすくなります。	7
	3	それを回避するための対策を講じることは容易ではなく、大変な労力が必要になってしまいます。	7
	3	こう言うと「IDE を利用すればよいのでは」と考える人もいるでしょう。	7
	3	確かにIDEを使えば環境を自在に扱うことができるため、デプロイ作業が少しは楽になるかもしれません。	7
	3	しかし、いずれにしろトレードオフはあるので、それが具体的にどんなものかを早めに知っておくに越したことはないでしょう。	7
	3		7
	3	プロジェクトの初期には「デプロイができる」ということよりも、開発者のコンピュータ上でアプリケーションが動作する(一応、正しく動作しているように見える)ことの方に価値が置かれがちです。	7
	3	しかし当然のことながら、ターゲット環境でのデモができるようになってはじめて、ソフトウェアはビジネス上の価値を持ちます。	7
	3	「開発者のコンピュータで一応動作する」という状態から、「デモが可能である」という状態にするまでには、相当な作業が必要になるのです。	7
	3	それなりの理由があってデプロイ作業を後回しにしているのかもしれませんが、よほどの理由でない限り、ともかくデプロイ作業を早い段階から始めるべきでしょう。	7
	3	その方がコストが少なくて済みます。	7
	3	「作業が複雑すぎる」あるいは「不定要素が多すぎる」という場合には、アプリケーションコードを書くときと同じことをすれば良いのです。	7
	3	つまり、デプロイ作業の実験、評価、リファクタリングを必要なだけ行うのです。	7
	3		7
	3	インストールやデプロイのプロセスは、顧客やプロフェッショナルサービスチームの生産性に大きく影響します。	7
	3	早い段階からプロセスのテストやリファクタリングに取り組み、プロジェクトの進行と連動して作業を進めていくべきです。	7
	3	私たちプログラマはコードのテストとリファクタリングを常に行いますが、インストールやデプロイのプロセス自体もその例外ではないのです。	7
	3		7
	3		7
	3	技術的例外とビジネス例外を明確に区別する	5
	3	Dan Bergh Johnsson	6
	3	プログラムの実行時に起きる問題には、大きく分けて2つの原因があります。	7
	3	1つは技術的な原因です。	7
	3	これは、発生するとアプリケーションの実行そのものが続けられなくなるような問題のことです。	7
	3	もう1つの原因はビジネスロジックで、これは簡単に言えば、ユーザがアプリケーションの使い方を誤らせないために(わざと)発生させる問題です。	7
	3	「モダンな」プログラミング言語、LISP、Java、Smalltalk、C#などは、この2種類の問題の発生を通知するために「例外(Exception)」を使用します。	7
	3	しかし、2種類の問題は本質的に大きく異なるものなので、混同しないように常に注意する必要があります。	7
	3	両者を同じ例外階層構造を使って表現することは混乱の元になりますし、ましてや同じ例外クラスで表現するのはもってのほかです。	7
	3		7
	3	プログラムのコードに誤りがあると、解決が難しい「技術的な問題」が発生することがあります。	7
	3	たとえば、要素が17個しかない配列の83番目の要素にアクセスするようなコードがあると、プログラムは間違いなくまともに動かず、例外が発生するでしょう。	7
	3	そこまで極端でなくても、たとえばライブラリのコードを呼び出す時に引数が適切でなかったりすると、ライブラリ内部で同様のことが起きるでしょう。	7
	3		7
	3	この種の例外を処理するコードを自分の手で書くのは賢明とは言えません。	7
	3	発生した例外を自分で捕まえずにトップレベル、アーキテクチャレベルまで通過させ、トップレベルの例外処理メカニズムに後の処理を委ねるのです。	7
	3	トップレベルの例外処理メカニズムは処理を依頼されると、システムを安全な状態に戻すための対処をします。	7
	3	具体的には、トランザクションのロールパック、ログ作成、管理者への警告、ユーザへの通知(管理者への警告より表現は穏やかになる)などを行います。	7
	3		7
	3	ライブラリ内で問題が発生した場合も同様のことが言えます。	7
	3	たとえば、メソッド呼び出しのコードがライブラリの契約(Contract) に違反していた場合などです。	7
	3	契約の違反とは具体的には、渡す引数が正しくない、必要なオブジェクトが正しくセットアップできていない、といったことを意味します。	7
	3	これも「技術的な問題」の一種です。	7
	3	要素が17個しかない配列の83番目の要素にアクセスしようとする、というのと重大さの点でさほど変わりません。	7
	3	これは本来、呼び出し側のコードでチェックされるべきことなのですが、もし、チェックが行われないのだとすれば、それはクライアント側のプログラマのミスということになります。	7
	3	呼び出し側コードでの正しい対処は、自分で例外を発生させることです。	7
	3		7
	3	データベースサーバが応答しない等、実行環境の不備によってプログラムの実行が続けられない、という状況も考えられます。	7
	3	これは上記の問題とは異なりますが、やはり技術的な問題で、あることは確かです。	7
	3	本来は、インフラの側が何らかの対処(接続を修復する、何度かリトライをする、など)をするべきなのですが、それが失敗に終わったという状況です。	7
	3	先の2つとは原因が違いますが、解決のためにできることがほとんどないという点は同じです。	7
	3	発生した例外を捕まえずに通過させて状況を通知し、トップレベルの例外処理メカニズムに対処を委ねるしかないでしょう。	7
	3		7
	3	ここまで述べた技術的な問題とは違い、「ビジネスロジック」は、業務ロジックの判断によりプログラムの実行が中断されるような状況です。	7
	3	確かに普通の状況ではないし、望ましい状況でもないのですが、技術上の問題が起きた時ほど深刻ではありません。	7
	3	プログラム自体に問題がある、というわけではないからです。	7
	3	たとえば「ユーザが、預金額を超える額のお金を口座から引き出そうとした」というような問題を指します。	7
	3	これは先ほど述 べた「契約(Contract)」の一部と言ってもいいでしょう。	7
	3	この状況で例外を発生させることは、モデルに含まれた代替パスの1つにすぎないのです。	7
	3	つまり、クライアントの方で、あらかじめこの状況に対処するコードを組み込んでおく必要があるということです。	7
	3	発生させる例外は、この状況にのみ対応する例外を新たに定義するか、あるいは、技術的な例外とは違う例外階層構造に属するものにすべきです。	7
	3	システム全体に影響を与えず、クライアントだけで問題に対処できるようにするのです。	7
	3		7
	3	「技術的例外」と「ビジネス例外」を同じ例外階層構造で扱ってしまうと、両者の区別は暖味になってしまいます。	7
	3	メソッドの契約に違反していてもそれがわからず、メソッドを呼び出す際にどういう事前条件を満たさなければならないのかもわかりません。	7
	3	例外が発生したときにクライアントのコードで処理するべきかも判断できません。	7
	3	2つの例外を明確に区別して扱うようにすれば、そういうことは起きません。	7
	3	技術的例外に関しては、アプリケーションのフレームワークに対応を任せることができ、ビジネス例外に関しては、クライアントにあらかじめ対処するコードを組み込んでおくことができます。	7
	3		7
	3		7
	3	1万時間の訓練	5
	3	Jon Jagger	6
	3	「集中的訓練 (Deliberate practice：DP)」という言葉があります。	7
	3	集中的訓練は、ただ課題をこなすだけのものではありません。	7
	3	「課題のための課題」、課題を終わらせるためだけに課題をやっているのだとしたら、それはまったく集中的訓練とは呼べないでしょう。	7
	3		7
	3	集中的訓練の目的は、あくまで自らの能力を高めることにあります。	7
	3	いわゆる「スキル」や「テクニック」を身につけることが目的なのです。	7
	3	集中的訓練において重要なのが「反復」です。	7
	3	身につけたい能力をいくつかの小さな要素に分割し、その一つ一つについて反復訓練をし、習熟度を高めていきます。	7
	3	つまり「反復の反復」が必要になる、ということです。	7
	3	ゆっくりと、能力全体の習熟度を望ましいレベルにまで引き上げていきます。	7
	3	集中的訓練の目的は習熟度を上げることであり、個々の課題、作業をこなし、完了することではないのです。	7
	3		7
	3	代金をもらって開発をする場合、その主たる目的は、製品を完成させることにあります。	7
	3	集中的訓練の場合はそうではなく、自分の能力を高めることを主たる目的とします。	7
	3	両者は本質的に違うものです。	7
	3	まず自分に問うてみてください。	7
	3	普段、仕事での開発作業に費やしている時間はどのくらいですか?それに対し、自分の能力を高めるのに費やしている時間はどのくらいですか?。	7
	3	来たして「エキスパート」と呼ばれるだけの能力を身につけるには、一体、どのくらいの量の訓練が必要なのでしょうか。	7
	3	それについては次のようなことが言われています。	7
	3		7
	3	専門的な技術や知識は、ゆっくりと徐々に身につくものです。	7
	3	1万時間が経過した途端、急に身につく、というわけではありません。	7
	3	それでも、ともかく1万時間やる、ということが大切なのです。	7
	3	ただ1万時間と言ってもそれは膨大な時間です。	7
	3	週に20時間なら10年かかることになります。	7
	3	「1万時間努力したはいいけれど、結果、自分にはエキスパートになる素質がないとわかるだけかもしれない」そう心配する人はいるでしょう。	7
	3	そんな心配はいりません。	7
	3	エキスパートには必ずなれます。	7
	3	何かに秀でた人間になるかどうかは、ほぼ、自分がなろうとするかどうかだけで決まるのです。	7
	3	すべてはあなたの意志次第なのです。	7
	3	過去20年間におよぶ前提でも、ある知識や技術が身につくかどうかは、大部分が、訓練に費やされた時間の長さで決まる、という結果が得られています。	7
	3	天賦の才はさほど重要ではないのです。	7
	3	Mary Poppendieckは次のように述べています。	7
	3		7
	3	訓練をする時、自分にとって楽にこなせることを課題にしでもあまり意味がありません。	7
	3	楽にできないことを課題にして、はじめて意味があるのです。	7
	3	Peter Norvigはそれについて次のように言っています。	7
	3		7
	3	また、Mary Poppendieckも次のように言っています。	7
	3		7
	3	集中的訓練とは「学び」です。	7
	3	新しいことを学んで自分を変え、学ぶことで自分の行動を変えるのです。	7
	3	日々努力を続けなくてはなりません。	7
	3	さあ、始めましょう。	7
	3		7
	3		7
	3	ドメイン特化言語	5
	3	Michael Hunger	6
	3	チェスプレイヤー、幼稚園の先生、保険の外交員など、どの分野にも言えることですが、専門家というのは、日常生活で使われる言葉とは全く違った言葉を使うものです。	7
	3	いわゆる「ドメイン特化言語(DSL: Domain Specific Language)」が存在するのはそのためです。	7
	3	分野(ドメイン)には、それぞれ固有の事象があり、固有の事象を表す特殊な語彙があるので、DSLによってその語彙に対応するというわけです。	7
	3		7
	3	DSLは、ある分野に固有の語彙や語法を使用して事象を表現できるよう作られたプログラミング言語です。	7
	3	この言語を使えば、コードは当該分野の専門家にとって読みやすく理解しやすくなります。	7
	3	その言語を使うことで、専門家自身が自らコードを書くこともできれば理想でしょう。	7
	3	DSLの中でも特に古くから存在するのは、ソフトウェア開発者や科学者をターゲットとしたDSLです。	7
	3	UNIXの環境設定ファイルなどで使われる「ミニ言語」や、LISPのマクロの力を利用して作成された言語などは、その中でも古い例と言えるでしょう。	7
	3		7
	3	DSLは、大きく内部DSLと外部DSLに分類することができます。	7
	3		7
	3	内部DSL: 内部DSLは、汎用のプログラミング言語の書き方を工夫して、見かけ上の構文を自然言語に近づけた言語です。	7
	3	内部DSLの作成には、糖衣構文(syntactic sugar)を豊富に持ち、フォーマットの自由度の高い言語(Ruby、Scalaなど)の方が、そうでない言語(Javaなど)よりも向いていると言えます。	7
	3	内部DSLでは、ホスト言語(基になった言語)のAPI、ライブラリ、ビジネスコードなどはラッピングされるのが普通です。	7
	3	ラッパが提供され、技術的知識がなくてもその機能を用意に利用できるようにしてあるのです。	7
	3	また、コードをファイルに書けば、そのファイルを使って即、実行できるのが普通です。	7
	3	実装の仕方や分野によって言語の用途は様々に異なってきます。	7
	3	用途の例としては、データ構造の構築、依存関係の定義、プロセスやタスクの実行、他のシステムとの通信、ユーザ入力のバリデーションなどが挙げられます。	7
	3	内部DSLの構文はホスト言語の構文の制約を受けます。	7
	3	ホスト言語での書き方を工夫してDSLを作るのに役立つパターンは多数存在します。	7
	3	例えばエクスプレッションビルダ、メソッドチェーン、アノテーションなどです。	7
	3	ホスト言語が再コンパイルを必要としない言語であれば、内部DSIは非常に簡単こ作成でき、対象ビジネス分野の専門家にとって使いやすいものになるでしょう。	7
	3		7
	3	外部DSL： 外部DSLは、汎用のプログラミング言語とはまったく別の構文を持ったDSLです。	7
	3	グラフイカルな外部DSL もありますが、テキストベースの外部DSLの方が一般的です。	7
	3	テキストベースの外部DSLのコードは、レキサ一、パーサ、モデルトランスフォーマ、ジェネレータといったポストプロセッシングのためのツール群を組み合わせることによって処理されます。	7
	3	通常の場合外部DSLは読み込み時に内部モデルに変換され、後続処理に使われます。	7
	3	EBNFなどの文法(grammar)を定義するのが有効でしょう。	7
	3	文法は、エディ夕、ピジュアライザ、パーサジェネレータ等のツール群が扱うパーツを生成するための起点となります。	7
	3	シンプルなDSLならば、たとえば正規表現を利用した「手作りの」パーサなどでも十分に対応ができますむただし、手作りのパーサは、あれこれ欲張ると非常にわかりにくく、使いにくくなってしまうので、openArchitectureWare、ANTLR、SableCC、AndroMDAなど、元々文法定義またはDSLのために作られた既存のツールを探す方が合理的でしょう。	7
	3	XMLの「方言」を作り、それを外部DSLとする方法もよく使われますが、特に技術知識のない人にとってコードが読みにくくなりやすいのが難点です。	7
	3		7
	3	DSLを作るときは、使う人が誰かということを常に考慮にいれておく必要があります。	7
	3	DSLの利用者は、開発者でしょうか、管理者でしょうか、どこかの企業の顧客でしょうか、それともエンドユーザでしょうか。	7
	3	言語の技術レベルや利用可能なツール、例えばシンタックスヘルプ(例: IntelliSense)、リアルタイムバリデーション、可視化ツールなどへの対応や、コード表現を利用者に応じて変えることになります。	7
	3	DSLが技術的な詳細を隠蔽すれば、技術者の助けを借りることなく、ユーザが自分の手でシステムを自らのニーズに合わせることができます。	7
	3	最初にDSLの枠組みさえ提供されれば、あとは各自が自力で作業を進められるため、それが開発作業のスピードアップにつながります。	7
	3	言語は使用されるうちに、徐々に進化することになるでしょう。	7
	3	既存の表現や文法からの移行のために使える手立ても増えます。	7
	3		7
	3		7
	3	変更を恐れない	5
	3	Mike Lewis	6
	3	ソフトウェア業界で働いたことのある人なら、ひどいプロジェクトに関わった経験か一度はあるはずです。	7
	3	たとえば、どう見てもコードベースの品質が低すぎるようなプロジェクトです。	7
	3	システムの構造自体に問題があり、どこかに変更を加えると必ず、関連のないはずの別の箇所が壊れてしまう。	7
	3	そんなプロジェクトにおいて新たにモジュールを追加する必要が生じた時、担当者が考えるのは、できる限りどこにも変更を加えないことです。	7
	3	リリースの時は、毎回固唾を飲む思いをします。	7
	3	それはまさにソフトウェアで「ジェンガをやっているようなものです。	7
	3	直方体のパーツを積んで作った高い塔が倒れないよう、慎重にこそっと手を加えていくのですが、いつかは必ず崩れる運命なのです。	7
	3		7
	3	変更を加える度になぜそう神経質になるかというと、それはシステムがいわば「病気にかかっている」からです。	7
	3	医者に診てもらう必要があります。	7
	3	そうしなければ容態は悪くなる一方でしょう。	7
	3	システムのどこが悪いのか、自分ではよくわかっているのだけれど、怖くて触れないのかもしれません。	7
	3	しかし、何かを改善するのに痛みはつきものです。	7
	3	外科手術をするには、必ずどこかを切る必要がありますが、痛みはあくまで一時的なことであり、その傷は癒えるのです。	7
	3	そして、患者の容態は手術の前より良くなるはずです。	7
	3		7
	3	プログラムのコードでも同じことが言えます。	7
	3	改良を加える問、一時的にどこかが壊れていても誰か気にする人がいるでしょうか。	7
	3	そもそも、そういうむやみに変更を怖がるような態度のせいでプロジェクトがひどい状況に陥っている可能性が高いのではないでしょうかのリファクタリングをすれば時間と労力はかかりますが、プロジェクトが進む中でその投資は十分回収できるでしょうし、何倍もの利益となって返ってくるでしょう。	7
	3	さらに良いことは、「病気の」システムを治すことがプロジェクトのメンバーにとって経験になるということです。	7
	3	その経験によって、システムは本来どうあるべきかを全員が理解するようになり、システムについてのエキスパートになるのです。	7
	3	システムがひどいとただ怒るのではなく、改良できる知識を身につけるのです。	7
	3	作っている人間自身がシステムを嫌っているようでは、そんなものを使わされる側はたまらないでしょう。	7
	3		7
	3	システムの改良にあたってうべきことは、たとえば、内部インターフェースの再定義、モジュールの再構築、コピー&ペーストしたコードのリファクタリングなどが挙げられます。	7
	3	また、依存関係を減らして設計をシンプルにすることなども重要です。	7
	3	コードをシンプルにするため、機能の組み合わせ方が不適切なときによく生じるコーナーケースを減らすというのも有効でしょう。	7
	3	改良はゆっくり少しずつ加えていき、改良の都度テストをします。	7
	3	一度に大幅な変更を加えるのは危険です。	7
	3	それが元で大変な問題が起きてしまい、結局、せっかく途中まで進めた改良を全部やめてしまおうということになりやすいからです。	7
	3		7
	3	大切なのは、外科医が身体を切ることを恐れずに病気を治すように、コードに変更を加えることを恐れず、積極的にシステムを改良していく姿勢です。	7
	3	そういう姿勢は人から人へと伝授しやすいものです。	7
	3	同じような人が増えれば、延び延びになっていた改良プロジェクトが実施に移される、ということがあるかもしれません。	7
	3	チームのメンバーの意識が高まれば、日々、気づいたことをチストアップして皆と共有する、ということも出来るでしょう。	7
	3	これもシステムの質向上につながります。	7
	3	改良プロジェクトを実施するには、会社の上層部を説得することが必要になるかもしれません。	7
	3	「改良してもすぐに目に見える利益が生まれるわけではないが、将来のコスト削減につながり、リリースに要する時間の短縮もできる」ということを説明して納得してもらうのです。	7
	3	こうして、システムの「健康」への留意は常に怠らないようにしましょう。	7
	3		7
	3		7
	3	見られて恥ずかしいデータは使わないこと	5
	3	Rod Begbie	6
	3	夜遅くのことでした。	7
	3	私はページレイアウトのテストのため、サンプルデータを入力していました。	7
	3		7
	3	ユーザ名には、英国のパンクロックバンド、ザ・クラッシュのメンバーの名前を使いました。	7
	3	会社名には、同じく英国のパンクロックバンド、セックス・ピストルスの曲名を使いました。	7
	3	あとはティッカーシンボルを入れるだけです。	7
	3	そこで私は、卑狼な4文字の言葉を大文字で入れることにしたのです。	7
	3		7
	3	そう、皆さんご存知の、”F”で始まる言葉なんかを使ったわけです。	7
	3		7
	3	特に問題はないだろうと思っていました。	7
	3	自分や他のプログラマが面白がって見るだけのものだし、どうせ翌日には「本物」のデータソースに人れ替えることになっていたからです。	7
	3	ところが翌朝、プロジェクトマネージャが件の4文字言葉の表示されている画面のスクリーンショットをとり、あるプレゼンに使ってしまったのです。	7
	3		7
	3	プログラミング中の、この種の「いたずら」や「武労伝」はよくある話です。	7
	3	「まあ誰も見ないのだから」と油断していると、思いがけず多くの人の自に触れてしまうことがあるのです。	7
	3		7
	3	露呈の仕方は様々ですが、いずれにしろ珍しいことではありません。	7
	3	しかし、関わったプログラマ個人や、開発チーム、あるいは会社全体にとっては命取りになりかねません。	7
	3	どんなパターンがあり得るか、例をいくつかあげておきましょう。	7
	3		7
	3	「好事門を出でず、悪事千里を走る」というのは古くから言われることです。	7
	3	今の時代なら、なおさらそうでしょう。	7
	3	誰かの「あら」が見つかれば、その噂は、Digg、Twitter、Flib-flarbなどにより、あっという間に世界中に広まってしまいます。	7
	3	担当者が寝ている間に、タイムゾーンの違う国に広まってしまえば、何も手を打つことはできないでしょう。	7
	3		7
	3	要するに、コードに何かテキストを入力する時は(コメントであれ、あるいはログ、ダイアログ、テストデータであれ)常に「これがもし公になったとして問題にならないか」と自問せよ、ということです。	7
	3	そうすれば、突然、卑狼な言葉が大写しになり、その場にいる全員が赤面するというような事態は防げます。	7
	3		7
	3		7
	3	言語だけでなく文化も学ぶ	5
	3	Anders Norås	6
	3	高校時代の外国語の授業、私はフランス語を選択していました。	7
	3	ただ当時「自分は将来も英語だけで何とかやっていく」と思っていたので、フランス語の授業では3年間ずっと寝続けてしまいました。	7
	3	その何年か後、私はチュニジアに旅行しました。	7
	3	チュニジアの公用語はアラビア語で、かつてフランスの地民地だったことから、フランス語も広く使われています。	7
	3		7
	3	英語が通じるのは、観光地になっているところだけです。	7
	3	言葉が通じず、仕方ないので、私はずっとプールサイドにいて、ジェームズ・ジョイスの大作「フィネガンズ・ウェイク」を読んでいました。	7
	3	この小説は、文体という点でも言語という点でも、とてつもない作品です。	7
	3	40ヶ国語を超える言語を駆使した言葉遊びの連続はまさに驚異であり、読んでいて消耗もします。	7
	3	そして、著者は、外国間の単語やフレーズを多数織り交ぜることにより、自分の表現の幅を大きく広げているとい感じます。	7
	3	また、それはどこか、プログラマである私がしてきたことにも通じます。	7
	3		7
	3	Andy HuntとDave Thomasは、多くの人に影特を与えた著書「逮人プログラマ」の中で、「毎年、新たなプログラミング言語を1つは学ぶこと」と勧めています。	7
	3	私はそのアドバイスに従い、過去何年かの間に実際に数多くの言語を学んできました。	7
	3	そして、その中で「言語を学ぶというのは、ただ文法、構文を学ぶことではなく、その背景にある文化も学ぶこと」という重要な教訓を得ました。	7
	3		7
	3	どのような言語でもFORTRANのように書くことはできます。	7
	3	しかし、言語にはその言語独自の文化というものがあり、真にその言語を知るには、その文化も正しく学ぶ必要があるのです。	7
	3		7
	3	C#を学び始めたばかりのときは、長いMainメソッドと静的なヘルパーメソッドばかりから成るコードを書いてしまうかもしれませんが、恥ずかしく思わなくていいのです。	7
	3	そのかわり「なぜクラスというものが存在するのか」を学び理解する姿勢が重要です。	7
	3	関数型言語で使われるラムダ式が最初なかなか理解できないとしても、怖じ気づくことはありません。	7
	3	ひたむきに、分かるまで使うように努めるのです。	7
	3		7
	3	複数の言語について学ぶと、デザインパターンについての理解も深まります。	7
	3	CのプログラマがC#とJavaを学ぶと、そこではIteratorパターンが一般化され普通に使われていることに気づくでしょう。	7
	3	Rubyなどの動的言語を学べば、動的言語でもやはりVisitorパターンは使うけれど、その実装はいわゆる「GoF本」に載せられた例とは違う見かけになることがわかるでしょっ。	7
	3		7
	3	小説「フィネガンズ・ウェイク」に関しては、「これは読めない」と非難する人もいれば、その文体の美しさを絶賛する人もいます。	7
	3	この本の場合、翻訳版の方がかえって読みやすいかもしれません。	7
	3	原書にあった40ヶ国語以上の言語が1ヶ国語に整理されるのだとしたら、少しは読みやすいとも考えられます。	7
	3	しかし、私にとって皮肉なことに、最初に出た翻訳版はフランス語版でした。	7
	3		7
	3	コードにも同じようなことが言えます。	7
	3	「フィネガンズ・ウェイク」のようなコードを書くのだと言って、一部をPythonで、一部をJava、さらに一部をErlangで書いたとすれば、プロジェクトは大混乱に陥るでしょう。	7
	3	そうではなく、新しい言語から新たな発想を得て、同じ問題に対して違った解決策を見つけられるようになることが大事なのです。	7
	3	新たな言語を学べば、従来から使っていた言語でも、より美しいコードが書けるようになることが多いのです。	7
	3		7
	3		7
	3	死ぬはずのプログラムを無理に生かしておいてはいけない	5
	3	Verity Stob	6
	3	私は以前、C++の例外処理に関し、こんな文章を書いたことがあります。	7
	3		7
	3	不謹慎と思われるかもしれませんが、これは一種の風刺であり、また自分自身の苦い経験から得た教訓の要約でもあります。	7
	3		7
	3	苦い経験とは、自社で作成したC++ライブラリのアプリケーション基底クラスのことです。	7
	3	そのクラスは、何年にもわたり大勢のプログラマが手を加えてきたクラスだもったのですが、問題はプログラマ全員の手が「汚れていた」ことです。	7
	3	そのクラスには、発生後どこでも処理されない例外を一手に引き受けるコードが含まれていました。	7
	3	私たちは、小説「キャッチ=22」の主人公ヨッサリアンのように、「このクラスのインスタンスは、いったん 生まれたら、自らの意志で死なない限り、永遠に生き続けるようにすべきだろう」と判断しました。	7
	3	正確には「判断した」というより、「そう感じた」と言った方がいいかもしれません(判断したというと、この化け物のようなクラスの構造について、私たちが深く考え、あれこれ検討したように聞こえますが、実際はそうではないのです)。	7
	3		7
	3	インスタンスを決して死なせないため、私たちは、複数の例外ハンドラを絡み合わせるという方法を採りました。	7
	3	WindowsのSEH(Structured Exception Handling:構造化例外処理)と、C++のネイテイブの例外処理メカニズムを組み合わせたのです(ネイティブのC++に__try…__exceptという構文はないので、Windowsでこんなものが使えるなんて知りませんでした)。	7
	3	何か予期せぬ事態が起きた時は、何度でも同様のパラメータが渡され、例外処理のコードが繰り返し呼び出されるようにしました。	7
	3	今考えると、try-catchブロックを別のtry-catch ブロックのcatch節の中に書いた時に、何となく嫌な感じがした、という気もします。	7
	3	何となく「正しい道からは外れてしまったな」という感じ、そして「魅力的だけれども、不健康で狂気をはらんだ道に入ってしまったな」そんな感じがしたような気もします。	7
	3	でも、それはきっと後知恵にすぎないでしょう。	7
	3		7
	3	この基底クラスを継承したアプリケーションで何か問題が起きても、その問題は、まるで波止場でマフィアに殺された人間のように、跡形もなく姿を消してしまいます。	7
	3	どんなことが起きたのか、それを知るほんのわずかな手がかりさえも残らないのです。	7
	3	普通ならばダンプが吐かれて状況が記録されるような場合でも、何も残らないのです。	7
	3	後になって(本当に随分に後になってからですが)私たちは自らのしたことの意味を悟り、恥ずかしい思いをしました。	7
	3	そしてその異常なメカニズムを破棄し、代わりに最小限の例外処理と通知をするだけの堅牢なメカニズムを組み込みました。	7
	3	ただ、そうすると今度は、クラッシュが頻繁に起きるようになってその対策が必要になりました。	7
	3		7
	3	こんな話をしても、「それがどうした」と思う読者が多いかもしれません(確かにこんなバカなことをする人はめったにいないでしょう)。	7
	3	しかし、私は最近、インターネット上でこんな人物に遭遇しました。	7
	3	肩書きからして、もう少し物が分かつてもよさそうに思える人です。	7
	3	私はその人とリモートトランザクションのためのJava コードについて議論を交わしたのですが、「コードに何か問題が起きたら、例外はその場で捕まえ、握りつぶせばいい」と彼は主張したのです(私はそれに対し「で、その後どうするんですか? 夕食のおかずにでもするんですか?」と問い返しました)。	7
	3		7
	3	彼は「例外に関する情報をユーザの目に触れさせてはならない(NEVER LET THE USER SEE ANE XCEPTION REPORT)」それがUIデザイナーのおきてだ、と言ってきました。	7
	3	すべてを大文字で打ったところから見て、これさえ言えば話は終わるだろうと思ったようでした。	7
	3	銀行のATMなどで突然ブルースクリーンが出ることがまれに起きますが、そういうATMのコードを書いているのは彼のような人間なんじゃないか、と思ってしまいました。	7
	3	ATMでブルースクリーンが出たりすれば、ブログなどに書かれてその噂はすぐに広まります。	7
	3	開発元の信用は失われ、簡単には戻らないでしょう。	7
	3		7
	3	いずれにしても、もし彼に会うようなことがあれば、会釈だけして、即座にその場を立ち去った方が賢明でしょうね。	7
	3		7
	3		7
	3	「魔法」に頼りすぎてはいけない	5
	3	Alan Griffiths	6
	3	他人のする仕事というのは、どういうものであれ、遠くから見ているとどうしても実際より簡単に思えてしまうものです。	7
	3	自身が開発を経験していないマネージャは、プログラマの仕事を簡単だと思ってしまいますし、逆にマネージメントの経験のないプログラマは、マネージャの仕事を簡単だと思い込んでしまいがちです。	7
	3		7
	3	厄介なのは、今は「プログラマ」でなくても、以前プログラミングをしたことがある人は意外にいるということです。	7
	3	しかし、「ちょっとやったことがある」という程度だと、プログラミング作業の中でも特に難しい部分(つまり自分の頭を使って考える部分)についてはよくわからないものです。	7
	3	少なくともそれをあまり重要とは思わないでしょう。	7
	3	これは、過去何十年もの問、「知識と経験を持った人でないとわからない部分」をプログラミングから排除する努力が続けられてきたおかげでもあります。	7
	3	最も早い時期からその努力をし、特によく知られている人物がGrace Hopperです。	7
	3	Hopperは、まるで暗号のようだったプログラミング言語を、よりわかりやすいものにすべく力を尽くしました。	7
	3	それができれば、専門のプログラマが不要になるのでは、という予測もありました。	7
	3	努力の結果、生まれたのがプログラミング言語、”COBOL”ですが、COBOLの誕生により、専門家は不要になるどころか、その後数十年にわたり、プログラミングによって収入を得る専門のプログラマが多数生まれることになります。	7
	3		7
	3	ソフトウェア開発がこのまま簡単になっていけば、いずれはプログラミングの作業はまったく不要になる、という見方はずっと以前からあり、現在もなくなっていません。	7
	3	この見方は、プログラミングをよく知っている人間から見ると、「あまりに無邪気」としか言いようがないものです。	7
	3	しかし、ついこういう見方をしてしまうのが人間である、ということも同時に言えます。	7
	3	そしてプログラマもやはり人間なので、同じようなことをする時はあるのです。	7
	3		7
	3	プロジェクトには必ず、プログラマが積極的に関わるわけではない作業も多数発生します。	7
	3	たとえば、ユーザの要件を確認することや、予算申請、ビルドサーバのセットアップ、QA環境や本番環境へのアプリケーションのデプロイなどもそうです。	7
	3	業務プロセスやプログラムを古いものから新しいものへ移行することなどもそうでしょう。	7
	3		7
	3	自分が積極的に関わらない仕事に関しては、無意識のうちに簡単だと思ってしまうし、まるで「魔法」のように自動的にできるような錯覚に陥ってしまうのが人間の常です。	7
	3	全て順調なときは、確かに魔法だと思っていてもさほど支障はありません。	7
	3	問題は「魔法が解けた」時です。	7
	3	魔法が解けてしまえば、途端にプロジェクトは頓挫し、混乱してしまいます。	7
	3		7
	3	たとえば、私の関わったプロジェクトでは、常に正しいバージョンのDLLがロードされていなければシステムがまったく動かないのに、誰もそのことを理解していなかったということがありました。	7
	3	問題が頻繁に起こり始めてから見当違いの調査を繰り返し、誤ったバージョンのDLLがロードされているせいで動かないということに気づくまでに何週間もの時間が無駄になりました。	7
	3		7
	3	対照的に、何もかもが常に順調に進む部署がありました。	7
	3	納期には絶対に遅れず、深夜までデバッグに追われるということも、顧客から緊急でバグ修正を求められるということもありませんでした。	7
	3	あまりにスムーズなので、会社の上層部は、物事がまるで自動的に回っているかのように思い込んでしまいました。	7
	3	そして「プロジェクトマネージャなど不要なのでは?」と考えるようになったのです。	7
	3	プロシェクトマネージャがいなくなった後、その部署の仕事ぶりは他と何ら変わらないものになってしまいました。	7
	3	納期には遅れ、バグは大量で、リリース後も絶えずパッチをあてているという有様になってしまいました。	7
	3		7
	3	もちろん、プロジェクトに関わるすべての人の仕事を詳しく知る必要はありません。	7
	3	しかし、たとえその一部でも、知ろうとして損はないのではないかと思います。	7
	3	そして、自分の知らない仕事、自分の直接関わっていない仕事をしている人を尊重するということが大事です。	7
	3		7
	3	忘れてはならないのは、「魔法が解けてしまった時は、誰かがかけなおさなくてはならない」ということです。	7
	3		7
	3		7
	3	DRY原則	5
	3	Steve Smith	6
	3	DRY(Don’t Repeat Your Self：繰り返しを避けること)原則は、プログラミングに関して守るべきとされている原則の中でも特に重要なものと言っていいでしょう。	7
	3	これは、Andy HuntとDave Thomasが、著書「達人プログラマ」の中で提唱した原則です。	7
	3	よく知られたソフトウェア開発のベストプラクティスやデザインパターンの中にも、基本的にな考え方がこの原則と同じものがたくさんあります。	7
	3	開発者は、アプリケーションの中に何らかの「重複」があれば、また、重複が起きそうであれば、それを察知する必要があります。	7
	3	そして、適切なプラクティスや抽象化によってそれを排除する必要があるのです。	7
	3	そのための方法を学べば、よりきれいなコードを書けるようになるはずです。	7
	3		7
	3	アプリケーションを構成するコードはすべて、保守を必要とします。	7
	3	どのコードも将来バグになる危険性を秘めています。	7
	3	重複があると、コードベースは不必要に大きくなり、それにつれて、バグが生じる危険性も高まります。	7
	3	また、システムの構造は、そう意図していないにもかかわらず複雑になってしまいます。	7
	3	重複によりコードベースが大きくなれば、開発に携わる人間がシステム全体を完全に理解することも難しくなります。	7
	3	特に困るのはコードに変更を加える時です。	7
	3	どこかに変更を加えた場合、それとロジック等が重複している箇所にも同様の変更が必要かどうか確認しなければなりません。	7
	3	DRY原則を守れば、そういう事態に陥らずに済みます。	7
	3	DRY原則を守るとは、言い換えれば「すべての知識はシステム内において、単一、かつ明確な、そして信頼できる表現になっていなければならない」という条件を満たすことです。	7
	3		7
	3	ソフトウェア開発に関わる作業の多くは「同じことの繰り返し」です。	7
	3	つまり作業が何度も重複します。	7
	3	この重複は、自動化によって容易に解消できます。	7
	3	DRY原則は、アプリケーションのソースコードだけでなく、開発作業にも適用すべき原則ですが、そのためには自動化が役立つというわけです。	7
	3	たとえばテストは同じ作業の繰り返しになることが多いですが、手作業でそれをやっていては手間も時間もかかり、しかも誤りも起きやすくなります。	7
	3	したがって、可能な限り、テストは自動化すべきなのです。	7
	3	同様に、ソフトウェアの結合(ビルド)も同じ作業の繰り返しになることが多いですが、手作業だと時間がかかり、誤りが起きやすくなります。	7
	3	従ってビルドプロセスも自動化し、しかも頻繁に走らせるべきです。	7
	3	コミットの度に走らせるというのが理想でしょう。	7
	3	手作業だと負担が大きすぎるようなものは、すべて自動化の対象となります。	7
	3	自動化し、かつ標準化するのが望ましいのです。	7
	3	大事なのは、作業を遂行するための方法を1つだけにするということです。	7
	3	そうすれば、手間が省ける上、問題も起きにくいと言えます。	7
	3		7
	3	ロジックの重複には多数の種類があります。	7
	3	たとえば、if-thenやswitchの部分が単純にコピー&ペーストされている場合は、発見するのも解消するのも非常に容易でしょう。	7
	3	デザインパターンの多くは、明らかにアプリケーションの中の重複を減らす、あるいは排除することを目的としています。	7
	3	あるオブジェクトを使用するために整えるべき条件がほぼいつも同じであれば、その場合はAbstract FactoryパターンやFactory Methodパターンを使用すればいいでしょう。	7
	3	オブジェクトのふるまいに様々な種類があり得る、という場合には、長いif-thenを書くよりは、Strategyパターンを使用します。	7
	3	実際、デザインパターンは、同じような問題について何度も繰り返し解決策を考えるという重複が起きないように作られたとも言えます。	7
	3	DRY原則は、データベーススキーマなどの構造にも適用されます。	7
	3	これは、いわゆる「正規化」につながります。	7
	3		7
	3	ソフトウェア開発に関する原則には、他にもDRY原則に関連するものがいくつかあります。	7
	3	OAOO(Once and Only Once:1度、ただ1度)原則はその1つです。	7
	3	これは、コードの機能、ふるまいについてのみ適用される原則で、DRY原則を特殊化したものと考えることもできます。	7
	3	OCP(Open/Closed Principle：開放/閉鎖原則)というのもあります。	7
	3	これは、クラスなどのプログラム単位は、拡張にに対して「開いて(open)」いなくてはならず、反対に、修正に対しては「閉じて(close)」いなくてはならない、という原則です。	7
	3	この原則は、DRY原則が守られている場合にのみ有効です。	7
	3	他には、SRP(Single Responsibility Principle：単一責任原則) という有名な還俗もあります。	7
	3	これは、「クラスに変更を加える理由は2つ以上存在してはならない(1つの変更の理由は常に1つでなければならない)」という原則で、やはりDRY原則が守られている場合のみに有効です。	7
	3		7
	3	DRY原則は、構造、ロジック、プロセス、機能などあらゆる面で、開発者がシンプルなアプリケーションを作る上での基本的なな指針です。	7
	3	この原則を守ることで、シンプルで、品質が高く、保守もしやすいアプリケーションが作りやすくなるのです。	7
	3	状泌によっては、パフォーマンスを上げるため、あるいは何らかの要件(データベースを非正規化しなくてはならないなど)を満たすために、重複がどうしても必要ということはありえます。	7
	3	ただし、現実にすでに目の前にある問題に対処する以外の目的で、DRY原則を破ってはなりません。	7
	3	「こういう問題が起きそうだから原則をあらかじめ破っておこう」ということをしてはいけないのです。	7
	3		7
	3		7
	3	そのコードに触れてはならない！	5
	3	Cal Evans	6
	3	ステージングサーバでのシステムテストに入ってから、自分の書いたコードに問題が見つかり、それを知らせるメールかテストマネージャから届く、そんな経験はプログラマなら誰もがしていると思います。	7
	3	そのメールを見た時にプログラマか最初に思うことは、「すぐにそっちへ行って直させてくれ。	7
	3	どこが悪いかはわかっているから」ではないでしょうか。	7
	3		7
	3	「プログラマがステージングサーパを触ってもいいじゃないか」そう考えるのは一見、間違ってはいないように思えます。	7
	3	しかし、大局的にとらえるとやはりそれは間違いなのです。	7
	3	なぜでしょうか。	7
	3		7
	3	Webシステム開発プロジェクトの環境は、次のようにアーキテクチャ分割されているのが普通です。	7
	3		7
	3	もちろん、実際にはこれですべてではなく、他にもソースコード管理(SCM)や問題管理システム(ITS)などのサーバやサービスなどが色々と関わるのですが、おおまかには上のとおりと考えていいでしょう。	7
	3	上記のように分割されている場合、開発者は(たとえ上級開発者であっても)決して、開発サーバより後の環境に触れるべきではありません。	7
	3	開発の大半は、開発者のローカルマシンで行われます。	7
	3	開発者はローカルマシン上で自分に合ったIDEや仮想マシンを利用し、その他にも独自のツールを使うなど個々に工夫して、良いコードをさくために最善を尽くします。	7
	3		7
	3	SCMへチェックイン後は(自動であれ手動であれ)開発サーバに配備させて、そこで必要に応じてテスト、修正を行うことになります。	7
	3	そのテストにより、全体が問題なく機能するか確認するのです。	7
	3	ここで注意すべきなのは、チェックイン以降は、開発者は基本的にはプロジェクト進行の「傍観者」になるということです。	7
	3		7
	3	コードをパッケージングして、QAチーム向けのステージングサーバに配備するのは、ステージングマネージャの仕事です。	7
	3	開発者が開発サーバより後の開発環境にアクセスすべきではないのと同様、QAチームおよび顧客は、開発サーバ上のものには手を触れるべきではありません。	7
	3	あくまで受け入れテストが出来る状態が整ってからリリースし、配備するのです。	7
	3		7
	3	たとえば「開発サーバ上のシステムをちょっと見てくださいませんか?」と顧客に頼んではなりませ人そのプ口ジェクトでコードを書いている人間が1人だけであれば話は違ってきますが、普通は他にもコーディングをしている人がいるはずです。	7
	3	全員が「いつユーザに見られても大丈夫」という状態でいるとは限りません。	7
	3	開発サーバとステージングサーバの両方にアクセスでさるのは、リリースマネージャだけにすべきです。	7
	3		7
	3	そして、たとえどんなことがあっても、開発者は本番環境に触れてはなりません。	7
	3	問題が起きた場合でも、それを修正するのは基本的に運用チームの仕事であり、仮に開発者が修正にあたるにしても、それは運用チームからの依頼であるべきです。	7
	3	そして修正をSCMへチェックインした後で、彼らがSCMからパッチを作成して運用するのです。	7
	3	私がプログラマとして経験した中でも「最悪」と言える事件は、誰か(まあ、それは私、なんですが。	7
	3		7
	3		7
	3	)が、この「必ずSCMへのチェックインしてSCMからパッチを作る」というルールを守らなかったために起きたものでした。	7
	3	たとえシステムのどこかが壊れても、本番環境でそれを修理しようなどと考えてはいけません。	7
	3		7
	3		7
	3	状態だけでなく「ふるまい」もカプセル化する	5
	3	Einar Landre	6
	3	システム理論(Systems Theory) において、大規模で、複雑な構造のシステムを扱う際に、特に重要とされるのが「封じ込め(Containment)」です。	7
	3	ソフトウェア開発に携わる人なら、封じ込めもしくは「カプセル化」がいかに重要であるかは十分に理解しているでしょう。	7
	3	プログラミング言語も、やはり封じ込めを考慮した作りになっています。	7
	3	サブルーチンや関数、モジュール、パッケージ、クラスなどの要素を組み合わせてコードが書けるようになっているのはそのためです。	7
	3		7
	3	モジュールやパッケージは大規模なカプセル化に対応し、一方、クラスやサブルーチン、関数などは、もっときめの細かいカプセル化に対応します。	7
	3	長年の経験でわかったのですが、そうした要素の中でも、開発者にとって正しく使うのが最も難しいのは「クラス」のようです。	7
	3	mainメソッドだけで3000行もあるようなクラスや、プリミテイブ型のsetメソッドとgetメソッドだけから成るようなクラスは決して珍しくありません。	7
	3	そういうコードを見れば、関わっている人間がオブジェクト指向を十分に理解していないことがすぐにわかります。	7
	3	オブジェクトの「モデル」としての側面がまったく活かされていないからです。	7
	3	POJO (Plain Old Java Object)、POCO(Plain Old C# ObjectまたはPlain Old CLR Object)という言葉に日頃から慣れ親しんでいる開発者にとって、この言葉は「オブジェクト指向は、モデリングパラダイムである」という主張が込められた言葉であり、その原点に返るべきという主張が込められた言葉です。	7
	3	オブジェクトはあくまでシンプルなものであるべきですが、「シンプル」と「何も考えていない」は大きく違います。	7
	3		7
	3	オブジェクトは、状態と「ふるまい」の両方をカプセル化できます。	7
	3	また、ふるまいがどういうものになるかは、その時々の状態によって変わります。	7
	3	「ドアオブジェクト」を例に考えてみましょう。	7
	3	ドアには、「閉じている」、「開いている」、「閉まる途中」、「開く途中」という4つの状態があります。	7
	3	また、ドアの操作には、「開く」と「閉じる」の2種類があります。	7
	3	ただ同じ「開く」や「閉じる」であっても、その時々のドアの状態、によってふるまいは違ってきます。	7
	3	このように、個々のオブジェクトが元来どういう特性を持ってい るかをよく検討すれば、設計の作業は理論的にはさほど難しいものではなくなるはずです。	7
	3	突き詰めると、すべきことは2つしかありません。	7
	3	1つはオブジェクトへの責務の割り当て、もう1つは他のオブジェクトへの責務の委譲です。	7
	3	それにはオブジェクト間の相互作用についてのプロトコルが関わってきます。	7
	3		7
	3	オブジェクト指向開発の経験が浅い開発者は、上のようなビジネスルールをすべて1つのオブジェクトに詰め込んでしまいます。	7
	3	そして、そのオブジェクトにOrderManager、OrderServiceといった名前をつけるのです。	7
	3	そういう設計をした場合、Order、Customer、Itemといったクラスは、「レコード型」とほとんど変わらないことになってしまいます。	7
	3	3つのクラスからはロジックが完全に排除され、数多くのif-then-elseから成る1つの大きな手続き型メソッドに密結合してしまうでしょう。	7
	3	そんなメソッドではバグが発生しやすい上、保守も難しくなります。	7
	3	なぜかというと、「ふるまいのカプセル化」がまったくできていないからです。	7
	3		7
	3	状態だけをカプセル化しでも、ふるまいのカプセル化ができていなければ意味がありません。	7
	3	プログラミング言語には、そのための機能が用意されているので、是非、積極的に利用すべきです。	7
	3		7
	3		7
	3	浮動小数点数は実数ではない	5
	3	Chuck Allison	6
	3	浮動小数点数は、数学でいうところの「実数」とは違います。	7
	3	PascalやFortranなどプログラミング言語によっては「実数」という名前で呼ばれることもありますが、厳密には実数ではないのです。	7
	3	実数は、まず精度が無限です。	7
	3	完全に連続していて、「桁落ち」もありません。	7
	3	一方、浮動小数点数の精度は有限です。	7
	3	実数というよりは、むしろ整数に近いと言っていいでしょう。	7
	3	いわば「非常に奇妙な整数」です。	7
	3	「非常に奇妙」というのは、数と数の感覚が、通常の整数とは違って均等ではないからです。	7
	3		7
	3	たとえば、「2147483647」という数(符号付き32ビット整数の最大値)を、32ビットの浮動小数点型変数(仮にxとします)に代入し、xの値を出力したとします。	7
	3	すると、その結果は「2147483648」となります。	7
	3	x-64を出力しても、結果はやはり「2147483648」になり、x-64を出力すると、結果は何と「2147483520」になってしまいます。	7
	3	なぜでしょうか?それは、この範囲では、数の間隔が「128」になっていて、浮動小数点数の演算では、最も近い数値への「丸め」が行われるためです。	7
	3		7
	3	浮動小取点数において、数と数の間隔がどのようになっているかを正しく把握しておけば、「演算結果が想定と大きく異なってしまう」という起こりがちな間違いを防ぐことが出来ます。	7
	3	たとえば、方程式の探索などのような反復計算の際、定められた以上の精度を求めるようなコードを書いても意味はありません。	7
	3	数と数の間隔が広すぎれば、永久に求める答えは得られず、無限ループに陥ってしまいます。	7
	3		7
	3	浮動小数点政は、実敬の近似値です。	7
	3	つまり、誤差が生じることは避けられないということです。	7
	3	「丸め」によって生じる誤差が原因で、演算結果が予測とまったく違って驚くことは珍しくないのです。	7
	3	たとえば、ほとんど問じ大きさの数値どうしの演算をしたとします。	7
	3	その場合、最上位の桁は、互いに相殺し合い、最下位の桁にあった数(丸めによる誤差を含んだ数)が最上位の桁にまで繰り上がる、ということが起きます。	7
	3	この演算結果を踏まえてさらに演算を重ねていくと、誤差はどんとん大きくなっていってしまいます。	7
	3	こういう悲惨な結果を防ぐには、自分の書いたコードのアルゴリズムをよく確認する必要があります。	7
	3	例を1つあげておきましょう。	7
	3	方程式「x2-100000x+1=0」を、二次方程式の解の公式を使って解くとします。	7
	3	この場合、式「-b+sqrt(b2-4)」のオペランドの大きさはいずれもほぼ同じなので、代わりに、根「r1=-b-sqrt(b2-4)」を計算して、その後 にr2 = l/r1を求めることができます。	7
	3	二次方程式「ax2+bx+c-0」の場合、根は必ず「r1r2=c/a」を満たします。	7
	3		7
	3	誤差が大きくなっていくという現象は、もっと目立たないかたちで起きることもあります。	7
	3	仮に、exを、単純に「1+x+x2/2+x3/3!+･･･」という式で計算するライブラリがあったとします。	7
	3	xが正の数であれば、この方法でも問題は起きないのですが、もしxが絶対値の大きい負の数であったらどうなるかを考えてみましょう。	7
	3	その場合は、偶数番目の項の演算結果は大きな正の数になり、そこから、奇数番目の項の演算結果を差し引くことに なります。	7
	3	それだけでは特に誤差が生じるわけではありません。	7
	3	ただ問題は、偶数番目の項の演算結果に対する丸めです。	7
	3	演算結果が大きな数であれば、かなり上位の桁で丸めが行われてしまうのです。	7
	3	このことから、最終的な演算結果は、正の無限大に向かつて大きくなり、本来得られるべき結果とは大きく異なってしまいます。	7
	3	この問題を解決する方法は簡単です。	7
	3	xが負の数の場合はex = 1/e 1x1 を計算するようにすればいいのです。	7
	3		7
	3	最後に、金融関係のアプリケーションには浮動小数点数を使うべきではないということも書いておくべきでしょう。	7
	3	pythonやC#に、Decimalクラスが用意されているのはそのためです。	7
	3	浮動小数点欽は、元々、科学技術計算を効率的に行うことを目的としたものです。	7
	3	しかし、正確さを欠いていては、効率がいくら良くても価値はありません。	7
	3	浮動小数点数を使うときは、どういう時に丸めの誤差が出るかをよく知り、その知識を踏まえた上でコーディングをすべきです。	7
	3		7
	3		7
	3	オープンソースプロジェクトで夢を実現する	5
	3	Richard Monson+Haefel	6
	3	仕事でソフトウェア開発をしている人は大勢いますが、その中に、本当に自分の希望どおりのソフトウェアを作ることのできる立場にいる人は多くはないでしょう。	7
	3	夢と現実は違っているものです。	7
	3	たとえば、本当はGoogleやApple、Microsoftなどで働いてみたいとう希望をを持ちながら、今は大手の保険会社から発注されたシステムを作っている、そんな人もいるはずです。	7
	3	実は自分の会社を興して、次の時代の中心をなすような斬新なソフトウェアを作ってみたい、と思っているけれど、今は別の仕事をしているという人もいるかもしれません。	7
	3	ただ、今の仕事をそのまま続けていても、なかなか希望に近づくものではありません。	7
	3		7
	3	幸い、希望. に近づく方法はあります。	7
	3	それは「オープンソースプロジェクト」に参加する、という方法です。	7
	3	オープンソースプロジェクトは少なくともすでに何千という単位で存在し、その多くは非常に活発に活動しています。	7
	3	オープンソースなら、自分の好きなタイプのソフトウェアに関われる可能性は高いでしょう。	7
	3	たとえば、OS の開発プロジェクトは10以上あるので、OSに興味がある人ならすぐにでもどれかを選んで参加すればいいわけです。	7
	3	その他、音楽、アニメーション、暗号、ロボット工学、ゲーム(スタンドアロンのゲームもあれば、オンラインゲームもあります) 、携帯電話など、どんな分野であっても、探せば1つは関連するプロジェクトを見つけられるはずです。	7
	3		7
	3	もちろん、世の中には「うまい話」というのはありません。	7
	3	オープンソースプロジェクトに関われば、自分の時間を多少なりとも犠牲にする必要が出てきます。	7
	3	まさか昼間会社にいる時に関係ない作業をするわけにはいかないからです。	7
	3	昼間は相変わらず、今までと同じように社員としての責任を果たさなくてはなりません。	7
	3	またオープンソースに貢献しでも、お金になることはまずありません。	7
	3	確かに中には、お金になっている人もいます が、大半はそうではないのです。	7
	3	つまり、自分の時間をタダで差し出さなくてはならないということになります(しかし、ゲームをする時間やテレビを見る時間を削るくらいは何でもないでしょう)。	7
	3	オープンソース活動に熱心に取り組めば取り組むほど、自分の本当の希望に気づくのが早くなるでしょう。	7
	3	しかし、プロジェクト参加の前には、会社との雇用契約をよく確かめておく必要があります。	7
	3	会社によっては、たとえ勤務時間外であっても、参加できるプロジェクトに制限を設けているところもあるからです。	7
	3	また、活動中は「知的財産」つまり著作権、特許、商標、企業秘密などに関する法律に違反しないよう、十分注意しなくてはなりません。	7
	3		7
	3	オーブンソースは、やる気のあるプログラマにとっては、大きなチャンスを与えてくれるものです。	7
	3	まず、オープンソースプロジェクトに参加すれば、多くの人の仕事ぶりを目の当たりにできます。	7
	3	たとえば、同じ問題を解決するにしても色々な方法があり得ること、目的は同じでも自分と他人とではやり方が違うのだということが学べます。	7
	3	何より大きいのは、他人の書いたコードから多くを学ぶことができるということでしょう。	7
	3	もう1つ大事なのは、プロジェクトに自分のコードやアイデアを提供できるということです。	7
	3	どんなに素晴らしいコードを書いても、どんな素晴らしいアイデアを出しても、すべてが受け入れられるとは限りません。	7
	3	しかし、そうしてアイデアを練り、コードを書いて提供するだけでも、学ぶことはとても多いはずです。	7
	3	自分と興味を同じくする人に出会えるというのも、大きな利点でしょう。	7
	3	出会う人の中には、素晴らしい技術を持った優秀な人も多くいるに違いありません。	7
	3	出会った人との友情は生涯続く可能性があります。	7
	3	そして、能力を存分に発揮し、プロジェクトに大きく貢献すれば、それは立派な「実務経験」となります。	7
	3	本業に加え、自分がまさに興味を持っている技術分野での実務経験を積むことができるのです。	7
	3		7
	3	オープンソースプロジェクトへの参加はとても簡単です。	7
	3	開発に必要なツール群(ソースコード管理ツール、エディ夕、プログラミング言語、ビルドシステムなど)は、どれもドキュメントが多数存在しています。	7
	3	参加するプロジェクトを決めてから、そのプロジェクトが使っているツールに関して学べばいいでしょう。	7
	3	多くの場合プロジェクト自体に関するドキュメントは量が少ないのですが、あまり困りません。	7
	3	ソースコードを読んで学ぶことができるからです。	7
	3	システムについて早く理解したいのなら、ドキュメントを充実させることでプロジェクトに貢献するのも1つの方法です。	7
	3	あるいは、プロジェクトにテストコードを書くことで貢献を始めるという方法もあります。	7
	3	テストコードを書くというと、あまり楽しそうには思えないかもしれません。	7
	3	しかし実際は、他人の作ったソフトウェアについて学ぶのに、テストコードを書くほど効果的な方法は無いのです。	7
	3	努力して良いテ ストコードを書き、バグを見つけ、修正を提案する。	7
	3	プロジェクトを通じて友人を作り自分の好きなソフトウェアに関わることで、自分の希望も早く実現に近づくでしょう。	7
	3		7
	3		7
	3	API設計の黄金律	5
	3	Michael Feathers	6
	3	APIの設計は簡単ではありません。	7
	3	特に規模が大きいと困難になります。	7
	3	何百、何千というユーザが要る場合には、将来APIに変更を加えた際の影響についても考慮する必要があります。	7
	3	変更を加えた時、その影響でAPIを利用するクライアントコードが動かなくなるようでは困るのです。	7
	3	逆に、APIのユーザが開発側に与える影響についても考慮が必要です。	7
	3	たとえばAPIを構成するクラスの内部で、そのクラス自身のメソッドを呼び出したとします。	7
	3	その場合、ユーザがそのクラスを継承してサブクラスを作り、メソッドをオーバライドするという事態も考慮しなくてはなりませんし、その場合は実に面倒なことになります。	7
	3	APIの開発側は、もはやそのメソッドに変更を加える事ができません。	7
	3	ユーザが、そのメソッドに元とは違った意味を与えてしまっているからです。	7
	3	このように、ユーザの使い方によって、その後の開発側の内部実装に制約が加えられてしまうことがあり得るのです。	7
	3		7
	3	この種の問題が起きないようにする方法はいくつかあります。	7
	3	最も簡単なのはAPIを「ロックする」という方法です。	7
	3	Javaの場合は、クラスやメソッドの大半をfinal宣言してしまえばいいでしょう。	7
	3	C#の場合は、クラスやメソッドをsealed宣言します。	7
	3	言語を問わず、ともかくAPIをシングルトン、あるいはスタティックファクトリメソッドばかりにして、ユーザがその振る舞いをオーバライド出来ないようにしてしまうことは出来ます。	7
	3	そうすれば、ユーザの使い方によって開発側の行動が制限されるという事態は防げます。	7
	3	これで一応問題は解決するように思えますが、しかし本当にそう言い切れるでしょうか。	7
	3		7
	3	開発作業におけるユニットテストの重要性は、過去10年の間に徐々に認識されるようになってきました。	7
	3	しかし、まだ認識が十分に広まったとはいえません。	7
	3	その証拠はいたるところに見つかります。	7
	3	試しに、どれでもいいので、サードパーティのAPIを利用している未テストのクラスを選び、そのクラスに対応するユニットテストを書いてみてください。	7
	3	ほぼ間違いなく問題が起きるはずです。	7
	3	問題が起きるのは、おそらくAPIを利用する部分でしょう。	7
	3	糊のついた紙が勝手なところに張り付くような具合に、APIを利用する部分がどうしても邪魔になるのです。	7
	3	APIクラスに「なりすます」方法がないので、自分のコードがAPIクラスとどういうやりとりをしているのかを検出することができず、かつテストに必要なAPIからの戻り値も創りだすことができないのです。	7
	3		7
	3	このような状況もいずれ改善されるかもしれません。	7
	3	しかしそのためには、皆がAPIの設計に際し、テストを本当のユースケースの1つとみなすことが必要です。	7
	3	それは残念ながら、単に自分が書いたコードをテストするより難しいことです。	7
	3	「APIを提供するときは、API自身のテストだけでなく、必ずそのAPIを利用するコードのユニットテストも書く」APIの設計者は、これを黄金律にして欲しいと思います。	7
	3	この黄金律を守れば、APIの利 用者がユニットテストに際してどのような問題に直面するかを事前に察知できます。	7
	3		7
	3	API開発時にこうしておけば、APIのユーザは必ず簡単にユニットテストができる、というような方法はありません。	7
	3	確かにstatic宣言やfinal宣言、sealed宣言といった方法も場合によっては有効です。	7
	3	しかし、重要なのはまずAPIを開発する側が「APIを利用するコードのユニットテストは難しい」と認識することです。	7
	3	それには、自らその難しさを体験するのが一番なのです。	7
	3	一度体験すれば、その後は「テストの難しさ」を設計上の課 題の1つととらえ、他の課題と同様に考慮するようになるはずです。	7
	3		7
	3		7
	3	超人の神話	5
	3	Ryan Brush	6
	3	ソフトウェア業界で長く仕事をしている人なら、一度はこんな質問を受けたことがあるのではないで、しょうか。	7
	3		7
	3	こういう質問をする人が、スタックトレースやエラーログを提示してくれたり、問題の起きた状況について、詳しく説明してくれたりすることはまずありません。	7
	3	あなたを、自分とは別世界の人間だと考え、十分な情報を与えられなくても、少し話を聞いただけで問題を解決できると思っているのかもしれません。	7
	3	超人だから何でもすぐにわかる、と思っているのかもしれません。	7
	3		7
	3	ソフトウェアのことをよく知らない人が、こういう質問をするのは仕方のないことでしょう。	7
	3	彼らにとって、コンピュータを自在に操るのは魔法に近いことだからです。	7
	3	しかし、問題なのは、実はプログラマが同士の質問をすることも珍しくない、ということです。	7
	3	たとえば、設計に関して「私は在庫管理システムを作っているのですが、楽観的ロックを使った)方がいいでしょうか?」というような質問をする人は多いのです。	7
	3	皮肉なことに、こういう場合、質問をする側の方が、質問される側よりも、質問されたことがらについてよく知っていることが多いのです。	7
	3	おそらく質問した側は、問題となっている状況についても、システムの要件についてもよく知っています。	7
	3	現状取り得る戦略にどのようなものがあって、それぞれにどんな利点と難点があるかといったことについても、その気になれば資料で調べることができます。	7
	3	にもかかわらず、まったくそういう情報や資料を持たない人に対して質問をし、まともな答えが返ってくることを期待してしまうのです。	7
	3		7
	3	何も情報を与えられなくても、あらゆる質問に答え、あらゆる問題を解決できる。	7
	3	そんな人はいません。	7
	3	ソフトウェア業界にそんな「超人」がいるという神話は、そろそろ一掃すべきでしょう。	7
	3	どれほど優れたプログラマも人間であることには違いはないのです。	7
	3	彼らも他の人と同じように、論理的に考え、体系的に分析をしない限り、どんな問題も解決できないのです。	7
	3	経験を積んでいる分、勘がはたらくため、普通の人より早く正解にたどり付けることはありますが、基本的には他の人と同じです。	7
	3	どれほど素晴らしいプログラマであっても、はじめから十分な知識と技術を持っていたわけではありません。	7
	3	最初はごく普通の人だったはずです。	7
	3	今は超人に見えるかもしれませんが、それは長い時間をかけて学び、自分を磨いてきたからです。	7
	3	賢い人が長い間、強い好奇心を持ち続けた結果、超人に見えるようになったと言っていいでしょう。	7
	3		7
	3	権かに、生まれっき持っている才能に個人差はあります。	7
	3	世の中にいるハッカーの多くは、元々凡人より賢く知識豊富で、仕事をやり遂げる能力も高い人です。	7
	3	それでも「この世のどこかに超人がいる」という神話はそろそろ打ち壊すべさでしょう。	7
	3	超人はいないと思うようになれば、皆の行動は必ず良い方向に変わります。	7
	3	たとえば、共に仕事をしている人が自分よりはるかに賢いとわかっている時でも「何も言わなくてもわかってくれる」とは考えなくなります。	7
	3	手間をかけてでも現状についての情報を十分に集め、その人に伝えるはずです。	7
	3	情報が十分に与えられれば、彼らは持てる能力を存分に発揮できます。	7
	3	今、何が障害になって物事が進まないのか、それが常に具体的に明確に示されるようになるわけです。	7
	3	問題が何なのかを具体的に示すこともなく、ただ超人が魔法を駆使して解決してくれるのを待つ、ということはなくなるのです。	7
	3	これは、問題解決の過程がだれからも見えるということでもあります。	7
	3		7
	3	ソフトウェア業界には「超人の神話」を意図的に広めている人たちもいます。	7
	3	彼らは確かに頭の良い人たちなのですが、業界の発展にとっては大きな障害でしょう。	7
	3	神話を広めるのは、自尊心を満足させるため、あるいは顧客や雇用主から見た自らの価値を高めるための戦略かもしれません。	7
	3	しかしこの態度は、皮肉にも彼ら自身の価値を下げてしまいます。	7
	3	ソフトウェア産業、そして同僚たちの成長にとってはマイナスになるからです。	7
	3	超人は必要ありません。	7
	3	必要なのはエキスパートです。	7
	3	積極的に自分以外にもエキスパートを育てようとする意志を持ったエキスパートです。	7
	3	そういう人がいてくれれば、凡人が力をつけ、活躍できる可能性が生まれるでしょう。	7
	3		7
	3		7
	3	ハードワークは報われない	5
	3	Olve Maudal	6
	3	プログラマという仕事は、時に、懸命に働いても意味がない、ということかあります。	7
	3	長時間オフィスにいれば、プロジェクトに多大な貢献をしているような錯覚に陥ることもあゐし、同僚たちもそう思ってくれることがあります。	7
	3	しかし事実はまったく逆で、自分の働く時間や労力を減らせば減らすほど、プロジェクトへの貢献は大きくなると言えるのです。	7
	3	ときには、頑張って働くよりも、働かずに済む努力をした方が、はるかに大きな貢献ができることもあります。	7
	3	神経を集中させる時間、製品を産み出すのに使う時間が週に30時間を超えるようなら「自分は働き過ぎだ」と考えるべきでしょう。	7
	3	自分のかけている労力を減らすことを検討する必要があります。	7
	3	もっと効率的に働く方法、少ない労力と時間で多くを生み出す方法を探さなくてはならないということです。	7
	3		7
	3	一見してこれは直感に反する話なので、異を唱える人もいるでしょう。	7
	3	しかし、プログラミング、ソフトウェア開発という仕事の特性を考えれば、なぜこのように言えるかがわかります。	7
	3	プログラミング、ソフトウェア開発は、取り組みながら絶えず学ぶということが出来る仕事です。	7
	3	仕事をすればするほど、問題領域についての理解は深まり、同じ目的を達するために必要な労力と時間は徐々に減っていきます。	7
	3	仕事が効率化されるのです。	7
	3	自分の仕事にどんな無駄があるかを常に観察し、その結果を後の仕事に反映させていけば、着実な効率化がはかれます。	7
	3		7
	3	プログラミングのプロの仕事は「舗装された道路を、あらかじめ定められたゴール地点めざして猛烈に走る」というようなものではありません。	7
	3	ソフトウェア開発プロジェクトは通常、オリエンテーリングをしながらマラソンをするようなものです。	7
	3	しかも走るのは時間で、頼みにするのは、大雑把な地図だけです。	7
	3	一方向に闇雲に、しかもすごいスピードで走れば、感心してくれる人はいるでしょう。	7
	3	しかしそれでプロジェクトが成功するわけではありません。	7
	3	第一、後先を考えずに走って途中でペースが極端に落ちることがあっては困ります。	7
	3	一定のペースで走りながら、自分の現在地と向かっている方向を常に確認し、コースを絶えず微調整していくことが大事なのです。	7
	3		7
	3	学ぶのは特定のプロジェクトについてだけではありません。	7
	3	ソフトウェア開発や、プログラミング技術全般についてもずっと勉強を続ける必要があります。	7
	3	勉強の手段は様々です。	7
	3	本を読むのもいいでしょうし、カンファレンスへの参加や、他のプログラマとの情報交換なども役立ちます。	7
	3	新たな実装テクニックを試したり、作業の効率化に役立ちそうなツールを探したり、使い方を調べるといったことも大事でしょう。	7
	3	脳外科医や航空機のパイロットと同じく、プロのプログラマなら、知識と技術の研鑽を怠ってはならないのです。	7
	3	それには主に、帰宅後や休日などの時間を利用することになります。	7
	3	会社の仕事で夜遅くまで、残っていたり、休日出勤をしたりしていたりすると、それができなくなります。	7
	3	 脳外科医が週60時間も執刀していたとして、そんな医者にかかりたいと思うでしょうか? かかりたい人はいないはずです。	7
	3	プロには、備えるための時間、知識と技術を高める時間がどうしても必要なのです。	7
	3		7
	3	仕事には長い時間を書けず、集中して短い時間で終わらせるように心がける。	7
	3	より効率的な問題解決方法を探す努力を常にする。	7
	3	プロジェクトに貢献するというのはそういうことです。	7
	3	技術力を向上させ、自分の行動パターンを振り返り、改善に努めることも、プロジェクトにとってプラスになるでしょう。	7
	3	決しで、ケージの中のハムスターのように、ただその場で車輪を回転させているだけ、というような仕事をすべきではありません。	7
	3	そんなことをすれば、自分自身とプログラマという職業を貶めることになります。	7
	3	プロのプログラマが週60時間、ずっと神経を集中させてひたすらコードを書き続けるというのは、とても賢明なこととは言えないでしょう。	7
	3	プロはただ、がむしゃらに働けばいいというものではありません。	7
	3	プロの仕事には、入念な準備と効率化のための努力、そして日々の反省と絶え間ない変化が必要なのです。	7
	3		7
	3		7
	3	バグレポートの使い方	5
	3	Matt Doar	6
	3	ソフトウェアには必ず「バグ」があります。	7
	3	場合によって「不具合」「設計上の副作用」などと別の呼び方をされることがありますが、ともかく絶対にバグとは無縁でいられません。	7
	3	つまり、プロジェクトを円滑に進める上で、バグレポートの作成が不可欠になるということです。	7
	3	バグレポートには何が求められるのか、どのように書けばいいのかを知っておくのはとても重要なのです。	7
	3		7
	3	バグレポートには、必ず次の3つのことを書く必要があります。	7
	3		7
	3	バグレポートはもちろん、バグについて伝えるものですが、レポートを見れば、書いたのがどういう人かも同時に伝わります。	7
	3	詳細で、質の良いレポートを書けば、自分の評価も高まるでしょう。	7
	3	ぶっきらぼうに、怒りをぶちまけただけのレポート(「この関数は最低!」などとしか書いてない)では、人格を疑われることにもなります。	7
	3	書いた人間がとても不機嫌であることは伝わりますが、ほとんど何の役にも立ちません。	7
	3	状況が詳しく説明され、バグが容易に再現できるよう配慮されたレポートならば、逆に皆の尊敬を集めるはずです。	7
	3	たとえそれで、リリースができなくなっても、恨まれることはないでしょう。	7
	3		7
	3	バグレポートを作成するのは、誰かと対話するためです。	7
	3	対話をするためには、そのバグが発生するにいたる過程をすべて相手に知らせる必要があります。	7
	3	同じ情報を共有しなくては対話にならないからです。	7
	3	バグレポートは、決して誰かを責めたり、バグが存在するコードを批判したりするためのものではありません。	7
	3	バグについて、より多くの情報を得ること、自分の知らなかったことを知ること、それがバグレポートの目的です。	7
	3		7
	3	バグのステータスを変更すれば、たとえばステータスを「未解決」から「解決済み」に変更すれば、それは自動的に「自分は、そのバグについての見解を変えた」という多くの人へのメッセージになります。	7
	3	そのメッセージには、時間と労力をかけてでも、見解を変えた理由を添えておくべきでしょう(「なぜ解決済みにすべきと考えたのか」など)。	7
	3	そうしておけば、マネージャや顧客をいら立たせることもないし、あとで彼らを説得するため に時間を費やす必要もなくなります。	7
	3	同様に、バグの優先度を変更した場合も、やはりそれは自動的に皆へのメッセージになります。	7
	3	注意すべきなのは、バグの優先度を下げたところで、そのバグを抱えた製品の使用頻度が上がるわけではないということです。	7
	3		7
	3	バグレポートを書く際は、1つの欄にあれこれと情報を詰め込みすぎないように注意します。	7
	3	たとえば、「件名」欄に”VITAL :”(vital :致命的) などと書いて、それで、バグの重要度を示す、というようなことを勝手にしない方がいいでしょう。	7
	3	確かに、これでバグレポートがソートしやすくなっていいかもしれませんが、他の人が真似をする時に、微妙に表記を変えてしまうこと(大文字を小文字に変えたり、以後のコロンを抜かすなど)が必ず起きます。	7
	3	別のレポートに記述を流用する際に、”VITAL: “をいちいち削除しなくてはならない可能性もあります。	7
	3	何か情報を追加したい場合には、新たに欄を作った方がいいでしょう。	7
	3	そして、その欄の用途を書いたドキュメントも作っておくのです。	7
	3	そうすれば、他の人が同様の欄を重複して作ってしまうということは防げます。	7
	3		7
	3	バグレポートの数が増えてくれば、プロジェクトチームのメンバー全員が必要なレポートを確実に見つけ出せるよう、そのための手段も用意しなくてはなりません。	7
	3	通常は、レポート検索のためのクエリを作ることになります。	7
	3	クエリには、すぐそれとわかる名前をつけ、全員が同じものを使うようにすべきです。	7
	3	クエリに何か変更を加える際は、その度にチーム全員に何をどう変更するのかを通知します。	7
	3		7
	3	一つ注意すべきなのは、「バグ数は何かの単位、基準ではない」ということです。	7
	3	コードの行数が労力を示していないのと同じことです。	7
	3		7
	3		7
	3	余分なコードは決して書かない	5
	3	Pete Goodlife	6
	3	「より少ないことは、より豊かなこと(Less is more)」。	7
	3	言い古された格言ですが、確かに真実です。	7
	3		7
	3	たとえば、一部のコードを削ることで、かえってコードベースの質が向上するということもあります。	7
	3	私も実際にコードベースをそういう方法で改良したことがあります。	7
	3		7
	3	今日のソフトウェア開発は、YAGNI (You Ain’t Gonna Need It :それは多分、必要ない)をはじめとするXP (eXtreme Programming) のプラクティスに従って行われることが増えています。	7
	3	ただ、人間のすることなので、どうしても時々は、プラクティスに従わずに作業をしてしまうことがあるのです。	7
	3		7
	3	以前、ある製品を開発した時、一部のタスクの実行に時間がかかりすぎるという問題が起きたことがありました。	7
	3	本来は、ほぼ瞬時に完了するはずの簡単なタスクです。	7
	3	原因は、実装をやりすぎていたことにありました。	7
	3	ベルやホイッスルなどといった余分な付属機能を加えすぎていたのです。	7
	3	作った時にはステキなアイデアに思えたのですが、結局は無駄でした。	7
	3		7
	3	この時は、不要と思われるコードを削ることで、実行速度を上げることに成功しました。	7
	3	余分な機能をなくすことで、コードベース全体の「エントロピー」を下げた、と言うこともできます。	7
	3	作業の間に何も壊していないことは、ユニットテストが教えてくれました。	7
	3		7
	3	これは、コードをシンプルにすることの効用が実によくわかる例だと言えます。	7
	3		7
	3	しかし、そもそもなぜ、不要なはずのコードが書かれたのでしょうか? あとで余分と判断されたとはいえ、プログラマはその時必要だと思ったからそのコードを書いたわけですが、なぜそう思ったのでしょうか。	7
	3	またレビューやペア作業で見過ごされたのはなぜでしょうか?それはおそらく、次のような理由ではないかと考えられます。	7
	3		7
	3	常に考える必要があるのです。	7
	3	いま自分が書いているコードは本当に必要なものなのか、と。	7
	3		7
	3		7
	3	最初が肝心	5
	3	Marcus Baker	6
	3	私は他人の仕事にはまったく興味がありません。	7
	3		7
	3	私の目の前には解決すべき問題が山と積まれているのです。	7
	3	To-Doリストーは恐ろしく長くなっています。	7
	3	とても他人のことまで考えてはいられません。	7
	3	そんな私がもし他人のWebサイトにアクセスするとしたら、その理由は、まず間違いなく自分の抱えている問題の解決に役立ちそうだからです。	7
	3	多分、自分の抱える問題の解決に役立ちそうなソフトウェアがそこで手に入るという噂でも耳にしたのでしょう。	7
	3	かなり疑り深い人ですから、きっと大して役には立たないだろうと思いつつアクセスしているはずです。	7
	3		7
	3	サイトにアクセスをしたら、私はまずタイトルを見て、次に、どこかに青い下線のついた”Download Now”という文字列がないかを探すでしょう。	7
	3	私は通常、英国のIPアドレスからLinuxのブラウザを使ってWebサイトにアクセスします。	7
	3	なので、できればヨーロッパのミラーサイトからLinuxバージョンをダウンロードしたいと思っています。	7
	3	しかし、そのあたりのことについて、逐一希望を尋ねられて答えるのは面倒です。	7
	3	”Download Now”をクリックしたら、あとはダウンロード先のフォルダをタイアログで選択するたけで他に何もしなくてもいいというのが理想です。	7
	3		7
	3	人が何かをする時には、費用対効果が非常に大切な要素になります。	7
	3	皆自分の中に基準があって、費用対効果がその基準を上回りそうな行動は取りますが、基準以下と判断した行動は普通取りません。	7
	3	どんなに有用なものがあっても、それを使うのに手間がかかりすぎると判断すれば、他のもっと手間のかからないものを探すでしょう。	7
	3	つまり、有用性が同じであれば、手間のかからないものほど有利ということです。	7
	3		7
	3	ソフトウェアの場合は、まず、インストールにかかる手間が大きな問題になります。	7
	3	それは大した問題ではないだろう、と思う人は、コンピュータのダウンロードフォルダの中を見てください。	7
	3	.tarファイルや.zipファイルが大量に置かれているのではありませんか?。	7
	3	しかし、そのうち、解凍したのは何パーセントくらいでしょうか。	7
	3	要するに、実際にインストールしたものはどのくらいあるか、ということです。	7
	3	インストールしたのはせいぜい1/3くらいで、あとはハードディスクのこやしになっているという人が多いのではないでしょうか。	7
	3		7
	3	手間がかからないというだけでは十分ではありません。	7
	3	どれほどインストールが簡単でも、自分にとって不要なものをコンピュータに置きたいと思う人はいないでしょう。	7
	3	関連ファイルが果たしてどこに置かれるのか、それがインストール前にわかるということは重要です。	7
	3	自分のコンピュータの中が他人に荒らされるのは誰にとっても不愉快なものです。	7
	3	ソフトウェアをインストールした際に、勝手にあちこちに関連ファイルを置かれるのを嫌がる人は多いでしょう。	7
	3	ソフトウェアがやっぱり気に入らないので削除したいと思っても、ファイルがあちこちに整理されずに置かれていれば手間がかかってしまいます。	7
	3	ファイルがどこに置かれるかが事前にわからないようなら、インストールをやめてしまう人も多いはずです。	7
	3	よほどメリットが大きくなければ、マシンの状態を今のまま維持したいと思うのが人間の普通の感情だからです。	7
	3		7
	3	GUIベースのソフトウェアをインストールした場合、期待するのは、操作か簡単であることです。	7
	3	ごく簡単な操作だけをして、すぐにその結果が得られるというのか何よりありがたいのです。	7
	3	その点から言えば、ウィザードが動いたりするソフトウェアはあまり嬉しくないということになります。	7
	3	ウィザードは裏で何をやっているかかわかりにくいからです。	7
	3	ファイルの読み込みや書き出しくらいの操作はするでしょうか、プロジェクトの作成 ディレクトリのインポートなどはできればしたくない、という人か多いでしょう。	7
	3	またEメールアドレスを通知するよう求められたりすれば、嫌がる人はさらに増えるはずです。	7
	3	もしそういう操作が必要ならば、すべてチュートリアルに明記しておくべきでしょう。	7
	3		7
	3	ライブラリをインストールした場合には、サイトにクイックスタートガイドの類がないかを探す人が多いでしょう。	7
	3	そこに、5行くらいのごく簡単なプログラム例が載っていて、実行結果も明記されていれば重宝がられるはずです。	7
	3	巨大なXMLファイルやテンプレートが用意されていて、空白部分をたくさん埋めなくてはならないというのは嫌がられるでしょう。	7
	3	それはスクリプト1つですべて済むというのが喜ばれます。	7
	3	重要なのは、同じようなフレームワークが2つあり、両者がライバル関係にある場合、その両方をダウンロードする人が多いということです。	7
	3	比べて使ってみてどちらが良かったか、という噂はきっとすぐに広まるでしょう。	7
	3		7
	3	ソフトウェアにはチュートリアルをつけることは多いと思いますが、その内容がわかりやすいかも大事な要素です。	7
	3	何を言っているかまったくわからないようだと意味がありません。	7
	3		7
	3	チュートリアルに、まさに自分の抱える問題の解決法が書かれていれば、ユーザは非常に喜びます。	7
	3	そういうチュートリアルなら読む気になりますし、読むのが楽しいでしょう。	7
	3	私も紅茶を飲みながら(英国人なのでやはり紅茶です)じっくり読むと思います。	7
	3	チュートリアルのプログラム例などを参考に使い方を理解し、その結果見事問題が解決できれば、私なら開発元に感謝のメールを送るかもしれません。	7
	3	また、クラッシュしたときにはバグレポートを送り、将来の改良のための提案もするかもしれません。	7
	3	「これ使ってみたけど、良かったよ」と友人にも推薦するでしょう。	7
	3	ライバルの製品の方がひょっとしたらいいのかもしれませんが、問題さえ解決できれば、そんなことはどうでもいいのです。	7
	3	重要なのは、ユーザが製品を使い始める段階でつまずかないよう、十分に配慮がなされているかどうかなのです。	7
	3		7
	3	インストールしたソフトウェアが十分に役立ってくれれば、私なら、最初に疑っていたことなど、きれいに忘れてしまうことでしょう。	7
	3		7
	3		7
	3	プロセス間通信とアプリケーションの応答時間の関係	5
	3	Randy Stafford	6
	3	応答時間は、ソフトウェアの使いやすさを大きく左右します。	7
	3	何か操作をして、その応答を長く待たされることほどストレスのたまることはないからです。	7
	3	特にその性質上、使用中に何度も「入力と応答」を繰り返すソフトウェアの場合は応答時間が重要になります。	7
	3	応答時間が長ければ、ソフトウェアのせいで自分の時間を無駄にされ、生産性も下がったとユーザは思うでしょう。	7
	3	しかし、なぜ応答時間が長くなるのか、その原因は十分には理解されていません。	7
	3	最近はその傾向か顕著なようです。	7
	3	ソフトウェアのパフォーマンスについて触れた文献は多くありますか、その多くがいまだにデータ構造とアルゴリズムに注目しています。	7
	3	もちろんその2つが大きく影響することもありますが、最近増えてきたマルチティアのエンタープライズアプリケーションの場合、そういうことは少ないのです。	7
	3		7
	3	私の経験から、この種のアプリケーションでパフォーマンスが問題になった時、データ構造やアルゴリズムを調べて改善を図るのは得策ではないと言えます。	7
	3	この種のアプリケーションの場合、応答時間を大きく左右するのは、リモートプロセス間通信(IPC：Inter-process Communication)の数です。	7
	3	入力への応答にIPCがいくつ必要になるかで、パフォーマンスが大きく変わるのです。	7
	3	他にも個々のソフトウェアに特有のボトルネックはあるでしょうが、通常はリモートIPCの影響が最も大きくなります。	7
	3	リモートIPCか行われると、たとえそれが1度だけでも、ソフトウェア全体の応答時間を無視できないほど遅延させます。	7
	3	リモートIPCがいくつも続けて発生すれば、それが積み重なって遅延が極端に大きくなってしまうのです。	7
	3		7
	3	その代表例が、オブジェクトリレーショナルマッピングを利用したアプリケーションで行われる「リップルローディング」です。	7
	3	リップルローディングとは、オブジェクトグラフを作成する際に、グラフ作成に必要なデータを取得するために何度もデータベース呼び出しを繰り返すことです(Martin Fowler 著「エンタープライズアプリケーションアーキテクチャパターン」の「遅延ロードjの頁を参照)。	7
	3	データベースのクライアントがWebページをレンダリングするミドルティアのアプリケーションサーバである場合、通常、データベース呼び出しはシングルスレッドでシーケンシャルに実行されます。	7
	3	その一つ一つで発生した遅延が積み重なり、全体の応答時間に大きな影響を与えるのです。	7
	3	個々のデータペース呼び出しの所要時間が10ミリ秒だとしても、1,000回の呼び出しが必要になれば(そのくらいは珍しくありません)、全体の応答時間は10秒を超えてしまう計算になります。	7
	3	他に同様の遅延が起きる処理の例としては、Webサービスの呼び出し、WebブラウザからのHTTPリクエスト、分散オブジェクトの呼び出し、要求一応答メッセージング、カスタムネットワークプロトコルを通じたデータグリッドとのやりとりなどがあげられます。	7
	3	入力への応答に必要になるリモートIPCが多ければ多いほど、応答時間も長くなります。	7
	3		7
	3	リモートIPCの数はどうすれば減らせるでしょうか。	7
	3	そのための方法は様々ですが、比較的簡単でよく知られている方法もいくつかあります。	7
	3	その1つは、「思考節約の法則(Principle of Parsimony)」を応用する方法です。	7
	3	これは、具体的には、プロセス間のインタフェースを最適化し、本当にいま必要なデータだけを必要最小限のインタラクションで取得するという方法です。	7
	3	他には、IPCをできるだけ並列化するという方法もあります。	7
	3	そうすれば、全体の応答時間は、主に最も遅延の大きいIPCによって決まることになります。	7
	3	また、以前のIPCの結果をキャッシュするという方法もあります。	7
	3	キャッシュを利用することで、その後に必要になるIPCの数を減らそうというわけです。	7
	3		7
	3	アプリケーションの設計にあたっては、入力への応答に必要なIPCの数が多くならないよう配慮すべきでしょう。	7
	3	パフォーマンスの悪いアプリケーションをよく調べてみると、1つの入力への応答に、IPCが数千も必要になっているということがよくあるのです。	7
	3	データ構造やソートアルゴリズムを工夫するよりも、キャッシュや並列化などのテクニックによって、入力に対するIPCの数を減らす方がはるかに効果的でしょう。	7
	3		7
	3		7
	3	無駄な警告を排除する	5
	3	Johannes Brodwall	6
	3	コードに問題があるときにコンパイラは警告を出しますが、その警告が1本のエッセイぐらいの長さになってしまうことがあります。	7
	3	それを見て密かに「問題があるのはわかったけど、こんなにたくさん警告を出されても、とても対処してる時間がないよ」と思ったことはないでしょうか?対照的に、コンパイル時に出た警告が1つだけのときは、きっと即座に対応ができるでしょう。	7
	3		7
	3	新しいプロジェクトをゼロから始めたばかりの時には、まだ問題は多くありません。	7
	3	余分なコードや作りの悪いコードもほとんどなく、警告も出ないでしょう。	7
	3	しかしコードベースが大きくなるにつれて、よくよく注意していないと、問題が増えていくのです。	7
	3	不要なコードや出来の良くないコードが増え、警告もたくさん出るようになってきます。	7
	3	そうした警告の中には、即座に対応を要するわけではない、いわば「ノイズ」のようなものも多いのです。	7
	3	ノイズが数百にも及ぶようになると、その中から本当にすぐ対応しなくてはならないものを見つけるのは困難ですつまり、警告が本来の役割を果たさなくなってしまうのです。	7
	3		7
	3	そういう事態を防ぐため、私はビルド時に警告が1つでも出たら、必ずその場でつぶすことにしています。	7
	3	たとえさほど重要でない警告であっても、見過ごすことなく、すぐにつぶすのです。	7
	3	たとえば「ヌルポインタ例外が起きる可能性がある」という警告は、もしかすると重大な警告ではないかもしれません。	7
	3	製品になった時に問題につながるわけではない、たとえ自分ではそれがわかっていても、警告はすぐにつぶすのです。	7
	3	埋め込みドキュメント(Javadocなど)の中に、削除されたパラメータや、名前が変更されたパラメータを参照している箇所があって、そのせいで、警告が出ているというような場合も、ドキュメントを即座に修正します。	7
	3		7
	3	出される警告が、どう考えても大した問題にはつながらないものばかりであると判断した場合には、警告ポリシーの変更を検討することもあります。	7
	3	警告ポリシーを変更しでもよいか皆に尋ねるのです。	7
	3	たとえば、メソッドのパラメータや戻り値のドキュメント化ができていない、という警告が出る場合、ドキュメント化にさほどの価値がないと思えば、その警告をやめてもいいでしょう。	7
	3	あるいは、プログラミング言語をアップグレードしたアップグレードした時、Java 5では「ジェネリック型」という概念が導入されましたが、それにより、ジェネリック型パラメータの指定がない古いコードのすべてで警告が出るようになりました。	7
	3	これは(少なくとも、今のところは)あまり意味のない警告でしょう。	7
	3	意味のない警告が出ても、ただ邪魔になるばかりで誰も喜びません。	7
	3		7
	3	ビルドで余計な警告が出る度、それを即座につぶすということを続けていれば、「これは意味のある警告か否か」ということを逐一判断する必要がなくなります。	7
	3	不要なものを無視するのも、やはり頭脳労働です。	7
	3	そんな無意味な頭脳労働は、せずに済むようにするのが賢明でしょう。	7
	3	加えて、余計な警告が出ないよう、常にコードを「クリーン」に保っておけば、他の人に仕事を引き継ぐのも簡単です。	7
	3	コードがクリーンになっていなければ、どの警告が重要でどの警告が重要でないかの判断を、引き継いだ人は改めて行わなくてはなりません。	7
	3	あまりに余分な警告が多く出るようだと、意味のある警告も含めてすべて無視する、という行動に出る人もいるでしょう。	7
	3		7
	3	本来ビルド中に出る警告は有用なものです。	7
	3	その有用性を実感できるようにするには、ノイズを排除する必要があります。	7
	3	「無用な警告が増えすぎたらその時に対処すればいい」という考え方ではうまくいきません。	7
	3	1つでも無意味な警告が出たら、すぐに対処しましょう。	7
	3	対処には、原因となっているコードを修正する、その警告が目に触れないようにする、警告ポリシーを変更するなどの方法が考えられます。	7
	3	適切に対処しておけば、余分な警告を見ずに済むだけでなく、真に意味のある警告が出た時、それを見逃さずに済みます。	7
	3	ノイズを排除する目的はそこにこそあるのです。	7
	3		7
	3		7
	3	コマンドラインツールを使う	5
	3	Carroll Robinson	6
	3	現在ソフトウェア開発ツールは、IDE(Integrated Development Environment :統合開 発環境)という形でパッケージングされて提供されることが多くなっています。	7
	3	MicrosoftのVisual StudioやオープンソースのEclipseがその代表例ですが、その他にも様々なIDEがあります。	7
	3	IDEはすで、に多数の人の支持を得ています。	7
	3	使いやすいだけでなく、ビルドプロセスに関わる細々した作業から解放されるからです。	7
	3		7
	3	使いやすい反面、IDEにはデメリットもあります。	7
	3	IDEが使いやすいのは、元々人間がしていた判断、作業の多くを裏で自動的にやってくれているからです。	7
	3	つまり、IDE以外のプログラミング環境を使ったことがないプログラマは、ツールが裏で何をしているのかをずっと知らないまま、という可能性もあります。	7
	3	ボタンをクリックしてから、実行ファイルがプロジェクトフォルダに現れるまでの間に行われることは、彼らにとっては一種の「魔法」かもしれません。	7
	3		7
	3	一方、コマンドラインのビルドツールで仕事をすれば、ビルド時に具体的にどういうことが行われるのかを詳しく知ることができます。	7
	3	makeファイルを自分で書こうとすれば、実行ファイルができあがるまでの間にどのようなステップ(コンパイル、アセンプル、リンクなど)を踏むのかを嫌でも知る必要があります。	7
	3	ツールのオプションを一つ一つ使って機能を確かめることも、知識を深めるのに大いに役立つはずです。	7
	3	コマンドラインのビルドツールをはじめて使う人は、GCCなどのオープンソースのツールを使うとよいでしょう。	7
	3	または、プロプライエタリなIDEとともに提供されているコマンドラインツールを使うという方法もあります。	7
	3	どれほど巧みに設計されたIDEであっても、結局は、コマンドラインツールにグラフイカルなフロントエンドをかぶせたものですわ実際にコマンドラインツールを使えばそのことがよく理解できるでしょう。	7
	3		7
	3	コマンドラインツールを使う利点は、ビルドプロセスについての理解が深まるということだけではありません作業によっては、コマンドラインツールの方がIDEより簡単に効率よくできるものもあるのですたとえば、検索や置換などの作業には、IDEに用意されているユーテイリテイよりも、grepやsedなどの方がはるかに便利です。	7
	3	スクリプトを書けるのもコマンドラインツールの強みですスクリプト化することでツールによる作業を簡単に自動化できます。	7
	3	たとえば、1日1回決まった時間にビルドを実行する、1つのプロジェクトのバージョンを複数作る、テストスイートを実行する、といった作業を簡単に自動化できるのですIDEで同じことが絶対にできないわけではないでしょうが、コマンドラインツールほど容易ではないのは確かですIDEの場合は、ビルドオプションの指定にGUIのダイアログボックスが必要になり、ビルドプロセスの開始にもマウスのクリックが必要になるということが多いためです。	7
	3	開発作業にIDEしか使ったことのない人は、こういう自動化が可能であることすら知らないかもしれません。	7
	3		7
	3	ただここで忘れてほしくないのは、IDEは開発作業を簡単にし、プログラマの生産性を向上させるために存在するということです。	7
	3	私は何も「IDE を使うな」、と言っているわけではありません。	7
	3	私が言いたいのは、「IDEが裏でしていることをよく見て理解しよう」ということです。	7
	3	そのためには、コマンドラインツールを使ってみるのが最普の方法であるというわけです。	7
	3	コマンドラインツールを使うことで、IDEが裏で何をしているかを知り、ビルドプロセスを円滑に進めるのにどのような作業が必要かを知れば、IDEをより有効に使えるようになるでしょう。	7
	3	もちろん、コマンドラインツールの使い方を習得し、その素晴らしい能力と柔軟性を知ったために、その後はIDEを使わなくなることもあるかもしれませんね。	7
	3		7
	3		7
	3	プログラミング言語は複数習得すべき	5
	3	Russel Winder	6
	3	プログラミング技術の習熟度は、どれだけ多くのプログラミングパラダイムに親しんでいるかによって大きく変わることが知られています。	7
	3	「親しんでいる」とは、名前について知っている、ちょっとかじったことがある、というような程度では駄目で、その言語を使って正しくプログラムを書けるということです。	7
	3		7
	3	はじめから複数の言語を知っているプログラマはいません。	7
	3	だれもが言語を一つずつ習得していくのですが、プログラマのソフトウェアに対する考え方は、どの言語を使用しているかによって大きく左右されます。	7
	3	特に最初に覚えた言語の影響は大きくなります。	7
	3	何年プログラミングを経験しようとも、ずっと同じ言語だけを使い、1つの言語しか知らないプログラマは、その言語の枠の中でしかものを考えられなくなってしまいます。	7
	3		7
	3	プログラマにとって、新たな言語を学ぶのは、かなり大変なことです。	7
	3	特に、最初に覚えた言語とはパラダイムの異なる言語を第二の言語として習得しようとすれば、そこには困難が伴います。	7
	3	C、Pascal、Fortranなどは同じパラダイムなので、たとえば、Fortranを最初に学んだ人が新たにCを学ぶ場合、さほど苦労はしないでしょう。	7
	3	しかし、CやFortranを使っていた人がC++やAdaを学ぼうとすれば、おそらく苦労することになるはずです。	7
	3	プログラムの振る舞いに根本的な違いがあるからです。	7
	3	同様に、C++を使っていた人がHaskellを学ぶことや、Cを使っていた人がPrologを学ぶことも、言語の性質が大きく違っているために困難を伴うでしょう。	7
	3		7
	3	プログラミング言語のパラダイムは大きく、手続き型、オブジェクト指向型、関数型、論理型、データフロー型などに分類することができます。	7
	3	2番目に学ぶ言語のパラダイムが最初の言語と同じであれば習得は楽ですが、パラダイムが違っていると、習得は困難になります。	7
	3		7
	3	しかし第二の言語には、是非とも、最初の言語とはパラダイムの違う言語を選ぶべきです。	7
	3	それはなぜかというと、パラダイムの違う言語を学ぶと、アルゴリズム、イディオム、パターンの実装について嫌でも考えるようになるからです。	7
	3	同様のアルゴリズムを実装するにしても、色々なやりかたがあり得ることに気づきます。	7
	3	この体験が、プログラマの技術を大きく向上させます。	7
	3	ある問題を解決するのに、言語Aではこのイディオムを使用するが、言語Bで同じイディオムは使えないというような体験が重要なのです。	7
	3	イディオムを言語Bでも使えるものに移植しようとすれば、両方の言語について、解決する問題について、よく考え学ぶ必要が出てくるからです。	7
	3		7
	3	パラダイムの違う言語を学ぶ効用は他にもたくさんあります。	7
	3	最も顕著な効用は、1つのパラダイムしか知らなければ思いつかないような表現を使用することができるということです3たとえば、宣言型言語の経験を積んだユーザなら、Cのような命令型言語においてもそのパラダイムを使用することができるでしょう。	7
	3	宣言型パラダイムを取り入れることにより、より簡潔で理解しやすいプログラムを書くことが可能になりますっC++などの言語は、初めから様々なパラダイムの語法を使用できるような作りになっています。	7
	3	それらの言語では、様々なパラダイムに関する知識は、むしろ必須のものになっていると言えるでしょう。	7
	3		7
	3	プログラマは少なくとも2つのパラダイムの言語を使いこなせるようになるべきです。	7
	3	もちろん、先に触れた5つのパラダイムすべての言語を使いこなせるというのが理想です。	7
	3	プログラマは常に新しい言語、特に馴染みのないパラダイムの言語を学ぶ意欲を持つべきでしょう。	7
	3	たとえ日々の業務で使う言語が1つだけだったとしても、パラダイムの違う言語を学べば、普段使っている言語をよりうまく使いこなせるようになります。	7
	3	実際に試してみれば効果に驚くことになるはずです。	7
	3	企業もそれを考慮し、社員が新たな言語を学ぶことを奨励すべきでしょう。	7
	3	できれば、そのための予算も確保しておくことが望ましいと言えます。	7
	3		7
	3	ただし、1週間のトレーニングコースを受ける、という程度の学習では不十分です。	7
	3	良いきっかけにはなるでしょうが、それだけで新たな言語を学んだとは言えません。	7
	3	言語を使いこなせるレベルになるためには、何ヶ月かの問、毎日少しでもその言語に触れる必要があるでしょう。	7
	3	大事なのは、その言語の構文や計算モデルについて知るだけでなく、言語のイディオムを身につけることです。	7
	3		7
	3		7
	3	IDEを知る	5
	3	Heinz Kabutz	6
	3	1980年代に「プログラミング環境」と言えば、ほとんどのプログラマにとって、あの素晴らしき「テキストエディタ」だけでした。	7
	3	どれほど恵まれているプログラマでも同じ状況でした。	7
	3	最近では当たり前の機能のように思われているシンタックスハイライトですら贅沢で、誰もが使えるというわけではありませんでした。	7
	3	コードをきれいにフォーマットする機能は外部ツールになっていたので、プログラマが逐一実行する必要がありました。	7
	3	コードを1ステップずつ実行するデバッガもやはり外部ツールで、使う際には、暗号のようなコマンドをたくさん打ち込まねばならなかったのです。	7
	3		7
	3	1990年代になると、プログラミング用のツールを売れば大きな利益につながるということを企業が認識し始めました。	7
	3	それで生まれたのがいわゆるIDE (Integrated Development Environment :統合開発環境)です。	7
	3	これは簡単に言えば、従来から広く使われていたテキストエディタに、コンパイラ、デバッガ、コードフォーマツタなどのツールの機能を組み込んだようなものです。	7
	3	またIDEが生まれる頃には、マウスやメニューを使うGUIが一般化していたので、暗号のようなコマンドを覚える必要もなくなりました。	7
	3	マウスを使ってメニューを選べば操作できるようになったのです。	7
	3		7
	3	21世紀には、IDEは当たり前の存在になり、他の分野でのマーケットシェアを獲得するためにIDEを無料配布する企業も増えました。	7
	3	最新のIDEは、驚くほど機能が豊富です。	7
	3	私が気に入っているのは、自動リファクタリング機能、中でも「メソッドの抽出」という機能です。	7
	3	これはメソッド中の一部のコードを選ぶと、その部分を新たなメソッドとして切り出してくれる機能です。	7
	3	どういうパラメータを渡すべきかもすべてツールが自動的に判断してくれるので、非常に簡単にコード編集を行うことができます。	7
	3	私が使っているIDEには、新たに作ったメソッドで置換可能な箇所が既存コードの中にないか探す機能もあります。	7
	3	もし見つかれば、置換するか否かをこちらに尋ねてくれます。	7
	3		7
	3	幸か不幸か、今やIDEは使うのに訓練や学習をほとんど必要としないものになっています。	7
	3	私がはじめてUNIXマシンでCのプログラミングをした時は、viエディタを使う必要があり、その使い方を習得するのにかなりの時間を要しました。	7
	3	viエディタの学習曲線は、かなりの急勾配(きゅうこうばい)と言えるでしょう。	7
	3	いったんコツがわかると急激に理解が進むのですが、最初の段階では非常に苦労をするのです。	7
	3	しかし苦労して身につけた技術は、その後ずっと役立つてくれているので、苦労は十分報われたと言えます。	7
	3	実際この原稿を書くのにもviを使っています。	7
	3	反対にIDEの学習曲線は非常に緩やかです。	7
	3	苦労せずに使い始められるのですが、その後はなかなか上達しないことが多いのです。	7
	3	長い間、基本的な使い方しか知らないという状態が続いてしまいます。	7
	3		7
	3	最後に、私たちプログラマにはUNIXがあります。	7
	3	UNIXには、習得は容易ではないが、一度習得してしまえばコーディング作業の効率化に非常に役立つツールが多数あります。	7
	3	たとえば、コードレビューで「システム中に同じ名前のクラスが多数あるらしい」と気づいたとします。	7
	3	その場合、実際に同じ名前のクラスがどのくらいあるかは、次のようにfind 、sed、sort 、uniq 、grep といったツールを使えば簡単に確認できます。	7
	3		7
	3	家に修理に来る配管工はプロートーチ(簡易型溶接機)という専門の道具を当然使えるはずです。	7
	3	IDEは今やプログラマにとってのプロートーチかもしれません。	7
	3	今後は、IDEをどう使えば生産性を上げられるか、時間をかけて学んでいくべきでしょう。	7
	3		7
	3		7
	3	限界を知る	5
	3	Greg Colvin	6
	3		7
	3	すべきことは常に明確に	5
	3	Dan Bergh Johnsson	6
	3	たとえば、私が3人のプログラマの肩を叩いて、「今、どんな仕事をしているんですか」と尋ねたとしましょう。	7
	3	すると1人は、「ああ、今、このメソッドのリファクタリングをしているところですよ」と答えました。	7
	3	もう1人は「このWebアクションにパラメータをいくつか追加しているところです」と答えました。	7
	3	そしてもう1人は「このユーザストーリを扱っています」と答えました。	7
	3		7
	3	この場合、最初の2人は細部にばかりとらわれていて、3人目のプログラマだけが大局を見ている、自分の仕事の目的がよくわかっている、そういうふうにも見えます。	7
	3	しかし、3人に作業の具体的内容と所要時間を聞いてみると、様子がまったく違ってきたのです。	7
	3	最初の2人は、自分がいま取り組んで、いる作業の内容を完全に把握していました。	7
	3	作業ではどのファイルについて何をするのか、何時間で完了する予定なのか、それがすべて明確になっていました。	7
	3	ところが、3人目のプログラマはそうではありませんでした。	7
	3	細かいことを尋ねたら、「検討中」という答えが返ってきました。	7
	3	何日か模索してみないと細かいことはどうなるかわからないと言うのです。	7
	3	わかるのは、せいぜい「クラスをいくつか追加して、サービスに少し変更を加えることになるだろう」ということくらいでした。	7
	3		7
	3	最初の2人は、何も大局を見ていなかったわけではないのです。	7
	3	最終的な目標が何なのかはよくわかっていました。	7
	3	その目標に向かつて前進するために、今どんな作業をすべきかを明確に決めていただけです。	7
	3	すべきことをはっきりと定め、それを何時間で完了させるのかも定めていました。	7
	3	また、1つの作業が完了したら、すぐに次に何をすればいいかを決めます。	7
	3	次の作業は、新しい機能の追加かもしれないし、既存のコードのリファクタリングかもしれません。	7
	3	ただ、どの作業でも必ず目的を明確に定め、それを充分短い時間(たとえば2時間)で区切るというのは同じです。	7
	3		7
	3	それに対し、3人目のプログラマは、大目標を小目標に分解するということは一切していません。	7
	3	いきなり大目標に向かつて作業を始め、漠然と作業を進めていました。	7
	3	目標達成までに具体的にどういう作業が必要になるのか、それぞれにどのくらい時間がかかるのかはまったく見えておらず、次にどうすればいいかは手探りで何となく決めている、という状態です。	7
	3	そうしているうちに視界が開け、すべきことが明確になり始めるだろう、とは思っていますが、それがいつになるか確信はありません。	7
	3	おそらく最初の万に書いたコードは、長い時間が経って全体像が見えてくる頃には、まったく的外れなものだったことがわかるでしょう。	7
	3		7
	3	最初の2人のプログラマは、たとえば2時間で完了させる予定だった作業にそれ以上の時間がかかりそうだと途中でわかってしまったらどうするでしょうか。	7
	3	その場合、彼らはまず、その作業で書いたコード、加えた変更をすべて破棄するでしょう。	7
	3	そして目標をさらに細かく分割して、再び新たな小目標達成のための作業を開始するのです。	7
	3	時間どおり終わらない作業をそのまま続けても、それが妥当なものかどうかはわからないし、本当に有効かどうかわからないコードがレポジトリに入ってしまうのは良いことではありません。	7
	3	それよりは、いったん作業を白紙に戻した方がいいのです。	7
	3	コードは白紙に戻りますが、直前の作業から得た教訓、ひらめきは頭に残っているはずです。	7
	3		7
	3	3人目のプログラマは、「多分、これで妥当だろう」という推測だけでコードを少しずつ書いていきます。	7
	3	そうしたコードの断片をあとで無理につなぎ合わせようとします。	7
	3	つなぎ合わせれば、それが大目標に添ったものになるはず、と信じて。	7
	3	せっかく書いたコード、加えた変更を途中で破棄するなど、あり得ないことです。	7
	3	それまでにかけた時間や労力が無駄になってしまう、と思うからです。	7
	3	しかし、そういうやり方をしていると、有効かどうかわからない中途半端なコードがレポジトリに多く入り込むことになってしまいます。	7
	3		7
	3	最初の2人のプログラマも、場合によっては、一定の時間内に完了できる有効な作業がすぐに見つからないということがあり得ます。	7
	3	そんなときは、コードを見たり、書いたりしながら、次にすべき作業を「ああでもない、こうでもない」と模索するモードに入ります。	7
	3	そして最終的に次の作業の内容が固まったら、模索中に書いたコード、加えた変更はすべて破棄します。	7
	3	作業が無駄になってしまうように見えますが、そうではありません。	7
	3	明確な目的もわからないのに闇雲に先を急ぐよりも、少し遠回りのようでも、確実に有効とわかる作業を探した方が、結局は最終目標に向かつて着実に前に進むことになるからです。	7
	3		7
	3	大事なのは、常に自分が何をすべきかを明確にするということです。	7
	3	完了する期限も必ず決めます。	7
	3	もし、期限内に予定の作業が終わらないようであれば、その間に書いたコード、コードに加えた変更はすべて破棄します。	7
	3	再度、小目標を立て直して作業内容を検討し、はじめからやり直すのです。	7
	3	次に何をすればいいかがすぐにわからない時は、やはりあれこれと模索するのですが、大事なのは「いつの間にか手探り状態になっていた」ということを絶対に避けるということです。	7
	3	模索段階で、書いたコードを決してレポジトリに入れてはいけません。	7
	3		7
	3		7
	3	大量のデータはデータベースで	5
	3	Diomidis Spinellis	6
	3	アプリケーションで大量の永続データを扱う必要がある場合やデータが相互に関係し合う場合は、迷うことなくリレーショナルデータベース(RDBMS)にデータを保存すべきでしょう。	7
	3	RDBMSにはかつて、コストが高い、複雑で扱いづらい、気軽には導入できない、というイメージがありました。	7
	3	しかし、今は以前とはまったく事情が変わっています。	7
	3	RDBMS は今や身近な存在です。	7
	3	改めて導入を考えなくとも、システムに既に1つや2つはインストールされているという人も多いでしょう。	7
	3	MySQL、PostgreSQLなどは非常に高機能なRDBMS ですが、オープンソースソフトウェアなので、購入のコストはかかりません。	7
	3	他にも、ライブラリとしてアプリケーションに直接リンクされる「組み込みデータベース」というデータベースもあります。	7
	3	特によく知られているのは、いずれもオープンソースのSQLiteとHSQLDBです。	7
	3	この種のデータベースなら、セットアップや管理の手間も必要なく、非常に効率的に使えると言っていいでしょう。	7
	3		7
	3	アプリケーションで扱うデータの量がシステムのRAM容量を超えている場合、インデックス付きのRDBMSテーブルを使えば、ライブラリに用意されているマップなどのコレクション型(この種の型では仮想メモリページが多用される)を使うよりも、処理が桁違いに速くなりますデータベースで扱うべきデータの量は簡単に増えていくものです。	7
	3	組み込みデータベースの場合、扱い方が適切であれば、必要データ量の増加に応じてより本格的なRDBMSに切り替えてスケールアップすることが可能です。	7
	3	フリーのオープンソースのデータベースを使っていて、後から、より高機能でサポートも充実した商用データベースに転換するということもできます。	7
	3		7
	3	SQLの使い方を覚えれば、データベースが中心となるアプリケーションを簡単に書けます。	7
	3	データベースに保存するデータを適切に正規化しておけば、SQLクエリを使って効率的に抽出ができます。	7
	3	SQLのコードは書くのも簡単で読んで理解するのも簡単です。	7
	3	SQLが使えれば、データを扱うのに複雑なコードを書く必要はなくなるのです。	7
	3	SQLクエリなら、データに1度に複雑な変更を加えるということも簡単にできます。	7
	3	また、永続データの編成の仕方を少し変えるというくらいの小幅の変更で、あれば、SQL対話環境を使うだけで済んでしまい、コードを一切書かなくていいという場合もあります。	7
	3	対話環境を使うと、書いたクエリを試しに実行してみるということもできます。	7
	3	対話環境無しでは「編集・コンパイル・実行」という手順を経ることになるわけですが、その手順を飛ばして、動きを確かめることができるのです。	7
	3		7
	3	他にRDBMSを利用するメリットとして大きいのは、データエレメント同士を関連付けることができることです。	7
	3	「このデータとこのデータは常に一致していなければならない」というような制約条件を明確に宣言できるのです。	7
	3	そうすることで、一方のデータだけを更新して、もう一方のデータを更新し忘れる「ダングリングポインタ」という問題の発生を防止できるわけです。	7
	3	たとえば、「ユーザAのデータを削除したら、ユーザAの送ったメッセージのデータも必ず削除する」というような指定も制約条件を定義することで実現できます。	7
	3		7
	3	インデックスを作成するだけで、データベース中のエンティティ同士をいつでも、あとからでも効率良くリンクすることができます。	7
	3	手間をかけてクラスフィールドのリファクタリングをする必要などはないのです。	7
	3	データベースにデータを保存しておけば、複数のアプリケーションから同じデータにアクセスするということも問題なくできます。	7
	3	同じデータを利用する複数のアプリケーションを並行してアップグレードをするのも簡単です。	7
	3	さらに、アプリケーションの構成部分ごとに言語やプラットフォームを変えるということも簡単にできます。	7
	3	各部分に最も適した言語とプラットフォームが使えるわけです。	7
	3	たとえば、WebベースアプリケーションのXMLバックエンドをJavaで書き、監査スクリプトをRubyで、ビジュアライゼーションインタフェースをProcessingで書く、といったこともできます。	7
	3		7
	3	RDBMSにSQLコマンドの最適化機能があるというのも重要です。	7
	3	この機能があるおかげで、アルゴリズムのチューニングに労力をかけることなく、アプリケーションの機能の充実に集中できます。	7
	3	高度なデータベースシステムの中には、マルチコアプロセッサを活かす最適化を自動で行うものもあります。	7
	3	技術が進むほど、間違いなくアプリケーションのパフォーマンスは向上していくでしょう。	7
	3		7
	3		7
	3	いろいろな言葉を学ぶ	5
	3	Klaus Marquardt	6
	3	プログラマにとってコミュニケーションはとても重要なことです。	7
	3		7
	3	プログラマの仕事を始めたばかりの頃は、コミュニケーションと言えば、人間相手よりも、専らコンピュータ相手のコミュニケーションということになるでしょう。	7
	3	より正確に言えば、コンピュータ上で動作するプログラムとのコミュニケーションです。	7
	3	このコミュニケーションにおいては、概念をコンピュータに理解できるかたちで表現する、つまりプログラミングが必要です。	7
	3	プログラムを書くことで、頭の中にあった概念が現実化されるのです。	7
	3	現実化される際に、実体のある物質がほとんど関わらないというのがプログラムの面白いところです。	7
	3		7
	3	プログラマには、コンピュータに理解できる言語を上手く操る能力が必要です。	7
	3	その言語には、様々な種類があります。	7
	3	ハードウェアに直接に語りかけるような言語もあれば、仮想的なコンピュータと対話するものもあります。	7
	3	抽象度が言語によって、また開発ツールによって違うということです。	7
	3	プログラマにとって、抽象度の異なる複数の言語を学ぶことは重要です。	7
	3	1種類の言語だけでは、中には非常に表現することが困難な概念もあります。	7
	3	優秀なプログラマなら、日々の業務をこなす以外に、自分の時間を割いて別の言語を学ぶ努力をするでしょう。	7
	3	業務で使うものとは目的が異なり、違った概念の表現に適した言語を学ぶのです。	7
	3	この努力は、いつか必ず報われるはずです。	7
	3		7
	3	コンピュータとのコミュニケーション以上に、プロジェクトチームのメンバーとのコミュニケーションが大切です。	7
	3	特に大規模なプロジェクトになると、1人でこつこつプログラムを書く「職人仕事」の部分はとても小さいと言えます。	7
	3	他人と話し合いながら進めるチームワークの部分が大きいでしょう。	7
	3	自分の考えていること、やろうとしていることを、コンピュータにわからせるだけでは不十分なのです。	7
	3	他人の言うことをよく理解し、自分の言いたいことを他人にわかりやすく伝えることが必要です。	7
	3	私の知る限り、優秀なプログラマはプログラミング言語を巧みに操るだけでなく、自然言語も非常にうまく使うことができます。	7
	3	話す力が大事なのは、他人とのコミュニケーションが円滑にできるからだけではありません。	7
	3	自分の思考を明確にするためにも、話す能力は重要なのです。	7
	3	この能力は問題を抽象化する際には欠かせません。	7
	3	そして抽象化こそ、プログラミングの核心です。	7
	3		7
	3	ソフトウェア開発に関わるのは、コンピュータとプロジェクトチームのメンバーだけではありません。	7
	3	他にも多くの人が関わります。	7
	3	その中には、同じ社内にいてもプログラムのコードは書かないという人もいれば、社外の人もいます。	7
	3	自分の仕事については知っていても、コンピュータについては知識がない人も大勢いるでしょう。	7
	3	そういう人たちとのコミュニケーションもやはり重要です。	7
	3	テストや品質管理、デプロイ、マーケティング、販売などに携わる人たち、そしてエンドユーザ(製品を企業内で使うユーザもいれば家庭で使うユーザもいます)とのコミュニケーションは欠かせません。	7
	3	コミュニケーションのためには、相手がどういう人たちで、どういうことに関心を持ち、どんな問題を抱えているかを知る必要があるでしょう。	7
	3	そのためには、相手と同じ言葉を話す必要があります。	7
	3	相手の住む世界の言葉、それぞれの専門分野の言葉を話さなくてはならないのです。	7
	3	もしそれができなければ、仮に会話がうまく成り立っているように思えても、実際には成り立っていないということになります。	7
	3		7
	3	たとえば、話す相手が会計士ならば、原価センタ会計、投資資本、使用資本、といった概念についての基本的な知識が必要です。	7
	3	マーケティング担当者にも、弁護士にも、やはりそれぞれに特有の言葉や概念があるので、それを多少は知っておかなければうまく話ができません。	7
	3	対応すべき分野はプロジェクトごとに違うでしょうが、その分野に固有の言語を話せる人は、プロジェクトに必ず何人かは必要です。	7
	3	その人自身がプログラマであることが理想的です。	7
	3	コンピュータを使って概念を現実化するのは最終的にはプログラマの仕事だからです。	7
	3		7
	3	プログラマはただコードを書くだけの存在ではないのです。	7
	3	カール大帝の言葉にもあるとおり「他者の言葉を知ることは、新たな魂を持つこと」です。	7
	3	ソフトウェア業界の外にいる人とコミュニケーションをしてみれば、他の世界の言葉を知ることの大切さがよくわかるでしょう。	7
	3	大事なのは自分が話すこと以上に、相手の話に耳を傾けることです。	7
	3	言葉にならない言葉の存在を知ることが大事なのです。	7
	3		7
	3		7
	3	見積りとは何か	5
	3	Giovanni Asproni	6
	3	自分の担当業務に関して見積りを行い、見積り結果をマネージャや同僚、ユーザなどに伝えるのはプログラマの義務です。	7
	3	彼らはその見積り結果を踏まえ、目標達成のために時間やお金、機器等のリソースがどのくらい必要かを判断します。	7
	3	見積りが正確でなければ正しい判断はできません。	7
	3		7
	3	正しい見積りをするためには、当然のことながら、そのための方法を学ぶ必要があります。	7
	3	しかし、それよりも先にまず知らなくてはならないのは「見積りとは何か」そして「見積り結果はどう利用すべきか」というごく基本的なことです。	7
	3	実に不思議なのですが、プログラマやマネージャの中に、この2つを正しく理解している人はさほど多くないのです。	7
	3		7
	3	それは、たとえばプロジェクトマネージャ(PM)とプログラマの間で、次のような会話が交わされることが決して珍しくないということからもわかります。	7
	3		7
	3	PM「機能xyzの件だけど、開発期間はどのくらいだと見積もってる?」 プログラマ「1ヶ月ですね。	7
	3	」 PM「長すぎる。	7
	3	1週間で何とかならないか。	7
	3	」 プログラマ「どんなにがんばっても3週間は必要ですよ。	7
	3	」 PM「2週間、それ以上は無理だな。	7
	3	」 プログラマ「わかりました。	7
	3	それで手を打ちましょう!」。	7
	3	プログラマは、はじめは自分の見積もった数字を言っていたのに、結局はPMの求める数字を受け入れてしまっています。	7
	3	しかも、かたちの上では、PMがプログラマに譲歩したことになっているため、プログラマはこの数字に責任を負わなくてはなりません。	7
	3	上の会話がおかしなものだと気付けるのは、見積もり、ターゲット、コミットメントという言葉の正しい意味を知っている人だけでしょう。	7
	3	3つの言葉は次のように定義出来ます。	7
	3		7
	3	見積り: 「見積り」とは、何かの価値、数字、量、程度などについて概算、あるいはおおまかな判断をすることを指します。	7
	3	見積りのためには「事実の裏づけに基づく測量」が必要です。	7
	3	具体的には、信頼のおける数値データや、過去の経験などに基づく予測のことです。	7
	3	裏づけを基に得られた判断からは、希望や願望が排除されなければなりません。	7
	3	また、見積りは、あくまで概算、おおまかな判断なので、ある程度以上の正確さは期待できません。	7
	3	たとえば「機能Aの開発に要する時間は234.14日」というような見積りはあり得ないのです。	7
	3		7
	3	ターゲット: 「ターゲット」とは、実現したいビジネス上の目標を明文化したものです。	7
	3	たとえば「システムAは、同時に400人のユーザが利用できなければならない」というのはターゲットと言えます。	7
	3		7
	3	コミットメント: 「コミットメント」とは、「約束」と言い換えてもいいでしょう。	7
	3	「ある機能を、ある期日までに(あるいは、あるイベントまでに)、一定以上の品質で提供する」と約束することです。	7
	3	たとえば「製品の次のリリースまでに、検索機能を利用可能にする」というのはコミットメントでしょう。	7
	3		7
	3	見積り、ターゲット、コミットメントは元来、互いにまったく無関係なものです。	7
	3	しかし、ターゲットとコミットメントは、見積りを基にしたものであるべきでしょう。	7
	3	Steve McConnellは「ソフトウェア見積りの主目的は、プロジェクトの結果を予言することではない。	7
	3	見積りを行うのは、プロジェクトのターゲットがコントロールによって達成可能な程度に現実的なものかどうかを判断するためである。	7
	3	」と言っています。	7
	3	ターゲット、コミットメントを現実的なものにすることが、見積りの目的とも言えます。	7
	3	そして正しい見積りが土台にあれば、適切な管理、プランニングができます。	7
	3		7
	3	先の会話の場合、PMは、実はプログラマに見積りを求めているのではなく、コミットメントの設定を求めているのです。	7
	3	しかも、そのコミットメントの基になるターゲットはPMの頭の中だけにあり、はっきりと言葉にはされていません。	7
	3	見積りに基づかないターゲットを達成することは非常に難しいでしょう。	7
	3	見積りを求められた時には必ず、相手が「見積り」「ターゲット」「コミットメント」という言葉の意味を正しく認識しているかを確認すべきです。	7
	3	そうすればプロジェクトが成功する確率も上がるはずです。	7
	3	プロジェクトに関わる人たちが「見積り」という言葉の意味を正しく認識しない限り、どれだけ素晴らしい見積りをしても無意味でしょう。	7
	3		7
	3		7
	3	Hello, Worldから始めよう	5
	3	Thomas Guest	6
	3	Paul Lee(通称Hoppy)は、私の同僚の中でも、プログラミングのことに関しては最高のエキスパートで、皆の尊敬を集めています。	7
	3	先日も少し困ったことがあったので、Hoppy のデスクまで、言って「ちょっとコードを見てもらえないだろうか」と頼みました。	7
	3		7
	3	「いいよ」Hoppyはそう答えました。	7
	3	「じゃあ、椅子を出してそこに座って」そう言われて私は、彼の後ろに築き上げられたコーラの空き缶のピラミッドを壊さないよう、慎重に椅子を引っ張り出しました。	7
	3		7
	3	「どのコード?」。	7
	3	私は、問題になっている関数の名前と、その関数のコードが収められているファイルの名前を告げました。	7
	3		7
	3	「じゃあ、その関数を見てみようよ」Hoppyはそう言って、置いてあったK&Rをどけると、キーボードを私の前に移動させました。	7
	3		7
	3	「IDEはどこ?」Hoppyは、IDEを使っておらず、エディタで作業しているようでしたが、そのエディタは私に使えるものではありませんでした。	7
	3	Hoppyはキーボードを私からひったくると、何やら打ち込み始めました。	7
	3	すると、私の言ったファイルが開き、内容が画面に表示されました。	7
	3	大きなファイルです。	7
	3	表示されていたのは、私が言った関数のコードでした関数も大規模なものです。	7
	3	彼はページを送ると、ある条件ブロックの部分を表示させました。	7
	3	私が彼に尋ねたかったのは、その条件ブロックについてです。	7
	3		7
	3	「xが負の値になった時、この部分のコードはどう動くのかな」私はそう尋ねました。	7
	3	「負 の数になると絶対にまずいってことだけはわかるんだけど」。	7
	3	私はその日、午前中いっぱいを使い、xの値を強制的に負の数にする方法を探して、あれこれ試したのです。	7
	3	しかし、何しろ大規模なプロジェクトで、ファイルも関数も大規模です。	7
	3	コードに変更を加えてコンパイルして実行、という作業を繰り返していたら、疲れ切ってしまいました。	7
	3	それで、Hoppyのようなエキスパートならすぐに答えがわかるのでは、と思って助けを求めたわけです。	7
	3		7
	3	これだけで、彼がほんの何分か前に作ったプログラムは動き出しました。	7
	3	私たちは、プログラムの求めに応じていくつかの値を入力し、私の懸念が正しかったことを確かめました(私も、この点だけは間違っていなかったわけです) 。	7
	3	さらにHoppyは念のため、K&Rの該当ページを開いて再確認もしてくれたのです。	7
	3	私はHoppyに礼を言い、コーラの缶のピラミッドを壊さないよう注意しながら椅子をしまって、その場を後にしました。	7
	3		7
	3	私は自分のデスクに戻ると、IDEを閉じました。	7
	3	長いあいだ大きなプロジェクトチームの一員として、大規模な製品の開発ばかりしてきたので、いつの間にかそのやり方に慣れきってしまっている自分に気づいたからです。	7
	3	プログラミングが元来どういう作業だったのか、ということを忘れかけていました。	7
	3	IDEを使わなければ、コンピュータが自動でやってくれることなどほとんどなく、あとは自分の手でやるしかないのです。	7
	3	プログラミングとは元々そういうものだったはずです。	7
	3	私はテキストエディタを開き、こんなコードを書きました。	7
	3		7
	3		7
	3	プロジェクト自身にしゃべらせる	5
	3	Daniel Lindner	6
	3	現在のソフトウェア開発プロジェクトの多くには、バージョン管理システムが導入されています。	7
	3	そしてバージョン管理システムの多くは、自動テストでコードの妥当性を定期的に確認するCI(Continuous Integration :継続的結合)サーバに接続されています。	7
	3	素晴らしいことです。	7
	3		7
	3	CIサーバに静的コード解析のツールを組み込み、コードメトリクスを収集することもできます。	7
	3	コードメトリクスは、コードの特定の側面におけるフィードバックデータであり、時間の経過に伴うコードの変化を知る手がかりでもあります。	7
	3	メトリクスを収集する場合は、「これを上回っては(下回っては)ならない」という基準を通常設けることになります。	7
	3	たとえば、コードのテストカバレッジが最初の段階で20%だったとしましょう。	7
	3	仮に、テストカバレッジが今後も決して15%を下回ってはならない、という基準を設けたとします。	7
	3	データの収集はCIサーバに任せておけばずっと自動でやってくれますが、そのままでは、基準値を下回っているかどうかは人間が定期的に自分の目で確認する必要があります。	7
	3	下回った時は自動的に通知される、という仕組みはできないでしょうか。	7
	3		7
	3	まず通知の手段が問題です。	7
	3	手段としては、eメールやインスタントメッセージなどが使えるでしょう。	7
	3	たとえば、テストカバレッジが低下した時や改善した時に、それを即座にメールやメッセージで伝えるようにするのです。	7
	3	しかし、それよりもさらに効果的なのは、XFD(eXtreme Feedback Device)です。	7
	3		7
	3	XFDは、定期タスク等の結果に応じ、ランプや小型の噴水、オモチャのロボット、USBロケットランチャーなどを動かす仕組みです。	7
	3	メトリクスがあらかじめ設定した基準値を上回った(下回った)時に機器を動かし、わかりやすく通知するのです。	7
	3	ランプならば、基準値を上回るか下回るかした場合に、一目でわかるように明るく光るわけです。	7
	3	これならば、帰宅しようと急いでいる時でも、見過ごすことはないでしょう。	7
	3		7
	3	使用する機器を工夫すれば、ビルドが失敗した時には何かが壊れる音が聞こえる、コードに注意すべき問題が発見された時には信号が赤に変わる、異臭が漂う、そんな仕組みにすることもできます。	7
	3	プロジェクトチームのメンバーが複数箇所に点在している時は、同様の仕組みを各所に作ってもいいでしょう。	7
	3	信号機をプロジェクトマネージャのオフィスに設置し、それでプロジェクト全体の状況を伝えれば、喜ばれるかもしれません。	7
	3		7
	3	どのような機器をどう使うかは、利用する人の創造力次第です。	7
	3	いわゆる「ギーク」の多いチームなら、チームのマスコットをラジコンで動かす、というのも面白いでしょう。	7
	3	もう少しシックな方がいい、というのなら、デザイナーランプを使うのもいいと思います。	7
	3	インターネットで色々と検索してみれば、さらにインスピレーションが湧くはずです。	7
	3	とにかく電源プラグのある機器、遠隔制御の可能な機器ならば、XFDに使用できるのです。	7
	3		7
	3	XFDは、プロジェクトの「ご意見番」のような存在と言ってもいいでしょう。	7
	3	メンバーたちの仕事ぶりが定められたルールに照らして褒められるものか、あるいは非難されるべきものかを、XFDが音や光を使って直接教えてくれるわけです。	7
	3	音声合成ソフトウェアとスピーカーを使えば、ご意見番に本当に「しゃべらせる」こともできます。	7
	3	プロジェクト自身が本当に「しゃべりだす」ときが来るのです。	7
	3		7
	3		7
	3	「その場しのぎ」が長生きしてしまう	5
	3	Klaus Marquardt	6
	3	プロジェクトの中で「暫定ソリューション(その場しのぎ)」を作ったことがある人は多いのではないかと思います。	7
	3	なぜ暫定ソリユーションが必要になるのでしょうか?。	7
	3	おそらくその理由は「一刻も早く解決しなくてはならない問題があるから」でしょう。	7
	3	その問題は開発チーム内部に閉じたものということもあります。	7
	3	たとえばツール間の差異を埋めるために早急に何かツールが必要になったのかもしれません。	7
	3	あるいは問題は外部、つまりエンドユーザから見える問題かもしれません。	7
	3	ユーザの求める機能が不足しているので、取り急ぎ何らかのかたちでその機能を提供する必要があったのかもしれません。	7
	3	時間が無いときに、その場しのぎに作られる。	7
	3	それが「暫定ソリューション」です。	7
	3		7
	3	どの開発チームでも、暫定ソリューションは、開発中のシステムに属きないものとして作られることが多いはずです。	7
	3	作った当初はあくまで「ドラフト」と考えられており、時間がなくて本来守るべき規約やガイドラインに従うことができないため、あとで修正することが前提です。	7
	3	必然的に、チームの内部からは「そういうものを作るべきではないのでは?」という異論が出ることになります。	7
	3	暫定ソリューションを作る理由は色々とあるでしょうが、いずれにしろ、その成否を分ける条件は単純です。	7
	3	有用であれば使い続けられ、そうではなければすぐに使われなくなります。	7
	3		7
	3	暫定ソリューションで問題なのは「慣性の法則がはたらく」ことです。	7
	3	いったん暫定ソリューションができてしまうと、既成事実化するのです。	7
	3	すでに存在していて、一応役に立っていて、皆に一応受け入れられている。	7
	3	もしそうだとすれば、その状況を今すぐ変える必要性を誰もあまり感じません。	7
	3	本当は暫定ソリューションも早くシステムに統合すべきなのですが、重要な仕事は他にもたくさんあるので、どうしても後回しになります。	7
	3	動いていて、皆に受け入れられているのだから、とりあえずはそのままで良いじゃないか、といろことになりやすいのです。	7
	3	規約やガイドラインに従っていないということは良くないと皆思っているのですが、よほど特殊なシステムでない限り、それを即どうにかしなくてはと考える人は多くありません。	7
	3		7
	3	そういう理由から、暫定ソリユーションは「暫定」と言いながら、いつまでも修正されずに残ることになります。	7
	3		7
	3	また仮に、暫定ソリユーションに何か放置できない問題が起きたとしましょう。	7
	3	修正の際に、システム本体のコードと同等の品質にまで高めることは難しいでしょう。	7
	3	結局は暫定の対策でその場を切り抜けることになります。	7
	3	少し新しくなったというだけで、本質は何も変わらないのですが、目的は果たしているのでそれでよしとされてしまいます暫定ソリユーションの最大の問題は何でしょうか。	7
	3		7
	3	その答えは、プロジェクトごとに違うでしょう。	7
	3	また、この質問を投げかけられた人が、規約やガイドラインを個人的にどの程度重視しているかによっても答えは違ってきます。	7
	3	暫定ソリューションの数があまりに増えれば、システムのエントロピーは増大し、複雑になってしまい、保守が厳しくなります。	7
	3	しかし、本当の問題は暫定ソリューションの存在や多寡ではないのではないでしょうか。	7
	3	ソリューションというのは、存在するからには必要なもののはずです。	7
	3	利用する人たちがそれを気に入っていようがいまいが、存在するからには必要なのです。	7
	3	ただ困るのは、ソリューションをいったん暫定ソリューションにしてしまうと、後で修正するのは難しくなるということです。	7
	3		7
	3	では、一体どうすればいいのでしょうか。	7
	3	対応は大きく次の3つに分かれると思います。	7
	3		7
	3	では、1 、2、3 について個々にどういうことが言えるか検討してみましょう。	7
	3		7
	3	プロジェクトを進めていく間には、ソリューションを多数作ることになります3おそらく、そのうちの少なくとも一部は暫定ソリューションになるでしょう。	7
	3	暫定であっても有用なソリューションならそのまま残ってしまいます。	7
	3	その状況を変える最善の方法は、暫定ソリューションに修正を加えるのではなく、不要にしてしまうことです。	7
	3	後から改めて、より優れたソリユーション、より有用性の高いソリューションを作るのです。	7
	3	大事なのは、自分に変えられることと、変えられないことを冷静に見極めることです。	7
	3	そして変えられることは勇気を持って変える。	7
	3	その姿勢で臨めば成果はあがるでしょう。	7
	3		7
	3		7
	3	正しい使い方を簡単に、誤った使い方を困難に	5
	3	Scott Meyers	6
	3	インタフェース仕様を決定する作業は、ソフトウェア開発プロジェクトには必ず必要です。	7
	3	「インタフェース」には、抽象度の高いもの(ユーザインタフェース)もあれば、低いもの(関数インタフェース)も、その中間のもの(クラスインタフェース、ライブラリインタフェースなど)もあります。	7
	3	つまり、システムとユーザの間のインタフェースもあれば、プログラマとAPIの間のインタフェースもあり、関数とクラスの間のインタフェースなどもあるわけです。	7
	3	いずれにしろ、その設計が重要であることには変わりありません。	7
	3	設計が良ければインタフェースは使いやすくなり、生産性は向上することになるでしょう。	7
	3	反対に設計が悪ければ、インタフェースがストレスやミスの原因になります。	7
	3		7
	3	良いインタフェースとは次の2つの条件を満たすインタフェースのことです。	7
	3		7
	3	正しく使用する方が操作ミスをするより簡単: インタフェースの設計が良ければ、ユーザは、ほぽ間違いなく正しく使用できます。	7
	3	それは、正しい使い方が「一番易しい使い方」になっているからです。	7
	3	GUIの場合なら、正しいアイコンやボタン、メニュー項目が、正しくないものより簡単に見つけられます。	7
	3	どれが正しいのかが一目でわかるようになっているのです。	7
	3	APIの場合なら、どのパラメータにもほぼ間違いなく正しい値を渡せます。	7
	3	一番「自然な値」が正しい値なのですぐにわかるのです。	7
	3	正しく使用することが簡単であれば、物事はすべてスムーズに進みます。	7
	3		7
	3	誤った使い方をすることが困難: 優れたインタフェースというのは、使う人間がどういう間違いをしそうか、あらかじめ予期した作りになっているものです。	7
	3	そして、そういう誤りが起きにくいよう対策を講じであります。	7
	3	たとえばGUIなら、そのコンテキストで実行しても無意味なコマンドは、自動的に使用不能になる(あるいは、なくなる)ようになっています。	7
	3	APIの場合なら、引数をどの順序で指定しても同じ結果になるように したりします。	7
	3	それによって「指定順序を間違える」という問題自体が発生しないようにしているのです。	7
	3		7
	3	簡単に正しく使え、ミスをしにくいインタフェースを作るには、「作る前に使ってみる」という方法が有効です。	7
	3	たとえばGUIなら「モツクアップ」を作ってみましょう。	7
	3	ホワイトボードに描いてもいいし、インデックスカードを机の上に並べてみてもいいでしょう。	7
	3	要するにコードを書く前にそれでシミュレーションしてみるわけです。	7
	3	APIの場合なら、そのAPIの関数を宣言する前に、呼び出しのコードを書いてみましょう。	7
	3	それらの方法を使って、通常あり得そうなユースケースの一つ一つについて、インタフェースがどう機能すべきかを事前に検証します。	7
	3	実際に使用する際にはどういうアイコンやボタンをクリックすることになるか。	7
	3	どういう引数を渡すことになるか。	7
	3	使いやすいインタフェースの特徴は「自然であること」です。	7
	3	「自然である」というのは、「常にその状況で一番しやすいことをしていれば、自動的に正しい使い方になる」という意味です。	7
	3	そういうインタフェースを作ろうとすれば、作り手がユーザの視点で物を見る必要があります(作る前に使ってみるという手法は、その意味で非常に有利です)。	7
	3		7
	3	使い方を間違えにくいインタフェースを作るには2つの方法が有効です。	7
	3	1つは、ユーザがしそうな間違いを事前に予測し、それを防止する策を講じることです。	7
	3	もう1つは、リリース後の早い時期に実際にインタフェースがどのように誤用されるかを観察し、改良を加えることです。	7
	3	誤用を防ぐ最良の方法は、そもそもその誤用を不可能にしてしまうことでしょう。	7
	3	観察の結果、ユーザが取り消し不可能な操作を何度も取り消そうとしているとわかった場合には、その操作を取り消し可能にすべきです。	7
	3	APIに誤った値が渡されることが多いとわかれば、できる限り、実際によく渡されている値を正しいものとして扱えるような改良をしましょう。	7
	3		7
	3	何より重要なのは、インタフェースが存在するのはユーザの利便のためであり、開発側の利便のためではないということです。	7
	3	それを忘れてはなりません。	7
	3		7
	3		7
	3	見えないものを見えるように	5
	3	Jon Jagger	6
	3	ソフトウェアの世界には、とにかく「目に見えない」ものが多く、目に見えないことが良いとされることもよくあります。	7
	3	目に見えないことに関連して使われる語彙も非常に豊富です。	7
	3	たとえば「メカニズムの透明性」、「情報隠蔽」などはその例でしょう。	7
	3	ソフトウェア自体、元々形がなく、目には見えないものですし、それを開発する過程で何が行われているかも見えにくいものです。	7
	3	ダグラス・アダムズの小説のタイトルをもじって言えば「ほとんど透明」ということになるでしょう。	7
	3	「目に見えない」ということに関しては、次のようなことが言えます。	7
	3		7
	3	何事にしろ、「目に見えない」というのは危険です。	7
	3	人間は目に見えるもの、具体的なかたちのあるものについてはよく考えますが、そうでないものについてはあまり考えない傾向にあるのです。	7
	3	存在や変化が目に見えていれば、それにうまく対処することができます。	7
	3		7
	3	ソフトウェア開発プロジェクトを進める際はいつでも、目に見える証拠がたくさんあるという状態を維持すべきでしょう。	7
	3	目に見える証拠があれば、進捗状況も正確に把握できます。	7
	3	決して頭の中だけの思い込みで判断はしなくなります。	7
	3	突然思いがけない事実が発覚して予定が変わってしまう、ということがなくなり、意図したとおりにプロジェクトが進行するようになります。	7
	3		7
	3		7
	3	並行処理に有効なメッセージパッシング	5
	3	Russel Winder	6
	3	並行処理(concurrency)、特にその一種である並列処理(parallelism)は「非常に難しいもの」と考えられています。	7
	3	並行処理が難しいことはプログラミングを学び始めたばかりの人でも知っていることでしょう。	7
	3	並行処理についてたとえ不正確にでも理解できるのは、経験を積んだ非常に優秀なプログラマだけと考える人が多いのです。	7
	3	しかし、スレッド、セマフォ、モニタといった概念への関心は常にとても高く、「変数へのスレッドセーフな並行アクセスは難しい」といったこともよく話題になります。	7
	3		7
	3	確かに並行処理に関しては、非常に解決の難しい問題が数多くあります。	7
	3	そして問題の根本は何かと探っていくと、それは結局「共有メモリ」であるという結論に達するのです。	7
	3	並行処理に関連する問題には、競合状態、デッドロック、ライブロックなどがありますが、そのほとんどが、可変メモリの共有に関係しています。	7
	3	だとすれば、どうするのがいいかは明白です。	7
	3	「並行処理、メモリ共有のどちらかをやめればいい」のです。	7
	3		7
	3	並行処理を一切やめる、という選択があり得ないのは明らかでしょう。	7
	3	プロセッサのコア数は、現在急速に増えています。	7
	3	四半期ごとに増えていると言ってもいいくらいです。	7
	3	つまり、並行処理、特に並列処理の重要度は高まる一方ということです。	7
	3	もはやプロセッサのクロック速度の向上だけでは、アプリケーションのパフォーマンスの向上はあまり期待できなくなっています。	7
	3	並列処理に頼ることではじめて、パフォーマンスが改善されると言ってもいいくらいです。	7
	3	これ以上パフォーマンスを向上させるつもりがないのならいいでしょうが、それがユーザに受け入れられるとは思えません。	7
	3		7
	3	ではメモリの共有をやめることは本当に可能なのでしょうか。	7
	3	実は可能なのです。	7
	3		7
	3	プログラミングモデルとして、スレッドや共有メモリの代わりにプロセスやメッセージパッシングを使うという方法があります。	7
	3	ここでの「プロセス」は、必ずしもOSのプロセスというわけでなく、単に「他から保護され、独立した状態の実行コード」という意味なので注意してください。	7
	3	Erlang(あるいはそれより前のOccam)などの言語を見ると、プロセスが並行/並列システムにとって非常に有効なメカニズムであるということがよくわかります。	7
	3	プロセスをプログラミングモデルとして使用したシステムでは、共有メモリ、マルチスレッドのシステムのような同期の問題が起きないのです。	7
	3	また、その種のシステムを構築する場合には、CSP(Communicasing Sequential Processes)というフォーマルモデルを利用することができます。	7
	3		7
	3	さらに踏み込んで、データフローシステムを導入するという方法もあります。	7
	3	データフローシステムにおいては、プログラムに明確な制御フローというものは存在しません。	7
	3	代わりに、データパスで接続された、オペレータの有向グラフを構築するという方法を採ります。	7
	3	そうしてできたシステムにデータを流し込むのです。	7
	3	どのような処理が行われるかは、システムにどのようなデータが入力されるかによって変わります。	7
	3	当然、同期の問題は起きません。	7
	3		7
	3	とは言うものの、現在システム開発の主流となっているC、C++、Java、Python、Groovyといった言語はどれも、共有メモリ、マルチスレッドのシステムに対応した言語です。	7
	3	ではどうすればいいのでしょうか。	7
	3	方法はあります。	7
	3	プロセスモデル、メッセージパッシングに対応したライブラリやフレームワークを利用すること、無ければ作ることです。	7
	3	そうすることで、可変メモリの共有を一切せずに済むようにするのです。	7
	3		7
	3	まとめると、共有メモリを使わずメッセージパッシングを使ってプログラミングをすることが、現在のコンピュータハードウェアにはどうしても必要な並行/並列処理にとって最も有効な方法だと言えるでしょう。	7
	3	面白いのは、プロセス自体は、並行処理の単位としてはスレッドより古いということです。	7
	3	そして今後は、スレッドを使ってプロセスを実装するということが行われるようになるのではないかと考えています。	7
	3		7
	3		7
	3	未来へのメッセージ	5
	3	Linda Rising	6
	3	「取り組む問題が難しければ、そのソリューションも難しく、わかりにくいものになるのが当然」そう考えている人がどうも多いようです。	7
	3	問題が難しいのだから、それに対応するソリューションは理解しにくく、保守も難しいものになって当たり前と思っているようなのです。	7
	3	皆おそらく賢い人たちばかりだからだと思いますが、私が長年の間に、教えたり、共に仕事をしてきた大勢の人たちの大半がそう思っているようでした。	7
	3	何ヶ月か時間が経つと、書いた本人でさえ理解が難しくなる、そんなコードを書いても変だとは思わないようです。	7
	3		7
	3	思い出すのは、ジョーのことです。	7
	3	ジョーは、私が担当していたデータ構造のクラスの生徒でした心彼は自分の書いたコードを持ってきて私に見せ、「難しいのが書けました。	7
	3	先生にも何のコードなのかきっとわからないと思いますよ」と言いました。	7
	3		7
	3	「確かにそのとおりね」私はほんの少しコードを見ただけですぐに同意しました。	7
	3	どう話せばいいか少し迷いましたが、結局、こんなふうに切り出しました。	7
	3	「これ、きっとがんばって書いたんでしょうね。	7
	3	でも、あなたは大事なことを忘れている気がする。	7
	3	そうそう、ジョー、あなた、弟いる?」。	7
	3	「ええ、いますよ!フィルです。	7
	3	入門のクラスにいます。	7
	3	弟もプログラミングを勉強しているんです」ジョーは誇らしげにそう言いました。	7
	3		7
	3	「それはよかった」私はそう答えました。	7
	3	「ところで、弟さんにはこのコード、読めるかな」「絶対無理ですね」ジョーは言いました。	7
	3	「何しろ高度なプログラムですからね!」「ちょっと考えてみて。	7
	3	もし、あなたがこのコードをどこかの会社で仕事として書いたとする。	7
	3	何年後かにフィルも同じ会社に入ってきて、コードの保守を任されたとする。	7
	3	あなたがとても難しくてわかりにくいコードを書いていたとしたら、フィルはどういう目に遭うと思う?」ジョーはじっと私を見ていましたが、それを聞いてちょっと瞬きをしました。	7
	3	「フィルはきっと、とても賢い子よね?」。	7
	3	ジョーはうなずきました。	7
	3	「あんまり言いたくはないけど、僕も賢いですよ」ジョーはにやりと笑いました。	7
	3	「じゃあ、聞くけど、今見せてもらったこのコード、私にはよく意味がわからない。	7
	3	あなたの賢い弟さんにもきっとわからないでしょう。	7
	3	だとしたら、あなたの書いたコードに一体、何の意味があると思う?」ジョーは改めて自分のコードを見ました。	7
	3	「こう考えたらどうかな」私は穏やかに、できるだけ「良き助言者」らしい声で彼に言いました。	7
	3	「自分の書くコードは、全部、未来の誰かへのメッセージだと思うのよ。	7
	3	その誰かは、あなたの弟さんかもしれない。	7
	3	誰か、とても賢い人に、自分が難しい問題をどう解いたのか、丁寧に説明するつもりで書くの」。	7
	3	「想像してみて。	7
	3	いつか、誰か賢い人が、あなたの書いたコード見て言うのよ。	7
	3	『おおっ、これはすごい!何が書いてあるか完壁にわかる。	7
	3	なんて簡潔でわかりやすいんだ。	7
	3	美しい。	7
	3	本当に美しいコードだよ。	7
	3	傑作だ! 皆に見せなく』ってね」。	7
	3	「ジョー、難しいことはやっているんだけど、簡潔で美しいコード、あなたならそういうのが書けるはずよ。	7
	3	美しい、まるで歌うようなコード。	7
	3	一度聞いたら忘れないメロデイのようなコーれこれだけ複雑なコードを書ける人なら、きっと美しいコードも書けるはず。	7
	3	私、これからは、コードの美しさを見て点をつけようかしらね。	7
	3	どう思う?」。	7
	3	ジョーは、コードを書いた紙を手に取って、私を見た。	7
	3	顔には微笑みが浮かんで、いる。	7
	3	「先生、わかりましたよ。	7
	3	フィルのためにこのコード、書き直します。	7
	3	ありがとうございました」。	7
	3		7
	3	ポリモーフィズムの利用機会を見逃さない	5
	3	Kirk Pepperdine	6
	3	「ポリモーフィズム」は、オブジェクト指向の基礎を成す重要な概念です。	7
	3	元々はギリシャ語で「多数」を意味する”poly”と「形」を意味する”morph”に由来します。	7
	3	プログラミングにおいてポリモーフィズムとは、同じクラスのオブジェクトやメソッドが複数の形(form)を取り得るということを意味します。	7
	3	しかしポリモーフイズムは、ただ単に実装が複数になるということを意味しているのではありません。	7
	3	ポリモーフイズムをうまく使えば、オブジェクトやメソッドの特性、動きを、コンテキストに応じて細かく変えることができます。	7
	3		7
	3	しかも、そのために冗長なif-then-elseブロックを書く必要がないのです。	7
	3	そのかわり、コンテキストによってオブジェクトやメソッドが自動的に形を変えるためには、「このコンテキストならこのオブジェクト、あるいはメソッドを使う」というコードをあらかじめコンテキストの外で書いておく必要があります。	7
	3	ポリモーフィズムを有効に活かせば、その分コードの量が滅り、読みやすくなります。	7
	3	そのメリットがよくわかるコード例(実用的なものとは言えませんが…)を1つ見てみましょう。	7
	3	シンプルなショッピングカートのコードです。	7
	3		7
	3	仮に、このWebショップでは、ダウンロードできる商品と、物理的な配送を必要とする商品の両方を扱っているとしましょう。	7
	3	それに対応するためには、たとえば次のようなクラスを作ることになります。	7
	3		7
	3	顧客が注文手続きを済ませたら、次のコードで商品のダウンロード、あるいは配送を開始します。	7
	3		7
	3	”???”という部分は、実際にこう書くわけではありません(こういう演算子が本当にあるわけではありません) 。	7
	3	ここは、コンテキストによって、eメールアドレスか配送先の住所が入るはずのところです。	7
	3	つまり上記の例では、実際にどちらを入れるのかを決めるコード、つまりコンテキストを決めるコードが足りないということになります。	7
	3	booleanやenumと、if-then-elseブロックを使えば、このパラメータに入る値は決定できます。	7
	3	他には、Itemを継承するクラスを2つ作るという方法も考えられます。	7
	3	ここでは、その2つのクラスにDownloadableItem、SurfaceItemという名前をつけることにしましょう。	7
	3	それぞれのコードは次のとおりです。	7
	3	この場合、Itemは正確にはクラスではなくインタフェースで、shipというメソッドを1つ持っています。	7
	3	ショッピングカートに入った商品が出荷される際にはitem.ship(shipper)が呼び出されます。	7
	3	Downloadableltem、SurfaceItemという2つのクラスではいずれもこのshipメソッドを実装しています。	7
	3		7
	3	この例では、Shippingクラスのshipメソッドを呼び出す仕事をItemクラスに委譲しています。	7
	3	物理的に配送すればいいのか、ダウンロードの方がいいのかという指定はItemクラスが自動的にするので、if-then-elseブロックを書かなくても、商品ごとに適切な出荷ができます。	7
	3	上記のコードは、CommandパターンとDouble Dispatchパターンという2つのパターンの使用例でもあります。	7
	3	この2つは、組み合わせて使うと効果的なことが多いパターンです。	7
	3	2つのパターンを組み合わせる上で重要になるのが、ポリモーフィズムをうまく利用することで、す。	7
	3	それができれば、if-then-elseブロックの数を減らすことがで、きるのです。	7
	3		7
	3	もちろん、ポリモーフイズムを利用するより、if-then-elseブロックを使った方が良いという場合も時にはあります。	7
	3	しかし、ポリモーフイズムを利用する方が、コードが読みやすく、またバグも少なくなる可能性が高いのです。	7
	3	コードの中に今、if-then-elseブロックになっている箇所があるのなら、そのすべてについてポリモーフイズムが使えないか検討した方が良い、と言ってもいいでしょう。	7
	3		7
	3		7
	3	テスト担当者はプログラマの友人	5
	3	Burk Hufnagel	6
	3	会社によってQA(Quality Assurance :品質保証)と呼ばれたりQC(Quality Control :品質管理)と呼ばれたりしますが、いずれにしろその仕事を担当している人たちのことを、プログラマの多くは「悩みの種」だと思っています。	7
	3	私の直接知っている範囲でも、テスト担当者たちと敵対的な関係に陥っているプログラマは多くいます。	7
	3	「小うるさい」「完壁主義すぎる」という愚痴もよく聞きます。	7
	3	読者の中にも同じような人は多いのではないでしょうか。	7
	3		7
	3	私自身は、彼らに対してまったく違った印象を持っています。	7
	3	そうなった原因はおそらく、最初に勤めた会社でテストを担当していた人にあると思います。	7
	3	その会社でテストを担当していたのは何と総務部長でした。	7
	3	マーガレットという名前の女性で、とても感じの良い人でした。	7
	3	いつも業務がスムーズに進むよう、細かいところにまで気を配ってくれ、私も含めた若いプログラマたちの教育も買って出ていました。	7
	3	プロとして顧客の前ではどう振る舞うべきなのかを教えていたのです。	7
	3	そして、彼女はバグを見つける才能にも恵まれていました。	7
	3	どれほど目立たないバグだろうとすぐに見つけてしまうのです。	7
	3		7
	3	当時私が担当していたプログラムは、元々は経理担当の人間が書いたものでした。	7
	3	書いた本人は、自分の腕はプロ並みだと思っていたようですが、実際はやはりプロではないため、プログラムは重大なバグをいくつか抱えていました。	7
	3	その修正が私の仕事だったのです。	7
	3	修正ができるとマーガレットがテストをします。	7
	3	私としては完全に直したつもりだったのですが、彼女が使い始めると、ほんの少しキーを叩くだけで、すぐに妙な動きをするのです。	7
	3	新たなバグが見つかったというわけです。	7
	3	もちろんそのときは、いらだたしい思いや恥ずかしい思いをすることもありましたが、ともかく彼女が感じの良い人だったので、恨む気持ちはまったくありませんでした。	7
	3	テスト、デバッグを繰り返すうち、ついにその日が来ました。	7
	3	マーガレットが使っても、プログラムは何の問題もなく起動され、請求書の作成からプリントアウト、終了までまったく滞りなく進んだのです。	7
	3	実に嬉しい瞬間でした。	7
	3	さらに素晴らしかったのは、顧客のコンピュータにプログラムがインストールされてからです。	7
	3	プログラムには何の問題も起きず、ずっと順調に動き続けました。	7
	3	リリース前にあらゆるバグをマーガレットが見つけてくれたからでしょう。	7
	3		7
	3	テスト担当者たちは、プログラマの敵ではなく「友人」であると私は言いたいです。	7
	3	彼らは、取るに足りないと思えるような問題を逐一指摘してくるかもしれません。	7
	3	それで「恥をかかされた」と思う人もいるでしょう。	7
	3	しかし、些細に思える問題でも解決しておけば、顧客はその問題に煩わされずに済みます。	7
	3	そうすれば、あなたは恥をかくどころか、顧客から高く評価されるでしょう。	7
	3	素晴らしいことではないでしょうかそれはテスト担当者が問題を見つけてくれたからこそ、できたことなのです。	7
	3	私の言う意味はもうおわかりでしょう。	7
	3		7
	3	想像してみてください。	7
	3	たとえば今、とても革新的な人工知能アルゴリズムを利用したソフトウェアが納入され、はじめて使ってみているところだとします。	7
	3	人工知能が、並行処理に関する問題を自動的に発見し修正してくれるという触れ込みです。	7
	3	起動してみたら、最初の方に表示される画面で”intelligence”のスペルが間違っているのに気づきました。	7
	3	何となく嫌な予感がしますが、単なるタイプミスです。	7
	3	大した問題ではありません。	7
	3	さらに操作すると、環境設定の画面で、ラジオボタンであるべきところにチェックボックスが使われているのが見つかりました。	7
	3	それからキーボードショートカットがいくつか機能しないのにも気づきました。	7
	3	どれも大問題というわけではないのですが、数が多くなると、作ったプログラマに対する信頼感は揺らいでくるはずです。	7
	3	こんな簡単な問題の修正もちゃんとできない人たちが作った人工知能、本当に大丈夫だろうか。	7
	3	並行処理の問題はずっと難しいのに、それを発見して修正するなどという芸当が果たしてできるのだろうか。	7
	3	そう思っても不思議はありません。	7
	3		7
	3	もちろん、プログラマたちが大変な天才で、AIを素晴らしいものに仕上げるのに熱中するあまり、些細な問題にはまったく気づかないということはあり得ます。	7
	3	それでも、他の人間にテストをさせれば、些細な問題は見っかり、顧客の目に触れるようなことはなかったはずです。	7
	3	それができないというのは、プログラマとしての資質を疑われでも仕方ないでしょう。	7
	3		7
	3	だから、些細な問を社内で見つけてくれ、顧客の目に触れないようにしてくれるテスト担当者は、プロクラマにとって「友人」と言えるのです。	7
	3	なかなか納得はできないかもしれませんが、それは本当です。	7
	3		7
	3		7
	3	バイナリは常に1つ	5
	3	Steve Freeman	6
	3	私の見てきた限り、ビルド中にコードの一部分を書き換え、ターゲット環境ごとに違うカスタムバイナリを生成する、ということはよく行われているようです。	7
	3	ただ問題なのは、そういうことをすれば、必要以上に事態が複雑になってしまうということです。	7
	3	インストールする度に新しいバージョンが生まれるということになりかねないからです。	7
	3	同じソフトウェアの、ほとんど同じだけれどわずかに違っているというバージョンがいくつも生まれることは確かです。	7
	3	しかもそれぞれ違う場所にデプロイしなくてはなりません。	7
	3	これは不確定要素を必要以上に増やし、ミスをする可能性をわざわざ高めてしまっているといえます。	7
	3		7
	3	私が以前いた開発チームでは、プロパティに変更を加える度にチェックインし、フルビルドをやり直さなくてはならない、ということになっていました。	7
	3	テスト担当者は、ごくわずかな修正が行われるだけでも、その度に待たされることになります(ビルドには、もちろん大変な時間がかかります)。	7
	3	製品版は開発版とは別に、ゼロからビルドすることになっていた(使用するスクリプトは開発版と同じ)チームもありました。	7
	3	システム管理者がそうするよう強硬に主張したからです。	7
	3	こうなってしまうと、開発チームがテストに使用したバージョンと製品版が完全に同一で、あるという保証はまったく無いことになります。	7
	3	同じような話は他にもたくさんあります。	7
	3		7
	3	バイナリに関しては、1つ簡単なルールを守るようにするだけで、問題の発生をかなり減らせるはずです。	7
	3	その簡単なルールとは「皆が常に同一のバイナリを使用するようにする」です。	7
	3	開発を通じたどのステージにおいても、バイナリは常に1つという状態を維持するのです。	7
	3	提供先の環境毎に違うバイナリを作るのではなく、どの環境でも同じバイナリを使い、細かい調整は環境の側で行います。	7
	3	調整のための情報はコンポーネントコンテナや、設定ファイル、ファイルパスなどに保持します。	7
	3		7
	3	ビルド中にコードを書き換えたり、ターゲットごとに違うコードを使うというのは、どう考えても賢明とは言えません。	7
	3	そういうことをするのは、開発チームの中に、設計について真剣に考える人間が誰もいない証拠です。	7
	3	深く考えていないので、アプリケーションのコアの部分と、各プラットフォームに固有の部分との切り分けをしていないので、す。	7
	3	切り分けをした方がいいとわかっているのに、他のことで忙しいので後回しにしている場合もあるかもしれません。	7
	3	これはさらに良くないことです。	7
	3		7
	3	もちろん例外はあります。	7
	3	たとえば、ターゲットごとにリソースの制約が大きく違っている場合などです。	7
	3	しかしそういう例外は、大部分の人が開発している「データベースと画面の問のデータ入出力」アプリケーションには当てはまらないでしょう。	7
	3	ただ、開発チームでずっと昔からバイナリをいくつも作るやり方を続けているため、自分が変えたいと思っても急には変えられないということもあり得ます。	7
	3	その場合は、徐々に改善していくしかないでしょう。	7
	3	それでも、着手は早ければ早いほど良いというのは確かです。	7
	3		7
	3	もう一点重要なのは「環境に関する情報もバージョン管理の対象とする」ということです。	7
	3	環境設定の変更によって問題が発生したが、どこが変わったのかはわからなくなってしまった、というのは最悪です。	7
	3	環境に関する情報は、コードとは分けてバージョン管理するといいでしょう。	7
	3	環境とコードでは、変更される頻度もその理由も異なるためです。	7
	3	そのため、分散バージョン管理システム(bazaar、gitなど)を利用しているチームもあります。	7
	3	製品版の環境に変更を加えた場合(そういうことはどうしても発生します)、それを簡単にリポジトリに反映させることができるからです。	7
	3		7
	3		7
	3	真実を語るはコードのみ	5
	3	Peter Sommerlad	6
	3	プログラムというのは、突き詰めれば実行されるために存在するものであり、読むためのものではありません。	7
	3	そもそもバイナリ形式になっていれば、読むことは容易ではないでしょう。	7
	3	しかしソースコードが手に入る場合もあります。	7
	3	自分自身の書いたプログラムなら当然ソースコードは手元にあるでしょう。	7
	3	商用ソフトウェアであってもその開発チームにいればソースコードを見ることができますし、オープンソースのソフトウェアならソースコードが公開されています。	7
	3	動的に実行されるインタープリタ型言語のプログラムの場合も、ソースコードの入手は容易です。	7
	3	ソースコードを読めば、そのプログラムがどういう意味を持っているのかは明確にわかるはずです。	7
	3	むしろ「プログラムの動作を完全に正確に知るには、結局はソースコードを見るしかない」とも言えるでしょう。	7
	3	要件定義書がたとえどれほど詳細に正確に書かれていたとしても、それが真実をすべて語ってくれるわけではありません。	7
	3	プログラムが実際にどう動くかが書かれているわけではなく、要件定義をした人間がどういう意図を持っているかが要約されているにすぎません。	7
	3	設計書もそうです。	7
	3	プログラムがどういう設計で作られる「予定だったか」が書かれているだけで、具体的にどう実装されたか、その詳細はわかりません。	7
	3	文書と実装との同期が切れている場合もありますし、書かれた文書がなくなってしまうこともあります。	7
	3	はじめから設計書が書かれないことだってあるでしょう。	7
	3	いずれにしろ、手がかりはソースコードだけ、ということです。	7
	3		7
	3	それを踏まえ、「では自分の書いているソースコードは果たしてどうだろうか」と自問してみてください。	7
	3	果たして、自分自身を含め、人に「このプログラムにはこういう意味があり、こういうことをしています」ということが明確に伝わるものになっているでしょうか。	7
	3		7
	3	「コメントに全部書いてあるから大丈夫」という人もいるかもしれません。	7
	3	しかし問題は「実行されるのはコメントではない」ことです。	7
	3	やはりコメントも他の種類の文書と同様に、誤ったことが書かれている恐れがあります。	7
	3	長い問、コメントを占くことは、無条件に「良いこと」とされてきたので、深く考えずに大量のコメントを書くプログラマもいます。	7
	3	何度も同じことが書かれていたり、コードを少し見ればすぐにわかるようなことが逐一説明されていたり。	7
	3	これではかえってコードがわかりにくくなってしまいます。	7
	3		7
	3	「このコードはコメントがなければわかりにくい」と感じたのなら、コメントを書くよりも、リファクタリングすることを検討した方がいいでしょう。	7
	3	コメントが大量にあると両面が見にくくなりますし、IDEの中には、コメントを自動的に非表示する機能を備えたものもあります。	7
	3	コードに何か変更を加えて、その変更の内容について説明したい場合にも、コメントに書くのではなく、バージョン管理システムへのチェックインの際に添えるメッセージに書くべきでしょう。	7
	3		7
	3	読んで、わかりやすいコードを書くにはどういうことをすればいいでしょうか。	7
	3	まず重要なのは、名前のつけ方です。	7
	3	システムを構成する各部分に、見てすぐに機能がわかるような名前をつけるのです。	7
	3	そのためには、コードの構成を「各部分の機能が非常に明確で、言葉で簡単に説明できる」ものにすべきです。	7
	3	コードをわかりやすくするには、部分同士ができるだけ依存関係を持たないようにすること、直交性(orthogonality)を高めることが大切です。	7
	3	自動テストを書いて「プログラムがどのような挙動をするはずか」を説明し、インタフェースのチェックをするというのも有効な方法です。	7
	3	その他、コードを少しでもシンプルにする方法がわかった時や、現状より少しでも良いソリューションが見つかった時には、即座にリファクタリングをすべきでしょう。	7
	3	可能な限り、プログラムを読みやすく、わかりやすくするのです。	7
	3		7
	3	コードを書くことは、詩やエッセイ、不特定多数の人に見せるブログ、あるいは大切な要件を伝えるメールなどを書くのと同じようなものと考えるべきです。	7
	3	表現を工夫し「このプログラムはどう動くものなのか」ということが、コードの読み手にストレートに伝わるようにするのです。	7
	3	書いた人間がそばにいて、逐一説明できるという状況ではなくても、書き手の意図が明確に伝わるようにするのです。	7
	3	プログラムのコードは、有用性を持つ限り使い続けられるので、思いがけず長く使われることがあります。	7
	3	コードが読んでわかりやすいものになっていれば、保守担当者はきっと書いた人に感謝するでしょう。	7
	3	逆に、他人が書いたコードを読んでいるのだけれど、何を言っているのかわからないという時は、ここに書いた方法を応用して、わかりやすく書き直すべきです。	7
	3	自分の目に触れるコードをすべてわかりやすいものにしておけば、あらゆる作業が円滑に進むようになります。	7
	3		7
	3		7
	3	ビルドをおろそかにしない	5
	3	Steve Berczuk	6
	3	コーディングプラクティスについての規約は厳格に守っているのに、ビルドスクリプトに関しては無頓着、そんな開発チームは実はそう珍しくありません。	7
	3	その背後には、ビルドスクリプトなどさほど重要でないので、細かいことまで気にする必要はない、という思い込みがあるようです。	7
	3	あるいは、ビルドスクリプトはあまりにも複雑なので、難しいことはリリースエンジニアリングの専門家に任せた方がよい、と考えている人も多いかもしれません。	7
	3	どちらにしろ、適切な保守がなされず、重複やエラーを多く含んだビルドスクリプトを使用し続けていると、大きな問題を引き起こすことになります。	7
	3	その問題の深刻さは、汚いコードがそのままになっている場合と変わりません。	7
	3		7
	3	技術力もあり、ルールを守って質の高いコードを書くプログラマが、ビルドのこととなると意外に無頓着になる。	7
	3	そうなってしまう原因は、ビルドスクリプトが、開発するソフトウェアそのもののコードとは違う言語で書かれるからなのかもしれません。	7
	3	彼らの頭の中では、ビルドスクリプトのコードは「コードではない」ということなのでしょうか。	7
	3	もしそうだとすれば、それはおかしな話です。	7
	3	最近では多くのプログラマが複数の言語を積極的に学ぶようになりました。	7
	3	ビルドスクリプトを書く言語も言語の一種ならば、積極的に学んでもいいはずです。	7
	3	それに、プログラマやエンドユーザが実行やテストをするための実行ファイルを作るのはビルドスクリプトなのです。	7
	3	コードはビルドきれなければ何の役にも立たないし、アプリケーションのコンポーネントアーキテクチャを定義するのもビルドです。	7
	3	ビルドは開発プロセスの中でも特に重要な部分と言えるでしょう。	7
	3	ビルドプロセス次第で、コードをシンプルにし、コーディング作業にかかる労力を減らすこともできるのです。	7
	3		7
	3	ビルドスクリプトは、不適切な書き方をしてしまうと保守が困難になる上、後で改善することも容易ではなくなります。	7
	3	そういうビルドスクリプトをどうすれば良いものに変えられるかを、時間を多少かけてでも是非学ぶべきでしょう。	7
	3	ビルドスクリプトのバグが顕在化するのは、誤ったバージョンのコードに依存してしまっている場合や、ビルド時の環境設定が不適切な場合です。	7
	3		7
	3	以前はコードのテストというと、品質管理(QA)チームに任せておけばよいものとされていました。	7
	3	しかし今日では「質の高いコードを確実に提供するためには、コーディングとテストを並行して行うべき」という考え方が常識になってきています。	7
	3	それと同じように、ビルドプロセスも、これからは開発チームの仕事と考えるべきではないでしょうか。	7
	3		7
	3	ビルドについて正しく理解すれば、開発のライフサイクル全体にかかる労力を減らしコストの削減をはかることもできるでしょう。	7
	3	ビルドが簡単に実行できるようになっていれば、入って日の浅い新人に担当してもらうこともできます。	7
	3	また、ビルドの設定を自動化しておけば、プロジェクトに関わる人の数が増えても、得られる結果がまちまちということがなくなります。	7
	3	「Aさんのマシンでは動くのにBさんのマシンではダメ」というようなことが起きなくなるのです。	7
	3	コードの品質についてレポートするツールも数多くあるので、そうしたツールを使えば問題の存在をいち早く察知できるでしょう。	7
	3	ビルドについて深く学べば、自分自身だけでなく、必ず開発チーム全員のためになるはずです。	7
	3	質の高いビルドスクリプトを作り、ビルドにかかる手間を省くことができれば、皆がコーディングの作業に集中することができ、作業がより楽しいものになるからです。	7
	3	それは関係者全員にとって喜ばしいことです。	7
	3		7
	3	ビルドプロセスについての理解が十分ならば、それに変更を加える時期や万法などもよくわかります。	7
	3	ビルドスクリプトも、開発するソフトウェアのコードと同様、やはりコードです。	7
	3	しかも非常に重要なコードですから、とても他人に任せるわけにはいきませんそもそもビルドなしではどんなアプリケーションも完成しません。	7
	3	プログラミングの仕事は、動作するソフトウェアを提供するまで決して終わらないのです。	7
	3		7
	3		7
	3	プリミティブ型よりドメイン固有の型を	5
	3	Einar Landre	6
	3	1999年9月23日、火星探査機「マーズ・クライメイト・オーピター(MCO)」は火星を周回する軌道への突入に失敗し、燃え尽きました。	7
	3	3億2,730万ドルが失われた原因はソフトウェアのエラーでした。	7
	3	そのエラーは、具体的には「単位の混在」でした。	7
	3	同じ数値の単位を、地上のソフトウェアではポンドとしていたのに対し、宇宙船ではニュートンとしていたのです。	7
	3	その結果地上では、宇宙船のスラスタ推力を実際の約4.45分の1とみなしてしまうことになりました。	7
	3		7
	3	データの型付けがもっと強ければ、あるいはドメイン固有の型が使われていれば問題の発生を防げたという事例は数多くありますが、MCOの事故もその1つと言えるでしょう。	7
	3	プログラミング言語Adaには、これを根拠とする機能が多数組み込まれています。	7
	3	Adaは、安全性が特に重要視される組み込みソフトウェアの実装を目的として設計された言語だからです。	7
	3	Adaは型付けが強く、プリミティブ型とユーザ定義型の両方について、以下のような静的チェックをするという特徴があります。	7
	3		7
	3	この種のアプローチは、静的な型付けの言語でも、動的な型付けの言語でも同様に有効です。	7
	3	両者の違いは、静的な型付けの言語では、コンパイラが型のチェックをしてくれるのに対し、動的な型付けの言語では、ユニットテストで型のチェックをせざるを得ないということくらいでしょう。	7
	3	ただ、型チェックの手段は違っても、ドメイン固有の型を使う目的や、その使い方は基本的に同じです。	7
	3		7
	3	マーズ・クライメイト・オーピターの事故を貴重な教訓とし、ドメイン固有の型を積極的に使ってソフトウェアの品質を高めるべきです。	7
	3		7
	3		7
	3	ユーザの操作ミスを防止する	5
	3	Giles Colborne	6
	3	エラーメッセージは、ユーザとシステムの間の重要なコミュニケーション手段です。	7
	3	エラーメッセージが出るのは、ユーザとシステムの間のコミュニケーションに危機が生じている時である、とも言えます。	7
	3		7
	3	ユーザが入力の際に何かミスをしたことが、エラーの原因かもしれません。	7
	3	ミスする方に責任があると思ってしまえば確かに話は簡単です。	7
	3	しかし、人間のミスには一定の傾向があります。	7
	3	それを知っていれば、どこでミスをしそうか、あらかじめ予測することもできるはずです。	7
	3	つまり方法によっては、ユーザのミスを事前に予防することも可能ということです。	7
	3	これを、ユーザとシステムの間のコミュニケーションの「デバッグ」と考えてもいいでしょう。	7
	3	デバッグとは何もシステム内部の話だけではないのです。	7
	3		7
	3	たとえば、ユーザがシステムに日付を入力する場面について考えてみてください。	7
	3	日付は一定の範囲内のものしか受けつけないとします。	7
	3	この場合は、ユーザに日付をすべてゼロから手入力させるのは得策とは言えません。	7
	3	それよりも、カレンダーやリストを表示し、その中から日付を選ばせる方がいいでしょう。	7
	3	カレンダーやリストに、受けつける範囲内の日付しかなければ、範囲外の日付を入力してしまうというミスは起きなくなります。	7
	3		7
	3	フォーマット間違いのエラーもよく起きます。	7
	3	しかし、たとえば日付のテキストフィールドに”July 29, 2012”と入力されたとして、これが指定のフォーマット(“DD/MM/YYYY”など)とは違っているからエラーにしてしまうのは理不尽ではないでしょうか。	7
	3	他の日付と誤解しようはないわけですから、フォーマットが違うというだけでは理由として弱いです。	7
	3	もっとひどいのは、”29 / 07 / 2012”という入力を、余分なスペースが入っているからといってエラーにしてしまうようなやり方です。	7
	3	ユーザにしてみれば、なぜエラーにされてしまったのか分かりにくいでしょう。	7
	3	「ちゃんと指定のフォーマットで入力したはず」と思うユーザは多いに違いありません。	7
	3		7
	3	指定のフォーマットと少しでも違っていればエラーにするという方法を採れば、確かに作る側は楽です。	7
	3	少しくらいの違いは許容するようにしようとすれば、あらかじめユーザがどういうフォーマットで入力しそうかを予測して、それと一致しているかを確認するコードを書くという手間がかかるからです。	7
	3	しかし、ほんの少しのフォーマットの違いでエラーにされてしまうと、ユーザにとっては大きなストレスになります。	7
	3	ストレスで操作がぞんざいになり、さらにエラーが続くということにもなりかねません。	7
	3	そうならないように日付に限らず何か情報の入力を求める際は、ある程度のフォーマットの違いは許容できるようにすべきです。	7
	3	「入力して欲しいのはあくまで情報であり、データではない」ということを考慮すべきでしょう。	7
	3		7
	3	この種のエラーを予防するには、入力時に指定のフォーマットをユーザに知らせるという方法も使えます。	7
	3	たとえば、はじめから”DD/MM /YYYY”という文字列が入った状態で入力フィールドが表示されるようにしておく、というのもその1つです。	7
	3	ユーザは”DD”や”MM”の部分を上書きすればいいわけです。	7
	3	また、入力フィールドを日、月、年の3つのテキストボックスに分け、それぞれ2文字、2文字、4文字を入力できるようにしてもよいでしょう。	7
	3		7
	3	「事前に使い方を指示すればいいのでは」と考える人もいるかもしれません， しかし、文章で長々と説明されても理解は難しいものです。	7
	3	実際に使ってみなければわからないこともあります。	7
	3	その点、入力フィールドにあらかじめ文字列を入れておくという方法なら、自分がいま何をすればいいのかがわかるので、ユーザにとってはこの方がありがたいのです。	7
	3		7
	3	使い方の指示をしても、エラーの発生を防ぐことにはまず役立ちません。	7
	3	ほとんどのユーザは、過去に似たようなインタフェースを使った経験から何をどう入力すべきかを推測するだけで、指示など読まないからです(前に”July 29, 2012”と入力して大丈夫だったから、今度も大丈夫だろう、というふうに考えます) 。	7
	3	それに対し、これから入力するまさにそのフィールドに、フォーマットについてのヒントがあれば、ユーザはすぐにどう入力すればいいか理解できます。	7
	3	それでエラーの発生が防げるのです。	7
	3		7
	3	デフォルト値を提供することも、エラー防止の方法としては有効です。	7
	3	フォームに日付を入力する際、よく入力されるのは、今日の日付や明日の日付、自分の誕生日、何かの期日、前回同じフォームに入力をした日付などでしょう」状況に応じて、そのいずれかをデフォルトにしておくのが賢明です。	7
	3		7
	3	その原因に関係なく、システムはユーザの操作ミスに対し寛容で、あるべきです。	7
	3	そのために役立つのが「アンドゥ機能」です。	7
	3	あらゆる操作、特にユーザのデータを破壊したり、データに変更を加えたりする可能性のある操作を、いくつもさかのぼって無効にできると、操作ミスが起きても安心です。	7
	3		7
	3	アンドゥ操作をログに記録してそのログを解析すれば、どういうところでユーザがうっかり操作をミスしやすいか探ることができますの何度も間違えてクリックしているボタンなどを知ることができるわけです。	7
	3	そういうミスは「指示が表示されているが理解されていない」さりげなくユーザを誘導しようとしているが、かえって誤解を招いている」といったことが原因で起きていることも多いので、ミスが起きないよう改良を加えるべきでしょう。	7
	3		7
	3	どういう種類のシステムであっても、ユーザのミスには一定の傾向があるものです。	7
	3	多くの場合、ミスはユーザとソフトウェアがお互いを誤解した結果として生じるのです。	7
	3	そうしたミスを防ぐには、ユーザがデータを入力する際、どのように考え、情報をどのように解釈し、どのように判断を下しているかを知ることが重要なのです。	7
	3		7
	3		7
	3	プロのプログラマとは？	5
	3	Robert C. Martin	6
	3	プロのプログラマとは、どういう人のことでしょうか。	7
	3		7
	3	プロフェッショナルなプログラマの最大の特徴は「自分が責任を取る」という態度、責任感です。	7
	3	プロのプログラマは、まず自分のキャリアに責任を持ちます。	7
	3	責任の取れないような見積りやスケジューリングは決してせず、作る製品の質にも責任を持ちます。	7
	3	ミスがあれば、必ず自ら対応します。	7
	3	他人に責任を押しつけるようなことは一切しない、それがプロです。	7
	3		7
	3	プロであるということは、責任を負うということです。	7
	3	自分のキャリアにも、製品の質にも責任を負います。	7
	3	製品の質に責任を負うということは、無駄がなく、動作も正しいコードを常に書き続けるということです。	7
	3	たとえ納期に追われて余裕がなくなった時でも、決して手を披くことなく、最善の努力を尽くして良い製品を作るということです。	7
	3		7
	3		7
	3	バージョン管理システムを有効に使う	5
	3	Diomidis Spinellis	6
	3	バージョン管理は、プロジェクトを構成するあらゆるものについて必要です。	7
	3	そのためには、Subversion 、Git、Mercurial、CVS などのフリーのバージョン管理ツール、大量のディスクスペース、安価でパワフルなサーバ、ユビキタスなネットワーク、さらにはプロジェクトホスティングサービスといったリソースを使うことになるでしょう。	7
	3	まずやるのはバージョン管理ツールのインストールです。	7
	3	インストールが終わったら、管理対象のコード以外に余分なものの置かれていない「クリーンな」ディレクトリに対し適切なコマンドを発行し、コードをリポジトリに登録します。	7
	3	バージョン管理ツールの操作は基本的には2種類しかありません。	7
	3	「コードの変更をリポジトリにコミットする」という操作と、「プロジェクトの作業ディレクトリで作業中のバージョンをリポジトリのバージョンと同期する(アップデー卜する)」という操作です。	7
	3		7
	3	プロジェクトのバージョン管理を開始すると、変更履歴が自動的に記録されます。	7
	3	誰がいつどんなコードを書いたのかが分かるようになり、ファイルやプロジェクトの特定のバージョンが問有のIDで取得できるようになります。	7
	3	重要なのは、こうしてバージョンを完全に符理しておけば、大胆なコード変更を恐れることなくできるということです。	7
	3	あとでわからなくならないように、コードを消さずにコメントアウトしておく必要もありません。	7
	3	古いバージョンは必ずリポジトリに残っているからです。	7
	3	ソフトウェアのリリースには個々にタグづけできます(そうすべきです)。	7
	3	リリース毎に、タグを見てすぐにそれとわかるような名前を作ることができるのです。	7
	3	タグづけをしておけば、いつでも好きなバージョンのファイルをすぐに取り出すことができます。	7
	3	プロジェクトのバージョンを、並行して進められているいくつかのブランチに分けて管理するということも可能です。	7
	3	多くの場合、プロジェクトはアクティプな開発ブランチと、すでにリリースされたバージョンをサポートするための保守ブランチ(複数の場合あり)に分かれています。	7
	3		7
	3	バージョン管理システムを使っていれば、担当者ごとに使うファイルのバージョンが違っている、というような事態の発生を防げます。	7
	3	個々のプログラマが自分の担当部分のことだけを与えて作業していても、バージョン管理システムが上手く同期をとってくれます。	7
	3	もし他人の担当部分に影響するような変更をした場合には、バージョン管理システムがその旨を通知し、矛盾の発生を防ぐのです。	7
	3	変更がコミットされる度にチーム全員に通知されるような設定もできます。	7
	3	そういう設定にしておけば、プロジェクト進行についての認識が人によって違う、ということは起きません。	7
	3		7
	3	プロジェクトを構成する要素は、とにかく何でもバージョン管理の対象にすべきでしょう。	7
	3	ソースコードだけでなく、ドキュメントやツール、ビルドスクリプト、テストケース、画像ファイル、ライブラリなど、ありとあらゆるものをバージョン管理の対象とするのです。	7
	3	プロジェクトのすべてをリポジトリに登録しておけば(そして、定期的にバックアップをとっておけば)、ディスクの破損やデータの消失によるダメージは最小限に食い止められます。	7
	3	開発マシンを新しくする際も、そのためのセットアップ作業は、リポジトリからプロジェクトをチェックアウトするというくらいで済みます。	7
	3	コードの配布、ビルドテストなどを何種類ものプラットフォームで行う場合も特に複雑な作業は必要ありません。	7
	3	マシン毎にアップデートコマンドを実行するだけで、ソフトウェアのバージョンが最新に保たれるからです。	7
	3		7
	3	バージョン管理システムはこのように非常に便利なものですが、有効に利用するためには、開発チームのメンバー全員が次のルールを守るべきでしょう。	7
	3		7
	3	どれも守るのが難しいルールではないはずです。	7
	3	こうしたルールを守るだけで、バージョン管理システムの有効性を保ち、プロジェクトを円滑に進めることができるのです。	7
	3		7
	3		7
	3	いったんコンピュータから離れてみる	5
	3	Burk Hufnagel	6
	3	何時間も集中して考えているのに、問題があまりに難ししなかなか解決策が思いつかない。	7
	3	仕方がないので、散歩に出てみたり、自動販売機まで何かを買いに行ったりしたら、帰りに突然答えがわかった。	7
	3	そういう経験をしたことのある人は案外多いのではないでしょうか。	7
	3		7
	3	どうしてこんなことが起きるのでしょうか。	7
	3	コーディング中は脳の論理を司る部分だけがはたらいていて、創造を司る部分がはたらいていないためではないかと私は考えています。	7
	3	発想の飛躍が求められるような場面では、論理を司る部分が休まない限り、解決策が見つからないということなのかもしれません。	7
	3		7
	3	そのメソッドでは、次のようなコードで、(時間を表す)2文字を数値に変換し、値が適切な範囲内にあるか検証していました。	7
	3		7
	3	冗長でわかりにくいコードだと，思った人も多いと思います。	7
	3	確かにそのとおりです。	7
	3	私もそう思ったので、改修することにしました。	7
	3	メソッドをリファクタリングし、ユニットテストをいくつか書いて、正しく機能することを確認しました。	7
	3		7
	3	改修結果にはとても満足していました。	7
	3	改修後のバージョンは読みやすいだけでなく、サイズも半分になり、加えてより確実な検証ができるようになったからです。	7
	3	元のコードのように、時間、分、秒が上限を超えていないかを確認するだけでなく、より厳密に確認するようにしたのです。	7
	3		7
	3	しかし翌朝、仕事を始める前に1つひらめいたのです。	7
	3	「どうして正規表現を使って文字列を検証するコードにしなかったのだろう」。	7
	3	わずか数分間の作業で、コードは次のようにたった1行になりました。	7
	3		7
	3	ここで重要なのは、30行以上あったコードが最終的にたった1行になったということではありません。	7
	3	コンピュータに向かい合っているうちは「もうこれ以上のものはできない」と，思っていた、ということです。	7
	3		7
	3	ここまで書いてきたような問題解決方法もあるのです。	7
	3	ある問題について十分に考えたら、あとは音楽を聴くなり、散歩をするなりして、脳の創造を司る部分をはたらかせてみてください。	7
	3	じっとコンピュータの前に座って考え込んでいるより、その方が良いアイデアを思いつくものです。	7
	3		7
	3		7
	3	コードを読む	5
	3	Karianne Berg	6
	3	私たちプログラマは妙な生き物です。	7
	3	総じてコードを書くことは大好きなのに、コードを読むとなると嫌がってしまうという性質があります。	7
	3	コードを書くのは楽しいのに、読むのは辛いと感じるのです。	7
	3	時には読むことがまったくできないときもあります。	7
	3	特に辛いのが、他人が書いたコードを読むことです。	7
	3	他人の書いたコードがひどいからではなく、思考や問題解決の方法が自分とは違っているからです。	7
	3	しかし、意外かもしれませんが、実は他人の書いたコードを読むことは自分の成長につながるのです。	7
	3		7
	3	他人のコードは、色々と考えながら読むようにするといいでしょう。	7
	3	まず考えるべきことは、そのコードが読みやすいか読みにくいかです。	7
	3	もし読みにくいとすれば、それはなぜでしょうか。	7
	3	フォーマットが良くないからでしょうか。	7
	3	命名に一貫性がなかったり、論理的でなかったりするからでしょうか。	7
	3	1つのコードで同時に複数の問題を扱っているからでしょうか。	7
	3	使われている言語のせいで読みにくいということもあります。	7
	3	他人のコードを読んでいて、何か間違いを見つけたら、自分がコードを書く時には同じことをしないでおこうと考えるでしょう。	7
	3	読んでいて、色々と驚くような発見もあるはずです。	7
	3	たとえば、コードの中には依存関係を持つ箇所をできるだけ作らないのがよいとされます。	7
	3	一般に、ある箇所と別の箇所の結合度が高いのは望ましいこととはきれないのです。	7
	3	しかし実際にコードを見ていると、依存関係を排除したために読みにくくなっているものも見つかります。	7
	3	ある人が「エレガント」と思うコードが別の人には「読みにくい」と感じられる、というのは大いにあり得ることです。	7
	3		7
	3	読みやすいコードを見つけたら、よく調べ、そこからできるだけ多くのことを学び取るようにすべきでしょう。	7
	3	知らないデザインパターンが使われていることもあるでしょうし、自分が以前実装にとても苦労したデザインパターンが使われていることもあります。	7
	3	同様のメソッドでも明らかに自分より簡潔に書ける人もいれば、メソッドの名前の付け方がいいので機能がすぐにわかることもあります。	7
	3	オープンソースプロジェクトには、読みやすく質の高いコードばかり、というものもあれば、その正反対のものもあります。	7
	3	コードをチェックアウトして少し見れば、どちらなのかは多分すぐにわかると思います。	7
	3		7
	3	以前関わっていたプロジェクトで自分が書いたコードを読み返すのも勉強になります。	7
	3	古いものから順に自分の書いてきたコードを読み返していくと、書いたときには読みやすいと思っていたのに、今読むとそうでもないと気づくでしょう。	7
	3	特にプログラミングを始めたばかりのコードを読み返すのは、恥ずかしいけれど、面白い体験になるでしょう。	7
	3	まるで夜にお酒を飲みながら話したことを朝に思い出すときのようです。	7
	3	そうやって、自分がこれまで何年もの間どうやってスキルを磨いてきたのか、それをあらためて確認すれば、また新たなやる気が湧いてくるものです。	7
	3	もちろん、昔のコードに読みにくい筒所が見つかったら、今も同じようなコードを書いていないか確認することも大切です。	7
	3		7
	3	プログラミングの技術を本気で、磨きたいと，思っているのなら、本を読むのもいいですが、一番いいのは、他人が書いたものでも自分の書いたものでも、とにかくコードを読むことです。	7
	3		7
	3		7
	3	「人間」を知る	5
	3	Keith Braithwaite	6
	3	ソフトウェア開発のプロジェクトでは、よほど小規模なプロジェクトは別にして、必ず人と人とが共に仕事をすることになります。	7
	3	研究などでは稀にソフトウェアを作ることそのものが目的ということもありますが、ほとんどのソフトウェアは、誰かの目標達成を手助けするために書かれます。	7
	3	つまり、人は、人とともに、そして人のためにソフトウェアを書くというわけです。	7
	3	ソフトウェア開発は「人のビジネス」なのです。	7
	3	それにもかかわらず、プログラマが人との関わりについて教育を受けることは、残念なことにほとんどありません。	7
	3	幸い役立つ学問分野もあるので目を向けてみることにしましょう。	7
	3		7
	3	たとえば、ルートヴィヒ・ウィトゲンシュタインは「哲学探究」などの著書の中で、「私たちが互いに話をする際には言語を使うが、私たちの頭の中にある思考や発想、画像などが、そのまま言語に変換されて他人の頭に送られるわけではない」という主旨のことを言っています。	7
	3	開発するソフトウェアの要件を顧客に確認する際に、十分注意が必要な理由の一部は、少なくともここにあるのでしょう。	7
	3	ウィトゲンシュタインはまた、私たちがお互いに理解し合うためには、「定義の共有」ではなく、「経験の共有」が必要だと言っていました。	7
	3	生きていく中で得た経験に共通する部分がないと理解し合えないというわけです。	7
	3	ソフトウェア開発の場合、問題領域に関して経験のあるプログラマの方が、経験のないプログラマよりも良い仕事をすることが多いですが、そうなる理由もそれでわかるでしょう。	7
	3		7
	3	ジョージ・レイコフとマーク・ジョンソンは著書「レトリックと人生」の中で、言語は大部分が比喩的なもので、その比倫により、私たちが世界をどのように見ているかがわかるということを述べています。	7
	3	金融の世界でよく聞かれる言葉に「キャッシユフロー」というのがありますが、このような具体的事象を指す言葉にも、やはり比職的な部分はあります。	7
	3	「フロー(flow : 流れ)」という言い方をするからには、お金を液体のように捉えている、ということになるからです。	7
	3	この比倫によって、お金を扱うシステムに対する私たちの見方がわかります。	7
	3	また、ソフトウェアの世界の、「プロトコルのスタック」「レイヤー」といった言い方や、「ハイレベル」「ローレベル」といった言い方にも同じようなことが言えます。	7
	3	こういう言い方をすると、ユーザを「上」、コンピュータやソフトウェアを「下」とみなすことになるからです。	7
	3	私たちがシステムの構造に対してどう考えているかが、こうした言葉からわかるのです。	7
	3	このように物事をいくつかの層に分割して捉えると理解が容易になることがあるため、人間はよくそういうことをします。	7
	3		7
	3	マルテイン・ハイデガーは、「道具(ツール)」というものに人間がどう関わるかを詳しく考察しました。	7
	3	プログラマの場合は、ツールを自ら作ることもあり、使うこともあります。	7
	3	以前に作られたツールを改良することもあれば、同様のツールを新たに作り直すこともあります。	7
	3	プログラマは、ツールには強い関心を持ちます。	7
	3	しかしユーザはどうでしょうか。	7
	3	ハイデガーが著書「存在と時間」で言っているとおり、道具というものはそれを使う人間にのみ理解できる存在です。	7
	3	使わない人間にとっては目に見えない存在なのです。	7
	3	ユーザにとってツールは、正しく機能しなくなってはじめて関心を持つものかもしれません。	7
	3	ツールの使い勝手などについて話し合う際には、こうしたプログラマとユーザの意識の「ずれ」を念頭に置いておくべきでしょう。	7
	3		7
	3	私たちの思想、世界観には、いまだにアリストテレスの影響が強く残っています。	7
	3	アリストテレスのように物事を分類して考える習慣がいまだに残っているのです。	7
	3	エレノア・ロッシュは、それを覆そうとしました。	7
	3	プログラマは、システムを構築する際にユーザに要望を尋ねます。	7
	3	そのときプログラマがやろうとするのもやはり、アリストテレス的な「分類」です。	7
	3	ユーザの話を聞き、求められていることを明確な定義を基にカテゴリに分けるのです。	7
	3	そうするのがプログラマにとって非常に便利だからです。	7
	3	この方法を採ると、ユーザの話に出てきた言葉をそのままクラスの属性にしたり、テーブルのカラムにしたりできます。	7
	3	各要素がきれいに分かれた、理路整然としたプログラムができあがります。	7
	3	しかし困ったことに、生物としての人間は、元来そのように世界を認識していないのです。	7
	3	エレノア・ロッシュは、そのことを「ナチユラルカテゴリー」の研究やその後の研究を通じて明らかにしています。	7
	3	人間は、「例」に基づいて物事を理解します。	7
	3	例の中でも、特に「プロトタイプ」と呼ばれるものは、他よりも優勢で大きな影響力を持ちます。	7
	3	このような例に基づく分類は、暖昧で、要素の重複の多いものになり、各カテゴリーは豊かな内部構造を持つことになります。	7
	3	「アリストテレス的」な答えを求めている限り、私たちはユーザに対して、妥当な問いを発することができないのです。	7
	3	ユーザの物の捉え方と相容れないからです。	7
	3	そのため、共通理解を得るのに大変な苦労を強いられることになります。	7
	3		7
	3		7
	3	車輪の再発明の効用	5
	3	Jason P. Sage	6
	3	この言葉、人によって言い方は少しずつ違うでしょうが、聞いたことのある人は多いのではないでしょうか。	7
	3	仕事の現場でも、大学などでも頻繁に言われることだからです。	7
	3	しかしなぜでしょうか。	7
	3	「車輪の再発明」はどうしてそんなに忌み嫌われるのでしょうか。	7
	3	それはまず、新たにコードを書くより、既存のコードを流用する方が安全でコストが少なくて済むからです。	7
	3	既存のコードは、その多くが「正しく動作すると既に確認されたコード」です。	7
	3	厳しいテストによって品質を高められ、製品としても役立ってきた実績のあるコードが多いのです。	7
	3	既存の製品やコードベースに時間と労力を投資したのに、同様のものを再度作ってまた時間と労力を投資するのは無駄、という考えもあります。	7
	3	あえて車輪の再発明をするのだとしたら、それなりの理由は必要でしょう。	7
	3		7
	3	世の中には、ソフトウェア開発のパターンや、設計について書かれた本がたくさん出回っています。	7
	3	読者の中にも読んだことのある人は多いでしょう。	7
	3	ただ、そういう本は、いくら素晴らしいことが書かれていても、だいたいは読むと眠くなります。	7
	3	ヨットの出てくる映画を見るのと、実際に自分でヨットに乗るのとではまったく違います。	7
	3	それと同様、すでに存在するコードを流用するのと、自分でゼロからソフトウェアをデザインし、テストし、バグ修正をして品質を高めていくのとでは、まるで違うのです。	7
	3		7
	3	「車輪の再発明」をしようと思えば、ただ単に目的に合う部品を探してきて、適切な場所にはめ込むだけでは済まなくなります。	7
	3	部品から自分の手で作ろうとすれば、その部品に中でどういう処理をさせる必要があるのか、また他の部分はどういう処理をしているのか、嫌でも詳しく知ることになります。	7
	3	メモリ管理、たとえば仮想ページングなどはどうなっているでしょうか。	7
	3	果たして自分の手でそれを実装できるでしょうか。	7
	3	双方向リスト、動的配列クラス、ODBCクライアント、自分が普段使っているようなGUIのコードなどを自分で書けるでしょうか。	7
	3	Webブラウザウィジェットを自ら作れるでしょうか。	7
	3	多重化システムをマルチスレッドシステムのかわりに書くことや、ファイルベースのデータベースとメモリベースのデータベースのどちらを使うか、自分で判断することなどはできるでしょうか。	7
	3		7
	3	こういうソフトウェアの核になる部分を自ら実装する機会を持てるプログラマはごくわずかです。	7
	3	このため普通の開発者は、これらの部分が現実にどのように機能しているのかを詳しく知ることができません。	7
	3	どう動いているか自分ではわからないために、神秘的なもの、「ブラックボックス」のようなものとみなし、機能した結果を利用するしかなくなっているのです。	7
	3	水面だけを見ていたのでは、その下にどんな危険が潜んで、いるかわかりません。	7
	3	また、底の方で何が起きているのかがわからなければ、せっかく優れた能力があっても、できることは限られてしまいます。	7
	3		7
	3	車輪の再発明をしようとした結果、失敗をすることもあるでしょう。	7
	3	しかし、それは一度で車輪の再実装がうまくいくよりも貴重な体験になるはずです。	7
	3	自分の予でゼロからコードを書き、あれこれと試行錯誤をすることを通して学ぶのは、ただ技術者を読んで学ぶこととは大きく違います。	7
	3	試行錯誤をしている間は、悔しがったり喜んだり、感情が大きく動くことになるからです。	7
	3		7
	3	本を読むなどして知識を頭に入れることも大切です。	7
	3	しかし優れたプログラマになるためには、経験を積むことがどうしても必要です。	7
	3	現場で多くを見て、自分の手で何かを作ることが必要なのです。	7
	3	車輪の再発明は、プログラマが学び、技術を高める上で非常に重要なことです。	7
	3	ボディビルダーがバーベルを上げるのと同じよろなもの、と言ってもいいでしょう。	7
	3		7
	3		7
	3	シングルトンパターンの誘惑に負けない	5
	3	Sam Saariste	6
	3	シングルトン(Singleton)パターンは多くの問題の解決に役立つパターンです。	7
	3	このパターンでは、クラスのインスタンスは必ず1つしか生成されません。	7
	3	そのインスタンスは使用前に必ず初期化されます。	7
	3	そしてシングルトンをグローバルアクセスポイントとすることで、設計をシンプルにできます。	7
	3	こう書いていくと良いことずくめのようですが、この「古典的な」デザインパターンに何か短所はあるのでしょうか。	7
	3	実はたくさんあります。	7
	3	それはよく考えてみるとわかります。	7
	3	確かにシングルトンパターンは魅力的なのですが、私の経験では、このパターンには利点よりも弊害の方が多いと言えます。	7
	3	まずテストの妨げになります。	7
	3	そして保守性の点でも不利です。	7
	3	残念ながらその事実は広く知られているとは言えないため、多くのプログラマを窓きつけているのです。	7
	3	つい使いたい誘惑にかられますが、その誘惑に抵抗しなくてはなりません。	7
	3		7
	3	シングルトンパターンに具体的にどんな問題があるかを次にまとめておきます。	7
	3		7
	3	シングルトンは、クリーンアップに関しても問題を起こしやすいと言えます。	7
	3		7
	3	シングルトンの欠点の中には、ある種のメカニズムを付加することで克服できるものもあります。	7
	3	しかし、それによってコードはどうしても複雑になってしまいます。	7
	3	シングルトンパターンさえ選択しなければ、そういう心配はいらないのです。	7
	3		7
	3	シングルトンパターンは、必要なインスタンスが絶対に1つだけと確信できるクラス以外では使うべきではないでしょう。	7
	3	そして、シングルトンをグローバルアクセスポイントとすることも避けるべきです。	7
	3	グローバルアクセスポイントになってどこからアクセスされるかわからないというのは良くないのです。	7
	3	シングルトンへの直接のアクセスは、あらかじめ定めておいたごく少数の箇所からのみ行うようにします。	7
	3	そして他のコードからは、インタフェースを通じてアクセスするのです。	7
	3	他のコードは、そのインタフェースを実装するのがシングルトンなのか、あるいは他の種類のクラスなのか、ということには関知しません。	7
	3	つまりシングルトンに依存しないのです。	7
	3	それにより、ユニットテストの妨げとなる依存関係も生じずに済み、保守性も向上します。	7
	3	今後、シングルトンの実装やシングルトンへのアクセスを検討する時があれば、いったん立ち止まって、ここに書いたようなことをじっくり考えてみてください。	7
	3		7
	3		7
	3	パフォーマンスへの道は地雷コードで敷き詰められている	5
	3	Kirk Pepperdine	6
	3	パフォーマンスチューニングでは、多くの場合、コードの変更が必要になります。	7
	3	そしてどんなコードにも必ず、複雑すぎる部分や、依存性が高すぎる部分が含まれているものです。	7
	3	そういうコードは、いわば地雷のようなもので、途中で昨裂してチューニングを妨げます。	7
	3	地雷の昨裂により第一に犠牲になるのは、当然のことながら、プロジェクトのスケジュールです。	7
	3	作業の進行速度が常に一定で、途中で、特に大きな問題が起きないのであれば、いつ完了するかの予測は簡単でしょう。	7
	3	しかし時折地雷が昨裂するとなると、完了時期の正確な予測は極めて難しくなります。	7
	3		7
	3	たとえば、プログラムにホットスポットを発見した場合を考えてみましょう。	7
	3	その場合、通常はそのホットスポットで使用されているアルゴリズムを改善するという対処をすることになります。	7
	3	その作業の所要時間を上司に見積もれと言われ、「3〜4時間です」と答えたとします。	7
	3	しかし作業をしてみたら、実は修正箇所に依存しているコードが他にあり、影響を与えてしまうとわかるかもしれません。	7
	3	もちろん、元々密接に関係している部分が依存し合うのは当然なことなので、それを事前に予測し、依存関係を考慮に入れた計画を立てることも可能でしょう。	7
	3	壊れた依存関係を修復する作業も発生するという前提で計画を立てるのです。	7
	3	ただ問題なのは、その修復によってまた別の依存関係が壊れる恐れもあるということです。	7
	3	そして、壊れる箇所が、元々の修正箇所との関係が薄いところだとしたら、そもそも壊れると予測するのが難しい、ということもあります。	7
	3	その場合には、スケジュールを立てる段階で考慮に入れるのも困難です。	7
	3	「3、4時間」と見積もった作業に3、4週間かかるようなことも簡単に起きてしまいます。	7
	3	予測外の問題が1つ見つかる度にスケジュールが1、2日遅れるというのも珍しいことではありません。	7
	3	あっという間に終わるはずと，思って始めたリファクタリングの完了に、結局何ヶ月もかかることもよくあるのです。	7
	3	そんなことがあると、作業を担当したチームは信用も立場もなくしてしまうでしょう。	7
	3	下手をするとチームや会社の存続すら危うい事態になってしまいます。	7
	3	せめて、事前にそういうリスクが存在すると察知する手段、あるいはリスクの大きさを評価する手段でもあればいいのですが…..。	7
	3		7
	3	ソフトウェアメトリクスを使うデメリットとしては、扱うべき数値が膨大になりやすいということがあげられます。	7
	3	メトリクスツールが一度に大量の数値を出力すると、慣れないうちは圧倒されてしまうかもしれません。	7
	3	それでも、ソフトウェアメトリクスが、コードをクリーンにする上で非常に役立つ手段であるというのは間違いありません。	7
	3	パフォーマンスチューニングの作業に深刻な悪影響を及ぼす前に、コードの地雷を発見し、排除するのに役立つのです。	7
	3		7
	3		7
	3	シンプルさは捨てることによって得られる	5
	3	Paul W. Homer	6
	3	「やり直し、だな….」Deleteキーを押しながら上司が言いました。	7
	3	私は、毎度のことながらとても沈んだ気持ちで、コンピュータの画面を見つめていました。	7
	3	私の書いたコードが1行1行、きれいに消されていくのを見ていたのです。	7
	3		7
	3	私の上司ステファンは、いつも口うるさい人というわけではなかったのですが、質の悪いコードは一目で察知しました。	7
	3	また、そういうコードをどうすればいいか、よく知っていました。	7
	3		7
	3	私は当時まだ見習いのプログラマで、やる気は十分だったのですが、コードの書き方がまったくわかっていませんでした。	7
	3	プログラムで解決すべき問題が増える度、とにかく解決のために変数を新たに加える悪い癖がありました。	7
	3	それでプログラムの行数も増やしてしまいます。	7
	3	リビジョンが上がる度にコードが良くなることはなく、かわりに規模が大きくなり、複雑さも増してしまうのです。	7
	3	そうなるとやはり、動作は安定しなくなってきます。	7
	3		7
	3	特に急いでいる時には、できれば既存のコードに最低限の修正だけをして済ませたいと考えるのは自然なことです。	7
	3	たとえ既存のコードがひどいものでも、それで済めばありがたい、と考えるわけです。	7
	3	質の悪いものであっても、過去に書いたコードを消せないプログラマが多いでしょう。	7
	3	すべてをゼロからやり直して新しいコードを書くと、修正よりはるかに労力がかかるのではないかと恐れているのです。	7
	3	確かに既存のコードの質が良ければ、作り直しより修正が楽だとは言えますが、質の悪い既存コードは、あっても何の役に立たないことが多いのです。	7
	3		7
	3	役に立たないどころか、既存のひどいコードを無理に残そうした結果、かえって余計な手間がかかってしまうということもあります。	7
	3	ある程度以下の質のコードは、活かそうとはせず、即座に破棄してしまった方が得策と言えます。	7
	3		7
	3	もちろん、せっかく書いたコードをいきなりDeleteキーで全部消してしまうのが必ずしも良いとは言いません。	7
	3	私の上司のやり方は少々極端でしょう。	7
	3	ただ、私の場合は、そうして自分の日の前でコードを消されてしまったことで、2度目(時には3度目もありました)のコーディングの際は、嫌でも慎重に考えるようになりました。	7
	3	質の悪いコードは容赦なく書き直す、場合によってはいっそ全部消してしまう、というくらいの姿勢で取り組む方が、確実に質の向上につながると言えます。	7
	3		7
	3	コードはシンプルなものであるべきです。	7
	3	変数や関数、宣言といった構成要素はできる限り減らすべきです。	7
	3	余分な行、余分な変数…、ともかく余分なものが少しでもあれば、即座に消すようにします。	7
	3	残るべきは、アルゴリズムを完成させ、必要な演算をすべて処理するための、必要最小限の要素だけです。	7
	3	余分な要素、不要なノイズがあると、処理の流れがわかりにくくなり、重要な部分が見えにくくなってしまいます。	7
	3		7
	3	良い部分だけを残して悪い部分は消す、ということも困難なくらいひどいコードであれば、全部消して、はじめから書き直す方がいいのです。	7
	3	せっかく書いたものを結局全部消したという記憶が頭のどこかにあれば、次からは無駄なコードは書かないでおこうと無意識に気をつけるようになるはずです。	7
	3		7
	3		7
	3	単一責任原則	5
	3	Robert C. Martin	6
	3	「変更する理由が同じものは集める、変更する理由が違うものは分ける。	7
	3	」良いデザインの基本原則を1つあげるとすればこれでしょう。	7
	3		7
	3	この原則は「単一責任原則 (Single Responsibility Principle :SR P)」と呼ばれています。	7
	3	これはつまり、1つのサブシステムやモジュール、クラス、関数などに、変更する理由が2つ以上あるようではいけない、ということです。	7
	3	1つ典型的な例をあげましょう。	7
	3	ビジネス ルール、レポート、データベースに関わるメソッドを持つクラスの例です。	7
	3		7
	3	こうすれば、3つのクラスはそれぞれ別のコンポーネントに配置されることになります。	7
	3	レポート関連のクラスと、データベース関連のクラスと、ビジネスルール関連のクラスが、すべて別のコンポーネントに配置されるということです。	7
	3		7
	3	SRPを守り、違う理由で変更し得るコードを別の要素に分けることは、各コンポーネントを独立してデプロイできるような設計をする上で非常に重要な条件なのです。	7
	3		7
	3		7
	3	「イエス」から始める	5
	3	Alex Miller	6
	3	先日、スーパーで「エダマメ(その時は、野菜の一種というだけでどういうものかよく知りませんでした)」を買ったのですが、見つけ出すのは大変でした。	7
	3	とにかく店中を探し回りました。	7
	3	何しろ、野菜コーナーに置いてあるのか、冷凍食品のコーナーに置いてあるのか、それとも缶詰のコーナーにあるのか、全然見当もつかないのですから仕方がありません。	7
	3	結局はあきらめ、そばにいた店員を捕まえて尋ねてみたのですが、その店員も「わからない」というのです。	7
	3		7
	3	店員には他にも何通りもの答え方があったろうと思います。	7
	3	実際にわからないので仕方ないのですが、「わからない」と答えれば、自分の不勉強を私に知らせることになってしまいます。	7
	3	わかっているのかわからないのか、どっちともつかない暖昧な態度を取ることもできたでしょう。	7
	3	あるいは、単に「うちには置いていません」と答えてしまう手もあるかもしれません。	7
	3	しかし彼女はそうせず、わからないと答えた上で、それでも何とか解決策を探し、客である私を助けようとしてくれました。	7
	3	自分の知らなかったことを学び、客の役にも立てる良い機会だと捉えてくれたようです。	7
	3	彼女は他の店員を呼ぴ、ほんの2、3 分で、目的の品物のあるところまで連れて行ってくれました。	7
	3	エダマメは冷凍食品のコーナーに置かれていました。	7
	3		7
	3	この時、店員は私の要求に対し、「店としてこの問題は解決し、顧客の要求に応じなくてはならない」という前提から行動を始めてくれました。	7
	3	言い換えれば、彼女は「ノー」からではなく「イエス」から行動を始めたのです。	7
	3		7
	3	私はテクニカルリーダーという立場になったばかりの頃、自分の役目は、プロダクトマネージヤやビジネスアナリストから来るバカげた要求をはねつけ、自分たちのチームの素晴らしいソフトウェアを守ることだと思っていました。	7
	3	何か要求が来た時には、それを「受け入れるべきもの」ではなく、常に「却下すべきもの」と捉え、その前提でほとんどの会話を始めていたのです。	7
	3		7
	3	しかし、あるとき私は突然悟ったのです。	7
	3	「ノー」でなく「イエス」という返答から始めるようにすれば、それだけ物の見方は大きく変わり、仕事の進め方も変わるだろうと。	7
	3	それからというもの、「イエス」から始めることは、テクニカルリーダーに不可欠な態度だ、とまで考えるようになりました。	7
	3		7
	3	「イエス」から始めるようにする、という簡単な変化だけで、私の仕事への取り組み方は劇的に変わりました。	7
	3	わかったのは、「イエス」という返事の仕方にも多くの種類があるといろことです。	7
	3	たとえば、誰かが「このアプリケーションのウィンドウを全部、円形で半討にしてくれたら嬉しいんだけど」と言ってきたとします。	7
	3	こういう要望は、「バカバカしい」と即座に拒否することもできます。	7
	3	そうはせずに「どうしてですか」と尋ねるようにすると、その方が良い結果になることが多いのです。	7
	3	尋ねてみると、円形で半透明のウィンドウが欲しいと思う、何か切実な理由が本当にあるかもしれません。	7
	3	どうしても「ウィンドウは円形で半透明であること」と定められた規格に準拠しなくてはならない、ということもあり得ます。	7
	3	要望に応え、規格に準拠できるようにすれば、その顧客から大口の契約が取れる可能性もあります。	7
	3		7
	3	要望が出されたコンテキストがわかれば、新しい可能性が広がることが多いのです。	7
	3	実は既存の製品にまったく手を加えなくても、方法によっては要望に応えられる場合も珍しくありません。	7
	3	その場合は、「イエス」と応えても特に何の作業も発生しないのです。	7
	3	「円形、半透明のウィンドウスキンをダウンロードし、ユーザプリファレンスの画面を開いて、「オン」にすればいいですよ」と回答すれば解決、というようなこともあります。	7
	3		7
	3	たとえ同じシステムでも、それに対する見方は人によって違います。	7
	3	そうした認識のズレが、要望をバカげたものに思わせるのかもしれません要望された時に、相手に「なぜ」と問う代わりに、自分に「なぜ、こういう要望が出るのだろう」と問いかけてみるのも有効です。	7
	3	すると、最初に「バカバカしい要望」と思ったのがそもそも間違いだった、とわかることもあります。	7
	3	最終的には、自分だけで判断せずに、社内の他の人の意見も聞いて意思決定をすべきでしょう。	7
	3	重要なのは、「イエス」と言って要望に応えるのは、必ずしも顧客のためだけではない、ということです。	7
	3	そうすることは自分自身や開発チームにとっても役立つのです。	7
	3		7
	3	最終的には要望に応えないとしても、なぜその要望が製品に合致しないのか、きちんとした説明をすれば、実りのある会話ができるでしょう。	7
	3	それにより、作っている製品が果たして適切なものなのか、ということもわかってくるはずです。	7
	3	会話の結論がどうなったとしても、製品がどういうものであるのか、あるいはどういうものでないかを、皆が真剣に考えることになります。	7
	3	それには大きな意味があるでしょう。	7
	3		7
	3	「イエス」から始めれば、人との対立は生まれず、協力関係が生まれるのです。	7
	3		7
	3		7
	3	面倒でも自動化できることは自動化する	5
	3	Cay Horstmann	6
	3	こんなプログラマがいました。	7
	3	モジュールのコードの行数を数えるように指示されたのですが、その時、コードをワードプロセッサの画面にコピー&ペーストしました。	7
	3	ワードプロセッサのカウント機能を使って行数を数えたわけです。	7
	3	次の週も、また次の週も同じように行数を数えました。	7
	3	これは良い方法とは言えません。	7
	3		7
	3	こんなプロジェクトもありました。	7
	3	そのプロジェクトでは、デプロイの度に煩雑で手間のかかる作業をしていました。	7
	3	コード署名の後、その結果をサーバに移動するなどの作業を、マウスを何度もクリックして行う必要がありました。	7
	3	ある時、誰かがスクリプトを書いて自動化しました。	7
	3	最終テストが行われる問、そのスクリプトは何百回も実行されました。	7
	3	予想を上回る使用頻度でした。	7
	3	これはとても良い方法でした。	7
	3		7
	3	自動化できそうな作業があっても、わざわざ何度も同じ手作業を繰り返す人は少なくありません。	7
	3	なぜでしょうか?。	7
	3	よくある誤解#1 :自動化はテストだけのもの テストを自動化すると便利なのは確かです。	7
	3	しかし、なぜテストだけと決める必要があるのでしょうか。	7
	3	同じことの繰り返し作業はプロジェクトのあちこちに見つかるはずです。	7
	3	バージョン管理、コンパイル、JARファイルのビルド、ドキュメント生成、デプロイ、レポート生成などはその例でしょう。	7
	3	多くの場合、この種の作業はマウスを使うよりスクリプトを書く方が効率的です。	7
	3	自動化を行えば、ただ面倒な作業から解放されるだけでなく、作業時間が短縮され、正確さも増します。	7
	3		7
	3	よくある誤解#2: IDE を使っていれば自動化の必要はない ソフトウェア開発においては、チームのメンバ一間で「自分のマシンでは、チェックした/ビルドできた/テストを通った」云々…という言葉がよく交わされます。	7
	3	最近のIDEには、何千通りもの設定があり得るので、メンバー全員の設定をすべて統ーするというのはまず不可能です。	7
	3	常に同じビルドを繰り返せるようにするには、また全員のビルドを統一するには、AntやAutotoolsといった自動化システムが役立ちます。	7
	3		7
	3	よくある誤解#3 :自動化のためには特殊なツールについて学ぶ必要がある よく知られたシェル言語(bashやPowerShellなど)さえ使えれば、自動化システムの作成は十分にできますWebサイトとのやりとりが必要な場合は、iMacrosやSeleniumなどのツールが使えます。	7
	3		7
	3	よくある誤解#4 :扱うファイルの形式によっては自動化ができないこともある 作業の中で扱うファイルに、Wordドキュメントやスプレッドシート、画像ファイルなどがあると、自動化が難しくなるのは事実です。	7
	3	しかし、そうした形式のファイルは本当に必要なものなのでしょうか。	7
	3	プレーンテキストにすることはできないのでしょうか。	7
	3	CSVやXMLを使ってもいいので、はないでしょうか。	7
	3	テキストファイルを基に描両をするツールなときもあります。	7
	3	ほんの少し工夫するだけで、作業を大幅に効率化することができるはずです。	7
	3		7
	3	よくある誤解#5 :忙しくて自動化のことまで勉強している時間はない 自動化は、何もbashやAntを十分に勉強しなければ始められないというものではありません。	7
	3	自動化を進めながら勉強をするということでかまわないでしょう。	7
	3	自動化できる、自動化すべし、と思う作業が見つかる度に、その自動化に十分なだけの知識を身につける、という方法で大丈夫です。	7
	3	取り組むのがプロジェクトの初期であれば、時間も見つけやすいでしょう。	7
	3	自動化が1度でもうまくいけば、時間と労力を投資するだけの価値があると理解できるはずです。	7
	3	上司や同僚も同じように理解してくれるでしょう。	7
	3		7
	3		7
	3	コード分析ツールを利用する	5
	3	Sarah Mount	6
	3	プログラマの中には、「テストがいかに重要か」を、プログラミングを始めた頃から頭にたたき込まれてきた人が多いでしょう。	7
	3	近年では、ユニットテストやテスト駆動開発、アジャイル開発などが広く行われるようになり、開発サイクルのあらゆるフェーズでテストを最大限活用するという考え方を受け入れる人も増えました。	7
	3	しかし、テストがいかに重要と言っても、それがコードの品質を高める唯一の方法というわけではありません。	7
	3	他にも方法は数多くあるのです。	7
	3		7
	3	はるかな昔、まだCが「新しい言語」だった頃、CPU時間と記憶容量はとても貴重なものでした。	7
	3	このため最初期のCコンパイラでは、コードを読み取る回数を減らすためにセマンティクス分析の一部が省略されていました。	7
	3	つまり、コンパイル時にはバグの検出があまりできなかったのです。	7
	3	その埋め合わせとして、Stephen Johnsonはlintというツールを書きましたにこれは、初期のCコンパイラでは行われなかった静的解析のためのツールで、バグを減らすのに非常に役立ちました。	7
	3	ただ、静的解析ツールには問題もありました。	7
	3	バグの誤検出が多かったのです。	7
	3	実際には問題がないところで警告を出してしまうことも多く、必ずしも守らなくてよいコーディングスタイル上の規約についての警告も多く出してしまっていました。	7
	3		7
	3	現在、言語やコンパイラ、静的解析ツールをめぐる状況は当時とは大きく異なっています。	7
	3	メモリやCPU時間は相対的に「安い」ものになり、コンパイラ自身がチェックできるエラーも大幅に増えました。	7
	3	ほほ全ての言語で、必ず1つは、スタイルガイドの違反や、よく見られるバグを検出するためのツールが用意されるようになっています。	7
	3	中には、ヌルポインタ逆参照など、かなり見つけにくいバグを検出できるツールまであります。	7
	3		7
	3	C向けのSplint、Python向けのPylintなどは、設定変更も可能な高度なツールです。	7
	3	「設定変更ができる」というのは、この場合、検出するエラーや警告の種類を選ぶことができるということです。	7
	3	設定変更には、設定ファイルや、コマンドライン引数などを使用する他、IDEでの設定変更ができる場合もあります。	7
	3	Splintには、プログラムの処理がよりわかりやすくなるよう、注釈をコメントのかたちで入れる機能もあります。	7
	3		7
	3	簡単なバグやちょっとした規則違反が、コンパイラでもIDEでも、lintツールでも検出できないということはあります。	7
	3	その検出のために、独自の静的チェッカーを作ることもできます。	7
	3	そういうと何やら難しそうですが、実際にはそうでもありません。	7
	3	ほとんどの言語、特に「動的」と言われる言語では、抽象構文ツリーやコンパイラツールが標準ライブラリの一部に含まれていて、誰でも使えるようになっているからです。	7
	3	開発に普段使用している言語の標準ライブラリにも、あまり使われないような片隅に、静的解析や動的テストに利用できる便利なものが隠れているかもしれません。	7
	3	よく調べてみる価値はあるでしょう。	7
	3	たとえばPythonの標準ライブラリには、「逆アセンブラ」が含まれています。	7
	3	コンパイル済みのコード、あるいはコードオプジェクトが、どのようなバイトコードから生成されたのかがそれでわかるのです。	7
	3	逆アセンブラなどと言われると、Python言語の開発チームのコンパイラ担当者のみが使うような難解なツールなのではとも思えますが、しかし実際には、一般のプログラマの作業にも驚くほど役立つのです匂たとえば、逆アセンブルできるものの中には、最新のスタックトレースなども含まれます。	7
	3	これにより、直近の(捕まえられなかった)例外を投げたのが、どのようなバイトコードだ、ったのかを正確に知ることができます。	7
	3		7
	3	コードの品質向上にあたっては、テストだけに頼るのではなく、解析ツールも積極的に利用すべきでしょう。	7
	3	自らツールを作ることにも、恐れることなくぜひ挑戦してみてください。	7
	3		7
	3		7
	3	偶然の仕様ではなく本物の仕様のためのテストを書く	5
	3	Kevlin Henney	6
	3	ソフトウェアをテストする際の典型的な落とし穴は、現状の実装コードのやっていることを、あまりに細部にいたるまで厳密にテストしてしまうことです。	7
	3	「細部にいたるまで厳密に」というと一見良いことのようですが、言い方を少し変えれば、なぜ問題なのか分かってきます。	7
	3	テストの典型的な落とし穴は、実装の詳細にテストを強結合してしまうことです。	7
	3	実装コードには、元々の設計でそうしようと意図したわけではなく、実装の都合でたまたまそうしている、という部分が多くあります。	7
	3	そういう、いわば「偶然の仕様」までテスト対象としてしまうのは問題なのです。	7
	3	その仕様が守られているどうかを確かめても意味はありません。	7
	3		7
	3	そういう実装コードの偶然の仕様がテスト対象となっていると、本来の仕様に沿うよう改良を加えることがテストを失敗させてしまうような、テストの誤検出を引き起こしますその時の対処としては、テストの方を修正するのが正しいのですが、コードの方を修正してしまうプログラマもいるでしょう。	7
	3	誤検出されたテストの失敗が本当のエラーだったりすることが何度もあると、不安や疑念を招いてしまいます。	7
	3	テストを修正するにしても、本物の仕様に合っているかを確認するよう修正すれば良いのですが、コードの改良より新たに生じた偶然の仕様に合わせて修正してしまっては何にもなりません。	7
	3	テストはきめの細かい、厳密なものでなくてはなりませんが、同時に、本当にテストすべきことは何かをよく考え、的確なものにする必要があるのです。	7
	3		7
	3	同様の問題は、テキストの形式や内容を比較する際にもよく起きます。	7
	3	文字の間のスペースや、文字の構成に関して、「同じ」とみなす基準が色々に考えられるからです。	7
	3	しかし、たとえば設定変更可能なフォーマッテイング機能を持ったXMLジェネレータを書いているような場合を除いて、テキストに入っているスペースに重要な意味はないことが多いのです。	7
	3	その他、UIコントロールにおけるボタンやラベルの配置などについても同様のことが言えます。	7
	3	偶然その配置になっているだけにもかかわらず、それを絶対に守るべき仕様のようにみなしてテストをしたりすれば、将来、変更や改良を加える余地が減ってしまいます。	7
	3	実装に加えた些細な変更、重要でない変更によって、突然ビルドが中断してしまうということにもなるのです。	7
	3		7
	3	厳密すぎる仕様にとらわれる傾向は、ホワイトボックスアプローチのユニットテストでよく見られます。	7
	3	ホワイトボックステストでは、どのようなテストケースが必要か判断する際、コードの構造を手がかりにします。	7
	3	そのため、現状のコードがしていることを、正しい仕様であると判断してしまいやすいのです。	7
	3	単に現状のものを良しとするテストでは、そもそも実施する意味があまりありません。	7
	3	「テストを実施した」というだけで、作業が進行したような錯覚、不当な安心感を持ってしまうこともあります。	7
	3		7
	3	テストを効果的なものにするには、実装で生じた偶然の仕様を確認するのではなく、あくまでコードが元々の要求に合っているかを確認すべきです。	7
	3	それには、ブラックボックステストが有効です。	7
	3	テスト対象のコードの中身ではなく、外から見た動きに注目してテストを書くのです。	7
	3	動きが元々の要求に合っているかを見るのです。	7
	3		7
	3		7
	3	テストは夜間と週末に	5
	3	Rajith Attapattu	6
	3	タイトルを見て「何を言っているんだ!」と怒った方がいるかもしれませんが、まあ落ち着いてください。	7
	3	私は何も、海外に開発を委託しろとか、週末や夜に出勤して働けとか、そういうことを言うつもりはありません。	7
	3	いま自分たちの持っているコンピュータのパワーをもっと有効に活かすことを考えるべきではと言いたいのです。	7
	3	素晴らしいコンピュータを手にしていながら、そのパワーを、プログラマである自分たちの仕事を楽にすることに十分活かせていないのではないでしょうか。	7
	3	もしかすると読者の中には、常にコンピュータのパワー不足を感じている、という人もいるかもしれません。	7
	3	ただ、それは平日の日中の話ではありませんか? そうだとして、では夜間や週末、テストサーバはどういう状態になっているでしょうか。	7
	3	夜間や週末にはテストサーバを動かしていないところも多いと思います。	7
	3	テストには是非、夜間や週末を利用すべきです。	7
	3		7
	3	夜間や週末に自動でテストをするようにすれば、順列組み合わせを変えたテストの実施回数を増やすことができます。	7
	3	それは、スクリプトの知識が少しあれば、さほど難しいことではないはずです。	7
	3	基本はcronを使ったスケジューリングです。	7
	3	多数提供されているテステイングツールも役立つでしょう。	7
	3	リソースを効率的に利用できるよう、サーバを複数の部署やチームにプールするサーバグリッドを構築している企業もあります。	7
	3	このサーバグリッドをうまく使えば、夜間と週末にテストをすることは十分に可能でしょう。	7
	3		7
	3		7
	3	テストのないソフトウェア開発はあり得ない	5
	3	Neal Ford	6
	3	プログラマには、たとえば配偶者などの家族や友人など、コンピュータに詳しくない人に自分の仕事の難しさ、大変さを話す時、比輸を使う癖があるようです。	7
	3	特にたとえに使われやすいのが、橋の建設などの建築、土木作業です。	7
	3	ただ、この比轍は突き詰めると簡単に破綻します。	7
	3	ソフトウェア開発の作業には、建築、土木作業とは根本的に違っている点がいくつもあるからです。	7
	3		7
	3	ソフトウェア開発の世界では、橋の建設にたとえれば、「橋を作ってから重い物を上にのせてみて、耐えられるかどうかを見る」というようなことをしています。	7
	3	重い物に耐えられれば成功ですが、そうでなければ、製図から見直すのです。	7
	3	しかし、実際の橋の建設は、そういう進め方にはなっていません。	7
	3	過去何千年にもわたり、技術者たちが、建築物、構造物に使える数学や物理学を発達させてきたからです。	7
	3	現在では、それを利用することで、実際に作らなくても、どういうものになるか、かなりの程度までわかるようになっています。	7
	3	しかしソフトウェアの世界には、そういうものはありません。	7
	3	多分、永久にできないでしょう。	7
	3	やはり土木、建築とは根本的に違っているからです。	7
	3	ソフトウェア工学と、その他の工学の違いについて深く考察した例としては、1992年にJack ReevesがC++ Journal誌に寄稿した”What is Software Design? (ソフトウェアデザインとは何か)”という記事がよく知られています。	7
	3	もう20年近くも前に書かれた記事ですが、今でも驚くほど真実を言い当てていると思います。	7
	3	Reevesがこの記事で書いているのは、ソフトウェア開発に携わる者が憂欝になってしまうようなことですが、当時と今とで、は違っていることもあります。	7
	3	それはテストを巡る状況です。	7
	3		7
	3	橋のように形のあるものを「テスト」するのは容易なことではありません。	7
	3	テストをするには、まず作る必要があります。	7
	3	しかし作るにはコストがかかり、いったん作ったものを壊したり修正したりするのも難しいので、「取りあえずだ、いたいの見当で、作って、テストしてみる」ことはなかなかできません。	7
	3	一方ソフトウェアの場合、とりあえず作る、ということにかかるコストは橋などに比べると圧倒的に安くなります。	7
	3	また、テストを容易に進めるための手法、ツールもこれまでに数多く産み出されています。	7
	3	ユニットテスト、モックオブジェクト、テストハーネスなどはその例です。	7
	3	他の分野の技術者だと、テストをするとすれば、まず実際の物を作って、現実の環境下でテストということになるわけですが、ソフトウェアの技術者の場合は、作りながらテストする、テストしながら作るということをします。	7
	3	テストが、品質保証のための第一の手段なのです(もちろん、他にも品質保証の手段はありますが、テストが重要であることは間違いありません)。	7
	3	土木工事などのように数学、物理学は使えませんが、その代わりにテストをすることで、品質を保証するというわけです。	7
	3	そう考えると、「テストなんでしている時間はない」などと言い放つマネージャは非常に困った存在ということになります。	7
	3	橋の建設をする技術者が、上司から「今回は構造解析しなくていいよ何しろ工期が迫っているからね」などと言われることがあり得るでしょうか。	7
	3	テストは、ソフトウェアの品質、再現性を保証するためにどうしても必要なものなのです。	7
	3	それがわかっていれば「テストなんでしていられない」と言うプログラ マに対し、「それは無責任だ」と反論することができるでしょう。	7
	3		7
	3	橋の構造解析に時間がかかるように、テストにもやはり時間がかかります。	7
	3	しかし、どちらも最終的な成果物の質を一定以上に保つためにすることです。	7
	3	ソフトウェアを開発する者にとって、テストをするということは、作るものに責任を持つということなのです。	7
	3	テストをしさえすればそれで十分ということはないですが、まずテストをしないことには話になりません。	7
	3	テストは、ソフトウェア開発の中でも特に難しく、そして重要な部分と言っていいでしょう。	7
	3		7
	3		7
	3	1人より2人	5
	3	Adrian Wible	6
	3	プログラミングには、じっくり物を考えることが必要、じっくり物を考えるには1人になる必要がある…。	7
	3	プログラミングは1人でする作業、というステレオタイプはそこから生まれたのでしょう。	7
	3		7
	3	しかし最近では、プログラミング作業の進め方は変わってきています。	7
	3	「一匹狼」風の方法ではなく、複数人で協力して進めるという方法が主流になってきているのです。	7
	3	協力して作業をする方が、品質も生産性も、自分の仕事に対する満足度も上がると私は思います。	7
	3	プログラマどうしの連携を緊密にするのはもちろんですが、プログラマでない人たち、たとえばビジネスアナリスト、システムアナリスト、QA担当者、ユーザなどとの関係も密にすべきです。	7
	3		7
	3	つまり、プログラマはもはや、技術が優れているだけでは十分でないということです。	7
	3	他人との連携でより大きな成果が上げられるようでなくてはならないのです。	7
	3		7
	3	ここでいう協力、連携というのは、単に人に何かを教わったり教えたりということではないし、また単に会議で話し合ったりすることでもありません。	7
	3	ただ他人の「手伝い」をするということではなく、1つの仕事を他人とともに進めるということなのです。	7
	3		7
	3	私は「ペアプログラミング」の信奉者です。	7
	3	ペアプログラミングは、協力の究極のかたちと言ってもいいでしょう。	7
	3	ペアプログラミングの利点は、プログラマとしてのスキルが確実に向上するということです。	7
	3	プログラミングの技術、あるいは問題領域についての知識が自分より上の人と組んだ場合には、間違いなくその人から多くのことを学べます。	7
	3	逆に自分の方が上だ、った場合も、パートナーに説明しなくてはならないので、すでに知っていたことをさらに詳しく学ぶことになります。	7
	3	その過程で、今まで知らなかったことも多く学ぶはずです。	7
	3	必ず両者がお互いから何かを学ぶことができるのです。	7
	3		7
	3	ペアを組めば、自の前の問題の解決に対して、2人分の知識、2人分の経験が活かせることになります。	7
	3	プログラミング、問題領域について2 人分の知識と経験があれば、1人では決して見えないようなことも見えてきます。	7
	3	その結果、より優れたソフトウェアをより効率的に開発することができます。	7
	3	両者の知識や経験に大きな差があったとしても、お互いが相手から何かを学びます。	7
	3	知識や経験が上の人間が、下の人間から何かを学ぶことも多いのです。	7
	3	新しいキーボードショートカットを覚えることもあれば、未知のツールやライブラリに触れることもあるでしょう。	7
	3	また当然、知識や経験が下の人間は、ペアを組むことで急速に力をつけることになります。	7
	3		7
	3	ペアプログラミングの支持者は、全員がそうではありませんが、多くがアジャイルソフトウェア開発の支持者です。	7
	3	ペアプログラミングに否定的な人がよく言うのは「仕事は1つなのに、どうして2人のプログラマに給料を払わなくてはならないのか」ということです。	7
	3	そう言う人には、私は「嫌ならやめればいい」と答えるしかありません。	7
	3	私が言いたいのは、1人よりもペアのときの方が、1つの仕事のために使える技術やテクニック(IDEを使いこなすコツなども含む)が増え、問題領域についての知識も増えるため、ソフトウェアの品質が向上する可能性が高いということです。	7
	3	また「宝くじのリスク(優れた知識、技術を持ったプログラマがある日、宝くじに当たって、急に会社を辞めてしまうリスク)」も緩和できます。	7
	3		7
	3	ペアプログラミングのパートナーから、今まで知らなかったキーボードショートカットを教わったとして、それによって得られる長期的な利益はどのくらいでしょうかペアを組むことによって、ソフトウェアの品質は全体としてどのくらい向上するでしょうか。	7
	3	それを評価する方法はあるでしょうか。	7
	3	難しい問題に直面した時も、2人であれば行き詰まらずに解決できることが多いですが、その効果が具体的にどのくらいか知ることはできるでしょうか。	7
	3	ある調査によれば、ペアプログラミングには、生産性、作業速度を40%向上させる効果があるという結果が得られています。	7
	3	ただし、効果を定量的に評価することは難しいようです。	7
	3	「宝くじのリスク」を緩和させる効果なども、具体的にどのくらいかを知るのは容易ではありません。	7
	3		7
	3	ペアプログラミングに向いているのはどういう人でしょうか。	7
	3	またペアの相手にはどういう人を選ぶべきでしょうか。	7
	3	もし開発チームに加わったばかりの新人なら、ペアの相手には、知識も経験も豊富な人を選ぶべきでしょう。	7
	3	またそれと同じくらい重要なのは、人間関係を円滑にできる人、また人にものを教えるのが得意な人を選ぶことです。	7
	3	問題領域についての経験が浅い人は、その領域についての経験が豊富な人を選ぶべきです。	7
	3		7
	3	誰がいいのか確信が持てない、という時は、まずはとにかく同僚のうちの誰かと組んで試してみるといいでしょう。	7
	3	そして、重要な問題、難しい問題の解決に共に取り組み、うまくいくか様子を見ます。	7
	3	何度か相手を変えて試してみてください。	7
	3		7
	3		7
	3	エラーがエラーを相殺してしまう	5
	3	Allan Kelly	6
	3	コードは嘘をつきません。	7
	3	プログラムは必ず人間が書いたとおりに動きます。	7
	3	ただ、ある箇所で書いたことと、別の箇所で書いたことが矛盾していた場合、思いがけない動きをすることがあり得ます。	7
	3		7
	3	アポロ11号の月着陸船のソフトウェア設計を指揮したAllan Klumppは、あるインタビューで、エンジンを制御するソフトウェアにバグがあったことを明かしています。	7
	3	そのバグのせいで、着陸船の動きが不安定になる恐れがあったというのです。	7
	3	しかし、結果的にそのバグは別のバグによって相殺されたため、発見も修正もされず、アポロ11号、12号の月着陸は無事成功しました。	7
	3		7
	3	表面上起きている問題は1つなのに、それに関わっているコードが2箇所ある場合、一つ一つ不具合を修正していくという方法で対処していくと問題が解決しない恐れがあります。	7
	3	バグの報告を受けると、プログラマは原因となる箇所を見つけ出して修復し、テストをします。	7
	3	バグの原因となっていたコードが元々2箇所だったとしたら、それでは問題は解決しないでしょう。	7
	3	2つ目の不具合は修正されていないからです。	7
	3	その場合は、最初の修正はいったん元に戻し、またコードを調べて別の不具合を探すことになるでしょう。	7
	3	それで2つ目の不具合を見つけ出し、修正をしたとします。	7
	3	しかし、1つ目の不具合の修正は元に戻っていますから、やはり問題は解決しません。	7
	3	問題が解決しなければ、修正は元に戻されることになります。	7
	3	これが何度か繰り返されることも多いですが、やがて人によっては、どちらの不具合も問題には関係ないとみなし、第3の不具合を探し始めることもあります。	7
	3	しかし、それが見つかることは決してないのです。	7
	3		7
	3	表面上1つに見える問題が、実は2つのコードの相互作用で生じている、という場合は、このように原因となる箇所の特定が難しく、袋小路に入ってしまうことが珍しくないのです。	7
	3	実は早い段階で原因となる箇所を見つけてはいるのですが、2つが同時に関与しているとはなかなか気づきません。	7
	3		7
	3	こういうことが起きるのはコードだけではありません。	7
	3	要件文書に誤りがあることもあるからです。	7
	3	この誤りはウイルスのようにあちこちの部分に広がる恐れもあります。	7
	3	コードのエラーが、要件文書のエラーを相殺し、表面上は問題が無いように見えてしまうのです。	7
	3		7
	3	問題は人間にも広がります。	7
	3	ユーザは「このアプリケーションが「左」だと言えば、それは「右」という意味だ」と学習すると、自分の行動をそれに合わせて調整することがあるからです。	7
	3	新規のユーザが加わった時には、「このアプリケーションが「左ボタンをクリックしろ」と指示したら本当は「右ボタンをクリックしろ」という意味なので注意するように」と伝えたりもします。	7
	3	そのバグが後で突然修正されてしまったら、ユーザは慣れるまでしばらく混乱し、誤操作を繰り返すことになります。	7
	3		7
	3	原因となる箇所が1つなら見つけて修正するのは簡単です。	7
	3	しかし問題に複数の原因がある場合は、複数の修正が必要になり対処が難しくなります。	7
	3	また、修正が容易な不具合は、比較的早い段階で修正されるのですが、修正が難しい不具合の修正は、どうしても後に固されるということもあります。	7
	3		7
	3	複数の原因がある問題にどう対処すべきか、「こうすれば大丈夫」というような簡単な解決策はありません。	7
	3	まず大切なのは、そういう問題が存在し得ると認識することでしょう。	7
	3	そして、思い込みを捨ててあらゆる対処を思いつくよう、冷静さを保つことが重要です。	7
	3		7
	3		7
	3	他者への思いやりを意識したコーディング	5
	3	Aslam Khan	6
	3	プログラマは1人で作業することが多いので、どうしても、問題を自分1人だけで解釈し、その解釈だけを頼りにコードを書いてしまいがちです。	7
	3	多くの場合、プログラマはどこかのチームに属してはいますが、結局は一人一人が孤立してコードを書くことになります。	7
	3	孤立して作業をしていると、このコードはいずれ他人によって使用され、実行されるのだということを、つい忘れがちになります。	7
	3	他人がコードを拡張することもあれば、自分の書いたコードに依存して誰かがコードを書くこともあるということを忘れてしまうのです。	7
	3	ソフトウェア開発の「社会的側面」は見過ごされやすいのです。	7
	3	ソフトウェアを作るには技術も必要ですが、他人との関わりも重要です。	7
	3	ずっと下を向いて作業をしているのではなく、時には顔を上げて、自分は1人で働いているのではないのだ、ということを思い出すようにすべきでしょう。	7
	3	プログラマには、開発チームだけでなく、ソフトウェアに関わるすべての人の成功に寄与する責任がありますが、その責任は他の全関係者と共有しているのです。	7
	3		7
	3	孤立していても、自分の世界に没入していても、質の良いコードを書くことは確かにできます。	7
	3	仕事が一種の自己追求になっている人もいるでしょう(これはもちろん「自分勝手」「わがまま」というのとは違います。	7
	3	ただ、関心が外ではなく内に向いているということです)。	7
	3	コードを書く間は、完全に没頭し、「禅の境地」のようになっているのかもしれません。	7
	3	そうなれば、コードの質は間違いなく上がるので、私自身もそういう状態で仕事をしていることはあります。	7
	3	しかし、その仕事の成果が本当に開発チームのためになっているのか、ということは常に意識していなくてはならないでしょう。	7
	3		7
	3	Linuxディストリビューションの”Ubuntu”はよく知られていますが、Ubuntuは元々、ズールー語で「他者への思いやり」というような意味です。	7
	3	そのUbuntuの理念は”Umuntu ngumuntu ngabantu”です。	7
	3	これもズール一語で、翻訳すると「人間は、他の人間がいるお陰で、人間になっている」というような意味です。	7
	3	自分が良い方向に進めるとすれば、それは誰か他の人が良い行動を取り、そうなるようにしてくれるからです。	7
	3	反面、自分が何か悪い行動を取った時には、その行動によって誰か他の人が悪い方向に進む恐れがあります。	7
	3	話をプログラマだけに絞ったとすれば、「プログラマは、他のプログラマがいるお陰でプログラマになっている」と言うことができるでしょう。	7
	3	さらに話をコードに絞れば「コードは、他のコードがあるお陰でコードになっている」とも言えます。	7
	3		7
	3	誰かが書いたコードの質は、必ず他の誰かが書くコードの質に影響します。	7
	3	もし私が質の低いコードを書いてしまったとしたらどうでしょうか。	7
	3	その場合は、誰か他の人が非常に質の高いコードを書いていたとしても、私のコードを利用した途端に悪影響を受け、同じレベルにまで質が低下してしまいます。	7
	3	その悪影響を減らすためのテクニックは多数ありますが、悪影響がなくなることはありません。	7
	3	いずれにしろ、他の人に本来する必要のないことをさせてしまうのです。	7
	3	自分の世界に没入して他人のことを一切考えなければ、そういう事態に陥りやすいでしょう。	7
	3		7
	3	自分のコードはすでに質が高いと思っていても、他のプログラマの存在を意識すれば、より良くする方法が見つかる可能性があります。	7
	3	他人の存在を意識したコードとはどういうものでしょうか。	7
	3	多分それは、一見しただけでは、単なる良いコード、クリーンなコードと区別がつきません。	7
	3	しかし大事なのは、コードそのものの質ではなく、他への影響です。	7
	3	他人の存在を意識すれば、他人の書くコードにも当然良い影響を与えることになります。	7
	3	チームの同僚のことを考え、思いやりを持ってコードを書けば、それは同僚たちにとって価値あるコードとなり、いずれ自分にも良い影響となって返ってきます。	7
	3	どんなかたちであれ、そのコードに触れた誰もが、触れる前より良い人間、良いプログラマになれる、そういうコードを書くようにすべきでしょう。	7
	3		7
	3	禅は元来、個人的なものですが、Ubuntuの理念は、集団のための禅と言えるかもしれません。	7
	3	ともかく、プログラマが他の人への思いやりを持たずにコードを書くことはあり得ない、ということを常に忘れてはならないのです。	7
	3		7
	3		7
	3	UNIXツールを友にする	5
	3	Diomidis Spinellis	6
	3	もし無人島にIDEかUNIXツールのどちらかしか持って行けないとしたら、私は迷うことなくUNIXツールを選びます。	7
	3	なぜそうなのか、ここではその理由を説明することにしましょう。	7
	3		7
	3	まず、IDEはどれも、特定の言語をターゲットとしています。	7
	3	一方UNIXツールなら、テキスト形式になっているものは何でも扱えます。	7
	3	今日の開発環境には毎年のように新しい言語や表記法が追加されるので、UNIXツールの使い方を学ぶのに時間を投資してもすぐに回収できるでしょう。	7
	3	UNIXツールが使えれば、新しいIDEを導入することなく新しい言語や表記法に対応できるからです。	7
	3		7
	3	また、IDEの場合は、そのIDEを開発した人の考えたコマンド以外は使えませんが、UNIXツールなら、自分の発想次第で何でもできます。	7
	3	UNIXツールを、レゴブロック(今の子供たちにはバイオニクルの方が有名かもしれません)のようなもの、と考えることもできます。	7
	3	シンプルな部品の組み合わせによってどんなコマンドでも自分で作り出せる万能のツールです。	7
	3	たとえば、Ward Cunninghamのシグネチャ調査をテキストベースで実装すると次のようになります。	7
	3	これにより、個々のファイル中のセミコロンや、中括弧、引用符などの並び方を見て、そのファイルの内容について知ることができます。	7
	3		7
	3	IDEの場合、特定の作業をするための方法はあらかじめ決まっていて、他の方法を使うことはできません。	7
	3	たとえば、デバッグビルドの設定にステップを新たに追加する方法は、あらかじめ決まっています。	7
	3	それに対しUNIXツールの場合は、自分の工夫次第で同じ作業をより効率的に行うことが可能です。	7
	3	たとえばUNIXツールで今の例と同じ作業をする場合には、私はsedを利用して、ビルドをマルチプロセッサアーキテクチャでのクロスコンパイルに対応させています。	7
	3		7
	3	元々UNIXツールは、マルチユーザのコンピュータのRAMが128KBしかない時代に開発されたものです。	7
	3	少ないRAMを効率的に利用するために工夫が凝らされているので、それを現在のような大容量RAMのコンピュータで使えば、素晴らしく効率的な処理が可能でしょう。	7
	3	ほとんどのUNIXツールは、フィルタのように1度に1行だけを処理します。	7
	3	これは、UNIXツールが扱えるデータの量に、事実上「上限がない」ことを意味します。	7
	3	たとえば、データ量500MBほどある英語版Wikipediaのダンプの中を解析して、編集が何回なされたかを調べたい時は、以下のコマンドを実行します。	7
	3		7
	3	これであっという間に答えがでます。	7
	3	何度も同じコマンドの組み合わせを使うようならば、それをシェルスクリプトにまとめることも簡単にできます。	7
	3	シェルスクリプトなら、パイプを使ってコマンドの処理結果をループや条件文に渡すこともでき、非常に便利です。	7
	3	さらに素敵なことに、UNIXコマンドはパイプライン処理として動作するので、現在のマルチコアCPUの場合は、複数のコアに負荷が自然に分散されます。	7
	3		7
	3	「スモール・イズ・ビューティフル」の発想で設計され、オープンソースで書かれたUNIXツールは、今やいたるところで利用されています。	7
	3	たとえばセットトップボックスやDSLルータといったリソースの限られたプラットフォームでも使われています。	7
	3	その種のデバイスでパワフルなGUIが提供されることはまずなく、多くの場合、BusyBoxアプリケーション十が使われています。	7
	3	BusyBoxは、UNIXツールの中でも特に利用頻度の高いもので構成されたアプリケーションです。	7
	3	Windowsで開発をしている場合も、Cygwin環境を導入すれば、UNIXツールと聞いて思いつくようなものが利用できます。	7
	3	Cygwin環境では、UNIXツールが実行ファイルとソースコードの両方の形態で提供されています。	7
	3		7
	3	既存のツールがどれも自分の希望に合わないという場合も、UNIXツールなら簡単に拡張ができます。	7
	3	いくつか簡単なルールを守ってプログラムを書けばいいのです(言語はどれでもかまいません)。	7
	3	そのルールとは、シングルタスクのプログラムにすること、標準入力からテキスト行としてデータを読み込むこと、実行結果は標準出力に書き込み、その際 ヘッダなどの余計な飾りはっけないこと、です。	7
	3	ツールの動作に影響するパラメータはすべてコマンドラインに指定するようにしましょう。	7
	3	これらのルールを守れば、「この世界とそこにあるものはすべて君のもの」、必要十分な機能を持ち、応用範囲の広いツールができるでしょう。	7
	3		7
	3		7
	3	正しいアルゴリズムとデータ構造を選ぶ	5
	3	Jan Christiaan "JC" van Winkel	6
	3	多数の支店を持つ大銀行が窓口業務のために新しいコンピュータを導入しました。	7
	3	しかし、その処理はあまりに遅く、日々不満が募っていました。	7
	3	まだオンラインバンクなどはない頃で、ATMも現在のように広く使われるようになる前の話です。	7
	3	銀行を直接訪れて手続きをする人が今よりはるかに多く、コンピュータが遅いとたちまち長蛇の列ができてしまいました。	7
	3	いら立った銀行はついには、「このままだと契約を破棄する」とコンピュータのベンダを脅し始めました。	7
	3		7
	3	ベンダは、遅延の原因を突き止めるべく、パフォーマンス解析とチューニングのスペシャリストを銀行に送り込みました。	7
	3	それでわかったのは、端末上で動くあるプログラムが、1つでCPUキャパシティのほとんどすべてを消費していたということです。	7
	3	プロファイリングツールを使い、そのプログラムについて詳しく調べた結果、問題を引き起こしている関数が特定できました。	7
	3	関数のソースコードは次のようになっていました。	7
	3		7
	3	上の例の場合は、必要もないのに、一度に扱うデータが極端に大きくなってしまうところが問題だったわけですが、ではどうすればこういう問題の発生は防げたのでしょうか。	7
	3		7
	3	「まずは動かすこと。	7
	3	速くするのはその後でいい」という格言を知っている人は多いでしょう。	7
	3	局所的な最適化の落とし穴を避けるためには、この格言の心に留めておくことが大切です。	7
	3	しかし、先の例のようなコードを見ると、「遅くても何でもいいからとにかく動かせ」というマキアベリ的な発想でコードを書いているのではないか、と疑ってしまいます。	7
	3		7
	3	この種の「何も考えていないようなコード」は実はかなり多く見つかります。	7
	3	「車輪の再発明をするな」とよく言われますが、ここで言いたいのは、単にそういうことではありません。	7
	3	経験の浅いプログラマには、深く考えることなく、とにかく次々にコードを書いてしまう傾向があります。	7
	3	そして、その間にバブルソートなどのアルゴリズムを「発明」してしまうことがあるのです。	7
	3	それで自分が良いコードを書いたと信じ込みます。	7
	3		7
	3	適切なアルゴリズムを選ぶことは大切ですが、それには、適切なデータ構造を選ぶということも含まれます。	7
	3	データ構造の違いはプログラムの処理に大きな影響を与える可能性があるからです。	7
	3	たとえば、検索すべき項目の数が百万にもなる時には、リンクリストを使うか、ハッシュを使うか、それともバイナリツリーを使うかで、プログラムに対するユーザの評価はまったく変わることになるでしょう。	7
	3		7
	3	プログラマは一般に、車輪の再発明をすべきでなく、可能であれば既存のライブラリを利用すべきと言われます。	7
	3	しかし、上の銀行のような問題が起きないようにするには、それだけではなく、既存のアルゴリズムについて、そのスケール特性について、学ぶ必要があります。	7
	3	一見魅力的だけれど、うかつに使うと最新のテキストエディタでも1980年のWordStarのような昔のプログラム並みに遅くなってしまうような機能もあるのです。	7
	3	プログラミングにおける「再利用」を重視する人は多いですが、いつ、何を、どのように再利用すべきかがわからなければ、良い結果にはなりません。	7
	3	それをわかるためには、問題領域について、またアルゴリズムとデータ構造について、十分な知識が必要なのです。	7
	3		7
	3	一般には「良くない」とされているアルゴリズムもありますが、優れたプログラマであれば、そういうアルゴリズムでさえも状況によっては良い結果を生むと知っています。	7
	3	たとえば、問題領域の性質上、扱う項目の数が絶対に5を超えることはないとあらかじめわかっていれば、項目のソートに際しても、5より大きい項目数を考える必要はありません(例:「ヤッツィー: Yahtzee」というゲームでは、サイコロの数が5つと決まっている)。	7
	3	その場合には、バブルソートが最も効率的なソートアルゴリズムということになるかもしれません。	7
	3	どんな道具にもそれに合った使い道というのはあるのです。	7
	3		7
	3	アルゴリズムやデータ構造に関しては良い本が何冊かあるので、是非とも読んで、内容を完全に理解しましょう。	7
	3	読むべき本の例としては、Donald Knuthの「The Art of Computer Programming」(有澤誠 他訳、アスキー)などがあげられます。	7
	3	この本は素敵なことに、よく読んで、もし運良く著者の誤りを発見して報告すれば、2ドル56セントの小切手が受け取れます(256セントは、16進数なら100セント、つまり1ドルだから、ということで2ドル56セントになったようです)。	7
	3		7
	3		7
	3	冗長なログは眠りを妨げる	5
	3	Johannes Brodwall	6
	3	開発中のシステム、あるいは製品としてすでに稼働中のシステムがあるとします。	7
	3	そのシステムに、すぐに目につく問題があるとすれば、それはまず「ログが汚い」ということではないでしょうか。	7
	3	思い当たることがある人も多いでしょう。	7
	3	たとえば、あるWebページをごく普通に見ていて、リンクを1つクリックしただけなのに、システムの提供する唯一のログに大量のメッセージが記録されている、というようなことがあるのです。	7
	3	ログの情報があまりに大量だと、ログが無いのと同じくらい役に立ちません。	7
	3		7
	3	私たちプログラマが開発するシステムは、開発が終われば、その後は誰か別の人が使うことになります。	7
	3	プログラマとしては、開発したシステムはできるだけ長く残って欲しい、長く使われ、その間ずっとユーザの役に立つ存在であって欲しいと望むのが普通でしょう。	7
	3	しかし、システムが製品として稼働し始めてから問題が起きることもあり得ます。	7
	3	それを私たちはどのようにして察知すればいいのでしょうか。	7
	3	また、その問題にどう対処すればいいのでしょうか。	7
	3		7
	3	誰かがシステム監視をするかもしれません。	7
	3	開発に携わったプログラマが自らシステム監視をすることもあるでしょう。	7
	3	いずれにせよ、監視をするとすれば、その中でログが必ず一定の役割を果たすことになります。	7
	3	ログに何か不穏なメッセージが記録されていれば、場合によってはたとえ寝ていてもすぐに起きて対応しなくてはならないでしょう。	7
	3	調べてみれば深刻な問題ではないかもしれませんが、どんなものかまだ分からないうちは対処せざるを得ません。	7
	3	もちろん、システムに本当に重大な問題が発生していて、今にも止まりそうだというのなら、それが察知できないのでは困るでしょう。	7
	3	しかし、本当はさほど大きな問題でもないのに、寝ているところを起こされるのではたまりません。	7
	3		7
	3	システムに何か問題がある場合、ログに残ったメッセージで最初に知ることになります。	7
	3	多くの場合、そのログはエラーログです。	7
	3	あらかじめ、そう認識しておくことは大事です。	7
	3	開発の初日、あるいは稼働の初日から、エラーログに何かが記録されたら確認すべきです。	7
	3	自分が現場にいない時にエラーログに何かが記録されていることがわかったら、たとえそれが真夜中で自分が寝ていたとしても、即時に知らせてもらうようにしても良いでしょう。	7
	3	実際の稼働時の負荷をシミュレートしたシステムテストが実施でき、その際、エラーログに問題を示すようなメッセージが何もなければ、システムの堅牢さがまずは一定以上には達しているとみなせるでしょう。	7
	3	もしそうでなければ、警戒して早めに対策をする必要があります。	7
	3		7
	3	分散システムの場合は事情がより複雑になります。	7
	3	外部との依存関係に問題が生じる可能性がどのくらいあるかを見極めなくてはならないからです。	7
	3	分散化の度合いが高い場合には、依存関係に問題が起きる頻度も高くなるでしょう。	7
	3	ロギングポリシーもそれを考慮したものにする必要があります。	7
	3		7
	3	一般に、全てが上手くいっているときには、優先度の低いメッセージがログに定期的に出ていることでしょう。	7
	3	参考程度に見た方が良いINFOレベルのメッセージなら、重要なアプリケーションイベント1つにつき1つ出れば十分です。	7
	3		7
	3	ログに、不要なものも含め、あまりに多くの情報が記録されると、システムの監視には役立たなくなってしまいます。	7
	3	本当に重大な問題が起きた場合以外、基本的にエラーログには何も記録されない、というくらいの方が良いと言えます。	7
	3	その場合は、エラーログにメッセージがあるというだけで、システムに重大な問題が発生しているとすぐ判断できるからです。	7
	3		7
	3		7
	3	WETなシステムはボトルネックが見つかりにくい	5
	3	Kirk Pepperdine	6
	3	DRY(Don’t Repeat Yourself :同じことを繰り返すな)原則は、非常に重要なものです。	7
	3	これは、1つのシステムの中で同じものが重複することがあってはならないという原則です。	7
	3	言い換えれば、1つの知識に対応する実装は必ず1つにする、ということです。	7
	3	DRY原則に反しているシステムを、「WET(Write Every Time :必要なものをその都度書く)なシステム」と呼ぶことがあります。	7
	3	WETなシステムには、同じ知識に対応する実装が複数存在します。	7
	3	DRYなシステムとWETなシステムでは、パフォーマンスに違いが生じます。	7
	3	そのことは、DRYであること、WETであることが具体的にどういう側面にどう影響するかを知れば、明確にわかるでしょう。	7
	3		7
	3	たとえば、あるシステムに、CPUボトルネックになっている機能があるとします。	7
	3	その機能を仮に、「機能X」と呼ぶことにします。	7
	3	そして、機能XがCPUの30%を消費しているとしましょう。	7
	3	もし機能Xに10種類の実装があるとしたら、個々の実装は、平均してCPUの3%を消費しているということになります。	7
	3	この場合は、じっくり見なければ、機能Xがボトルネックになっていることに気づきにくいでしょう。	7
	3	3%のCPU消費自体は多くないからです。	7
	3	また、仮に機能Xがボトルネックであると認識できたとしても、10種類の実装をすべて見つけ、個々に修正を施さなくてはならないという問題があります。	7
	3	1つの機能の実装が10個存在するのは、WETなシステムであると言えます。	7
	3	もしDRY原則に従ってシステムが作られていれば、機能XがCPUを30%消費している事実にすぐに発見できる上、修正するコードも1/10で済むでしょう。	7
	3	そもそも、10の実装をすべて見つけ出すための時間も手間も必要ありません。	7
	3		7
	3	DRY原則が破られやすい状況もあります。	7
	3	たとえば、コレクションを使う場合がそうです。	7
	3	コレクションの要素に順にアクセスするというクエリを実装する際には、同じクエリを個々の要素に対して順に実行する、というコードを書いてしまいがちなのです。	7
	3		7
	3		7
	3	プログラマとテスターが協力してできること	5
	3	Janet Gregory	6
	3	テスターとプログラマが協力し合えば、奇跡が起こせます。	7
	3	両者の協調が進むと、まず、問題管理システムを使ってバグ情報をやりとりする時間が減らせるでしょう。	7
	3	そして、「バグなのか、それとも新機能なのか」を見極めるための時間も減らせます。	7
	3	その分の時間を、ソフトウェアの機能をより充実させること、顧客の要望に応えることに使えるのです。	7
	3	両者の協調の機会は数多くあります。	7
	3	実は、コーディングの開始前から協力し合うことも可能なのです。	7
	3		7
	3	たとえばテスターは、顧客と協力し、FIT(Framework for Integrated Test)などのツールを使用して顧客のドメインの言葉で受け入れテストを書き、それを自動化することができます。	7
	3	受け入れテストをコーディング開始前に渡されれば、プログラマは、ATDD(Acceptance Test-Driven Development :受け入れテスト駆動開発)を実践できます。	7
	3	プログラマはテストの実行のために必要になる部品を作り、テストに合格するようにコードを書きます。	7
	3	このテストは「回帰スイート」の一部となります。	7
	3	テスターとプログラマがこういうかたちで協力すれば、機能テストは早いうちに完了するので、空いた時間を探索的テスト(exploratory testing)にあてることができます。	7
	3	境界条件のテストや、全体的な流れのテストができるのです。	7
	3		7
	3	さらに一歩進めることもできます。	7
	3	プログラマがコーディングを始める前に、テスターは「どういうテストをするつもりか」という考えを伝えるだけでなく、同時に、プログラマに何か提案はないかと尋ねるのです。	7
	3	そうすれば、プログラマからは、テストカバレッジをあげるのに役立つ情報、あるいは、どれが必要なテストでどれが不要なテストかの見極めに役立つ情報が提供されることが多いのです。	7
	3	テストについて早い段階から知っていれば、プログラマは、これから書こうとするコードがどういうものなのかをかなり明確にしてからコーディングを始めることができます。	7
	3	それによってバグの発生は大幅に減らせるでしょう。	7
	3	たとえば私が関わったあるプロジェクトでは、私がFITを使って書いてプログラマに提供したテストにより、ワイルドカード検索の際、クエリに具体的にどういう実行結果が求められるかが明らかになりました。	7
	3	プログラマは当初、入力された文字列を補完して検索する機能だけをイメージしていたのですが、どうもそれだけではないとわかったのです。	7
	3	その後、顧客と十分に話し合い、正しい解釈を基にコーディングを始めることができました。	7
	3	テスターとプログラマが協力し合えば、こうしてバグの発生を未然に防ぐことができ、時間も節約できるのです。	7
	3		7
	3	プログラマとテスターは自動化に関しても協力し合うことができます。	7
	3	当然のことながら、プログラマは優れたコーディングプラクティスがどういうものかを理解しています。	7
	3	テスターはプログラマの助けを借りれば、チーム全体で利用できる堅牢なテスト自動化スイートを作ることもできるでしょう。	7
	3	私の知る限り、テストの設計が悪いせいで、自動化プロジェクトが失敗するということが少なくないようです。	7
	3	設計が悪いテストとは、不要なテスト項目が多すぎるものや、テスト項目の独立性が低いものなどを指します。	7
	3	テスターに技術的な知識がないと、独立性の低いテスト項目ができてしまうことがよくあります。	7
	3	自動化などの作業においては、テスターがボトルネックになることが多いので、是非プログラマと協力して効率化をはかるべきでしょう。	7
	3	協力すれば、プログラマも、テストについて早いうちに知ることができます。	7
	3	協力と言っても、簡単なツールを提供するくらいで済むこともありますが、その際に得られるフィードバックは、長い目で見ればコードの質を高めるのに役立ちます。	7
	3		7
	3	テスターは、ソフトウェアを破壊し、プログラマの書いたコードからバグを見つけ出すことだけが自分の仕事である、という考え方をやめるべきです。	7
	3	そしてプログラマは、テスターのことを「自分たちの邪魔をする敵」となどと考えるべきではありません。	7
	3	そういう考えをやめれば、協調できる可能性が高まります。	7
	3	プログラマが、品質向上も自分の仕事の一部であると考え、テストしやすいコードを書くことも当然の責務であると考えるようになれば、回帰テストの自動化をテスターと共同で進めることなども簡単にできるようになるでしょう。	7
	3	プログラマとテスターのチームワークで、プロジェクトはまるで奇跡のようにうまくいくはずです。	7
	3		7
	3		7
	3	コードは生涯サポートするつもりで書く	5
	3	Yurly Zubarev	6
	3	「すべてのプログラマが必ず知っておくべきこと、また、必ずすべきことは何ですか」と97人に尋ねたとしたら、きっと97通りの答えが返ってくるでしょう。	7
	3	97通りの答えを聞いて圧倒されてしまう人、威圧されてしまう人もいるはずです。	7
	3	どのアドバイスも素晴らしいはずです。	7
	3	守るべきと言われる原則は、どれも確かに守るべきと思えますし、紹介されるコツはどれも参考になります。	7
	3	どの話にも説得力があり、なるほど正しいと思えます。	7
	3	ただ、どれも良いとなると、まず何を自分に取り入れるべきか迷ってしまいます。	7
	3	一体何から始めればいいのでしょうか。	7
	3	さらに大事なことは、いわゆる「ベストプラクティス」を学び、ずっと守り続けることです。	7
	3	「ベストプラクティス」が完全に自分のものになり、守るのが当たり前になればしめたものですが、どうすればそうなるのでしょうか。	7
	3		7
	3	結局は気持ちの持ち方、さらに言えば、取り組む態度の問題ということになってしまうのだと思います。	7
	3	たとえば、同僚のプログラマやテスター、マネージャ、営業やマーケティングのスタッフ、エンドユーザといった人たちのことが念頭になければ、なかなかテスト駆動開発を採用しようとは思わないでしょうし、明解なコメントを書こうと心がけることもないでしょう気持ちの持ち方、取り組む態度を変えるには、実はちょっとしたコツがあります。	7
	3	それは、。	7
	3	いつも「このコードは生涯、自分がサポートし続けなくてはならない」と思ってコードを書く。	7
	3		7
	3	ということです。	7
	3	それだけで、「良い製品を作らねば」という気になります。	7
	3	「生涯サポートしなくてはならない」と考えながら仕事をするようになれば、素晴らしいことが起きるでしょう。	7
	3	もし、これまでに書いたコードを本当にすべて生涯サポートしなくてはならないのだとしたら、たとえば、ずっと以前に書いたfooBarメソッドについて、いつ問い合わせを受けるかわからない、となったらどうでしょうか。	7
	3	以前に勤めていた会社、あるいは今勤めている会社から真夜中に電話がかかってきて、「どういう理由でこういうコードを書いたのか説明してくれ」と言われでも文句は言えないとしたら。	7
	3	そう考えれば、自然に、そんな問い合わせを受けないで済むようにしたい、と思うでしょう。	7
	3	そのために、技術力を少しずつでも高めようとし、変数名やメソッド名のつけ方にも注意するようになります。	7
	3	1ブロックが何百行にも及ぶコードを書いて放置する、ということもなくなるでしょう。	7
	3	デザインパターンについて学び、常により良いデザインパターンを探し、それを使うようになります。	7
	3	コメントもまめに書くようになり、テストも逐一実施するようになります。	7
	3	リファクタリングも頻繁に行うようになるでしょう。	7
	3	自分の書いたすべてのコードを生涯サポートするというのは、サポートするコードが時間が経つほど増えていくということを意味します。	7
	3	つまり、知識と知力、そして技術力を磨き、仕事の効率も上げていかないと対応しきれなくなってしまうことは明らかです。	7
	3		7
	3	これまでに書いてきたコードは、どれほど前のものであっても、好むと好まぎるとにかかわらず、必ず今の自分の仕事に影響を与えているのです。	7
	3	そのことは少し考えてみればわかるでしょう。	7
	3	コードを書くというのは、自分の知識や技術、取り組む姿勢、つまりプロ意識や責任感がどれほどのものか、それを他人がうかがい知るための手がかりを残すということです。	7
	3	コードを見れば、メソッドやクラス、モジュールの設計、コーディングを、担当した人がどのくらい楽しんでいたかもわかります。	7
	3	皆、書かれたコードを見て、書いた人がどういう人か評価するのです。	7
	3	その評価が常に良くないものであれば、誰もその人に重要な仕事を任せようとは思いません。	7
	3	つまり、良くないコードを書いていれば、キャリアアップのチャンスも減ってしまうということです。	7
	3	コードを1行書く度に、ユーザのこと、顧客のこと、そして自分のキャリアのことを考えるべきです。	7
	3	このコードは自分の今後の人生を決めるのだ、と思って書くべきでしょう。	7
	3		7
	3		7
	3	関数の「サイズ」を小さくする	5
	3	Keith Braithwaite	6
	3	正しいコードを書きたいというのは誰もが思うことです。	7
	3	そして自分の書いたコードが間違いなく正しいという証拠も欲しいでしょう。	7
	3	そういう意味で、役立つのは、関数の「サイズ」という指標です。	7
	3	この「サイズ」は、関数を実装しているコードの量という意味ではありません(もちろん、それも重要なのですが)。	7
	3	そのコードが表現している数学関数のサイズという意味です。	7
	3		7
	3	たとえば、囲碁のプログラムを書くとします。	7
	3	囲碁には「アタリ」と呼ばれる用語があります。	7
	3	これは、「相手に石を固まれ、取られる一歩手前の状態」のことです。	7
	3	石の周りにまだ2箇所以上の隙間が空いている場合には「アタリ」とは言いません。	7
	3	あくまで、あと1個だけ石を置けば完全に固まれてしまう状態をアタリと言うのです。	7
	3	あといくつ隙間が残っているかを数えるのは、ルールを覚える必要があるので少し難しいですが、それさえ数えられれば、アタリかどうかの判定は簡単です。	7
	3	アタリかどうかの判定のために次のような関数を書いたとしましょう。	7
	3		7
	3	こういう場合は、いくらテストをしたとしても、確かにバグがないという証明はできません。	7
	3	テストは、持つべき機能を持っていることを確かめるのに役立つだけです。	7
	3	サイズが大きいことは、そういう点で問題だと言えます。	7
	3		7
	3	これだとはるかに扱いやすくなります。	7
	3	数学関数は、最大で8つの要素を持つだけの集合になりました。	7
	3	4つの例について調べるだけで、関数が完全に正しいという証拠が得られます。	7
	3	組み込み型の代わりに、問題領域固有の型を使うのは、こういう意味でも良いことだと言えるでしょう。	7
	3	問題領域固有の型を使うと、関数のサイズを大幅に小さくすることができます。	7
	3	どういう型を使うのがいいかは、関数を書く前に、問題領域についての知識を基に考えるべきでしょう。	7
	3	確認すべき例の数をどこまで減らせるかを考えるのです。	7
	3		7
	3		7
	3	コードを見る人のためにテストを書く	5
	3	Gerard Meszaros	6
	3	読者の中に「製品版コード一つ一つについて、必ず自動化テストを書くようにしている」という人はどのくらいいますか?もしそうしているのなら、素晴らしいことだと思います。	7
	3	「テストは、いつもコードを書き始める前に書くようにしている」という人がいれば、さらに素晴らしいです。	7
	3	どちらも、ソフトウェアエンジニアリングの最先端のプラクティスをいち早く取り入れている、と言えるでしょう。	7
	3	ただ、テストを書くのはいいとして、そのテストは果たして「良いテスト」と言えるでしょうか。	7
	3	良いテストが書けているかを、どうやって見極めればいいのでしょうか。	7
	3	そのために「自分は誰のためにテストを書いているのか」と自らに問うてみるのは1つの方法でしょう。	7
	3	もしその答えが「自分のため。	7
	3	バグ修正の労力を少しでも減らすため」あるいは「コンパイラのため。	7
	3	コンパイル作業を円滑に進めるため」だったとしたら、良いテストが書けている可能性は低いと言えるでしょう。	7
	3	では一体誰のためにテストを書けばいいというのでしょうか。	7
	3	それは、「コードを見る人のため」です。	7
	3		7
	3	良いテストはドキュメントのようなはたらきをします。	7
	3	テスト対象となるコードについて知るのに役立つのです。	7
	3	「このコードはどう動くのか」を教えてくれるのが良いテストです。	7
	3	良いテストの条件を簡単にまとめると次のようになるでしょう。	7
	3		7
	3	以上の3つは利用シナリオごとに少しずつ違ってきますが、それが逐一わかるのが良いテストでしょう。	7
	3	コードについて知りたいと，思った人がテストを見た時、上の3つの点についてわかればいいわけです。	7
	3	それによって、ソフトウェアの動きを変化させるために何を変えればいいかもわかるでしょう。	7
	3	テストを見ることで、上の3つの間の因果関係も明確にわかるのが望ましいと言えます。	7
	3		7
	3	テストに関しては、何を見せるかだけでなく、「何を見せないか」も重要になります。	7
	3	たとえば、テストのコードが多すぎれば、読む人は些細なことにばかり囚われて肝心なことが理解できなくなる恐れがあります。	7
	3	できる限り、メソッドコールなどの重要な部分以外以上の3つは利用シナリオごとに少しずつ違ってきますが、それが逐一わかるのが良いテストでしょう。	7
	3	コードについて知りたいと，思った人がテストを見た時、上の3つの点についてわかればいいわけです。	7
	3	それによって、ソフトウェアの動きを変化させるために何を変えればいいかもわかるでしょう。	7
	3	テストを見ることで、上の3つの間の因果関係も明確にわかるのが望ましいと言えます。	7
	3		7
	3	テストのテストをするのも良いことです。	7
	3	製品版コード(ただし本物ではなくコピー。	7
	3	テストが終わったら破棄する)にあえてエラーを混入させ、期待どおりにそのエラーが検知されるかを確認するのです。	7
	3	単にエラーの発生が報告されるだけでなく、どういうエラーが起きていてどう対処すればいいかがわかる報告になっていることも確認しましょう。	7
	3	テストが、コードを理解する上で本当に役立つものになっているかも確認しておくべきでしょう。	7
	3	それを確認するには、コードについてよく知らない人にテストを読んでもらうしかありません。	7
	3	読んでもらった上で何がわかったかを話してもらうのです。	7
	3	その時に話されることをじっくりと聞くことが大事です。	7
	3	よく話を聞いて、もし何か「これはよくわかっていないな」と感じたことがあったとすれば、それはおそらく、その人に知性が欠けているせいではありません。	7
	3	テストが十分にわかりやすいものになっていないということです(その後、役割を交代し、テストを読んでくれた人の書いたテストをこちらが読んでみても面白いでしょう)。	7
	3		7
	3		7
	3	良いプログラマになるには	5
	3	Pete Goodlife	6
	3	良いプログラマは良いコードを書き、良くないプログラマは…そうでないコードを書く、そんなことは何もシャーロック・ホームズでなくてもわかることでしょう。	7
	3	良くないプログラマの書くコードはまるで怪物のようです。	7
	3	周囲の人間は、その修正のためにあとで大変な苦労をさせられます。	7
	3	読者はみな当然、良いコードを書きたい、良いプログラマでありたい、と望んでいるでしょう。	7
	3		7
	3	良いコードは何の根拠もなく勝手に生まれたりはしません。	7
	3	今週はたまたま星回りが良いから良いコードができた、などということはないのです。	7
	3	コードを良くするには、そうすべく相当な努力をしなくてはなりません。	7
	3	良いコードを書きたいと心の底から願い、努力をした人だけが本当に良いコードを書けるのです。	7
	3		7
	3	ただ技術が優れているというだけでは良いコードは書けません。	7
	3	素晴らしいアルゴリズムを考え出せる知性を持ち、プログラミング言語についての知識も十分なプログラマが、実にひどいコードを書くというのは珍しくありません。	7
	3	そういう人が、読むのも使うのも大変、修正するのも大変、というコードを書いてしまうことはあるのです。	7
	3	反対に、能力は平凡でも、シンプルなコードを書こうと細心の注意を払った結果、美しく、わかりやすいコードができあがったという例を私はたくさん見てきました。	7
	3	読むのも使うのも楽しくなるようなコードです。	7
	3		7
	3	ソフトウェア会社で長年働いた経験から、1つわかったことがあります。	7
	3	それは、良いプログラマとそうでないプログラマの違いです。	7
	3	両者の最大の違いは「取り組む姿勢」にあります。	7
	3	良いプログラマの姿勢は、プロフェッショナルという言葉にふさわしいものです。	7
	3	常に、最大限の力を尽くして良いコードを書こうとします。	7
	3	リソースの制約のある中、早く作業を終わらせろと会社が圧力をかけてくる中、それでもできる限り良いコードを書こうと努力をするのです。	7
	3		7
	3	「地獄への道には善意が敷き詰められている」という言葉があります。	7
	3	それと同じように、「地獄行きのコード」に善意が敷き詰められていることもよくあります。	7
	3	良いプログラマになるためには、単なる善意だけでは不十分です。	7
	3	自分が善意でしていることが本当に功を奏しているか、よく確認することが大切なのです。	7
	3	常に事実、現実を直視し、その上で物を考えるような姿勢が必要でしょう。	7
	3	真に優れたコードは、知識も経験もあるプログラマが最大限心を配って書いた時に生まれるものです。	7
	3	深く考えもせず、ぞんざいに書いたコード、自称「達人」が自分勝手な方法で書いた独りよがりなコードが良いものになるわけがありません。	7
	3		7
	3	良いコードが書きたいのなら、良いプログラマになりたいのなら、常に次のことを心がける必要があるでしょう。	7
	3		7
	3	ここに書いてあることに興味を持ち、最後まで読んだ人はおそらく、プログラミングが好きで、良いプログラマになりたいという熱意を持った人でしょう。	7
	3	是非これからもプログラミングを楽しんで欲しいと思います。	7
	3	難しい問題を見事解決できるプログラム、自ら誇りに思えるプログラムを書きましょう。	7
	3		7
	3		7
	3	顧客の言葉はそのまま受け取らない	5
	3	Nate Jackson	6
	3	自分の希望を伝えるのを嫌がる顧客はまずいないでしょう。	7
	3	少なくとも私は会ったことがありません。	7
	3	ほとんどの人は、尋ねれば、詳しく希望を話してくれます。	7
	3	問題は、顧客がいつも本当のことを言うとは限らないということです。	7
	3	嘘をついているというわけではありません。	7
	3	ただ、顧客とプログラマとでは話し方が違うのです。	7
	3	顧客には顧客独自の用語とコンテキストがあります。	7
	3	私たちから見れば、非常に重要と思われることをまったく話さないこともよくあります。	7
	3	たとえば、その人が1つの会社で20年間働いているとします。	7
	3	そういう場合はつい、プログラマも同じ会社で同じくらいの期間、働いているようなつもりで話をしてしまいがちなのです。	7
	3	さらに厄介なのは、顧客の中にはそもそも自分が何を欲しいのかよくわかっていない人が多いということです。	7
	3	大まかなことくらいは把握している人もいますが、自分の希望の細部にいたるまで相手に正しく伝わるようにうまく話せる人はめったにいません。	7
	3	たとえ詳しい話をしてくれたとしても、実際には自分の希望をよくわからずに話しているので、話されたことをそのまま受け取るわけにはいかない場合も多いのです。	7
	3	では、自分の本当の希望を話してくれない人に対し、一体どうやってソフトウェアを提供すればいいのでしょうか。	7
	3	その答えは実に簡単です。	7
	3	顧客との関わりを密にすることです。	7
	3		7
	3	顧客には早い段階から、頻繁に疑問を投げかけ、説明を求めるようにします。	7
	3	言われた言葉をただ文字通り受け取ってはいけないのです。	7
	3	彼らは決して自分の希望を正確に言葉にしているわけではない、というのを常に忘れないようにしましょう。	7
	3	私はよく「顧客から言われたことを、言葉を換えて言い直す」ということをしています。	7
	3	そして相手の反応を見るのです。	7
	3	すると、たとえば「クライアント」という用語1つとっても、自分とはまったく違う意味で使っていることが判明して驚くことがあるでしょう。	7
	3	まったく意味が違うにもかかわらず、顧客はそれに気づかず、自分の思う意味に取ってもらえるはず、と信じ込んで話していることが非常に多いのです。	7
	3	プログラマの側も、言葉の意味が違っていることに気づかなければ混乱して話を正しく理解することができず、当然ソフトウェアを正しく作ることもできません。	7
	3		7
	3	そうした事態を防ぐには、顧客と何度も話し合う必要があります。	7
	3	すぐに相手の言うことを理解したと思い込んではいけないのです。	7
	3	同じ話を何度も聞いてはじめて理解できる、と思っておいた方がいいでしょう。	7
	3	一つ一つのことがらについて、相手の言ったことをこちらの言葉で言い直す、というのを2度3度繰り返すべきです。	7
	3	ある出来事について、それが起きる前と起きた後に話し合ってみる、というのも有効でしょう。	7
	3	そうすれば、相手が何をどんな言葉で話すかがよくわかるはずです。	7
	3	また、可能な限り、同じことを複数の人と、別々の機会に話し合ってみるべきです。	7
	3	すると、同じことを話しているにも関わらず、人によって全然話が違うということがよくあります。	7
	3	まったく無関係と思われていたこと同士に実は関係がある、と判明する場合もあるのです。	7
	3	同じことを二人に話してもらったら、内容が完全に矛盾するということも珍しくありません。	7
	3	開発するソフトウェアが複雑なものであるほど、そういった食い違いはできる限り事前に解消することが重要になります。	7
	3		7
	3	話し合う際には、図や絵などを利用することも大切でしょう。	7
	3	ホワイトボードに簡単な図を描くだけでもずいぶん違います。	7
	3	設計の早い段階で画面のモックアップを作るのも有効です。	7
	3	手がかけられるのなら、機能のプロトタイプを作るのもいいでしょう。	7
	3	話をする際に図や絵などがあると、聞き手の集中力が長く続き、話の内容も長く記憶されることが知られています。	7
	3	プロジェクトの成功のためには、是非とも人間のこの特性を活かすべきです。	7
	3		7
	3	私は以前、いわゆる「マルチメディアソフトウェア」の開発チームにいたことがあります。	7
	3	そのソフトウェアの画面は非常にカラフルで派手なもので、私たちは、ソフトウェアのルック&フィールについて、顧客の希望を事前に詳しく尋ねました。	7
	3	設計ミーテイングで全体のカラースキームについて話し合ったのですが、背景色は「黒」にして欲しい、ということでした。	7
	3	その希望を基に、グラフイツクデザイナーのチームは、何百という数のマルチレイヤーグラフィックスファイルを作成しました。	7
	3	製品を完成させるまでには長時間を要し、労力も大変なものでした。	7
	3	しかし、大変な作業の成果を顧客に披露した時、私たちは驚くべきことを聞かされたのです。	7
	3	製品を見た顧客は背景色についてこう言いました。	7
	3	「ああ、私、「黒」って言いましたけど、あれは「白」っていう意味なんですよ…」よく「白黒をはっきりつける」という言い方をしますが、現実には白黒さえ、なかなかはっきりしないものなのです。	7
	3		7
	3		7
	3	エラーを無視するな	5
	3	Pete Goodlife	6
	3	ある夜、私は、バーに向かつて街を歩いていました。	7
	3	友人たちと会うことになっていたのです。	7
	3	彼らと一緒に飲むのも久しぶりだったので、楽しみにしていました。	7
	3	でも早く行かねばと焦り、周りがよく見えていなかったのでしょう。	7
	3	縁石につまずいて、見事に転んでしまいました。	7
	3	注意力散漫だったわけですから、まあ自業自得です。	7
	3		7
	3	脚が痛みましたが、早く友達に会いに行かねばと思っていたので、立ち上がり、歩き続けました。	7
	3	しかし、歩くほどに、痛みがひどくなってきます。	7
	3	はじめのうちは転んだショックの方が大きく、よくわかっていなかったのですが、どうもこれは、ただごとではないぞという痛みでした。	7
	3		7
	3	私はそれでも構わず、バーへと急ぎました。	7
	3	着く頃には、痛みは激痛になっていました。	7
	3	痛みにばかり気を取られ、せっかく来たのに結局はあまり楽しめませんでした。	7
	3	朝になって医者に行ってみると、脚の骨が折れているとの診断です。	7
	3	痛みを感じた時、そこで止まっていれば、歩き続けなければ、もっと軽く済んだでしょう。	7
	3	それは私のこれまでの人生で最悪の朝でした。	7
	3		7
	3	実を言えば、コードを書くときに同じようなことをしているプログラマはとても多いのではないかと思います。	7
	3		7
	3	エラーが起きているのに、大したことはないと思い込もうとする。	7
	3	大丈夫だと自分に言い聞かせて無視する。	7
	3	そんなことをしても何も良いことはないのです。	7
	3	これでは品質の高いコードはとても書けないでしょう。	7
	3	これは単なる怠惰(良い「怠惰」ではなく、ひどい方の「怠惰」) です。	7
	3	たとえどんなに問題の起きにくいコードでも、エラーチェックとエラーハンドリングは常に必要です。	7
	3	省略しても時間の節約には決してなりません。	7
	3	後でもっと大きな問題が起きる原因を作っているだけです。	7
	3		7
	3	コードからエラーを通知する方法は数多くあります。	7
	3	その例をいくつか挙げておきましょう。	7
	3		7
	3	この方法で例外は握りつぶされてしまう。	7
	3	ただこの場合の救いは、こういう類のコードが書かれているときは、書き手の姿勢に問題があるとすぐにわかることだ。	7
	3		7
	3	エラーが起きているのに、無視する、見て見ぬふりをする、何も起きていないことにする、そういう態度では、リスクが非常に大きくなってしまいます。	7
	3	私が痛みを感じても歩き続け、脚の状態を悪化させてしまったのと同じです。	7
	3	警告を無視して進むと、事態が余計に面倒になってしまうのです。	7
	3	問題の存在を察知したら、できるだけ早く対処すべきです。	7
	3	先延ばしは禁物です。	7
	3		7
	3	エラーを放置すると、次のようなことが起きます。	7
	3		7
	3	自分の書いたコードから発生し得るエラーを丹念にチェックするだけでなく、発生し得るエラーとその条件をインタフェースに明示しましょう。	7
	3	エラーを隠蔽し、何も問題なく動いているかのように見せかけてはいけません。	7
	3		7
	3	なぜエラーチェックをしないのでしょうか?やらない理由(言い訳)も色々あるので、その例を以下に挙げておきます。	7
	3	「自分に当てはまる」というものがあるでしょうか。	7
	3	なぜ、この言い訳が通用しないかわかるでしょうか。	7
	3		7
	3		7
	3	リンカは魔法のプログラムではない	5
	3	Walter Bright	6
	3	コンパイルが必要な言語においては、ソースコードを静的にリンクされた実行ファイルに変換するプロセスが発生します。	7
	3	樗然とするのは、そのプロセスについてごく浅い認識しか持っていないプログラマが意外に多いということです(つい最近も、それを思い知らされる出来事がありました)。	7
	3	読者の中にも、こんな認識の人がいるのではないでしょうか。	7
	3		7
	3	ステップ3で行われるのは、もちろん「リンク」です。	7
	3	何を当たり前のことを、と言う人もいるかもしれません。	7
	3	わざわざこんなバカげたことを言うのには理由があります。	7
	3	私は何十年もテクニカルサポートの仕事をしてきたのですが、次のような質問を受けることが実に多いのです。	7
	3		7
	3	こういう質問をする人の話を聞いていると、「・・・みたいです」、「どういうわけか」という類の言い回しが多いのに気づきます。	7
	3	困惑しているというのがよくわかります。	7
	3	こういう言葉を使うのは、リンクのプロセスを何だか得体の知れない、一種の「魔法」と思っているからでしょう。	7
	3	どうやら超人的な知識と技術を持った専門家にしか理解できないものと捉えているようです。	7
	3	コンパイルの話だと、こういう話し方をする人はまずいないのです。	7
	3	コンパイラなら、少なくとも何をしているか、だいたいのことはわかると，思っているのでしょう。	7
	3		7
	3	リンカは実はさほど難しいプログラムではありません。	7
	3	むしろ単純でわかりやすいプログラムです。	7
	3	することといえば、オブジェクトファイルのコードセクション、データセクションを連結し、定義されているシンボルと参照を接続し、ライブラリから未解決シンボルを抽出し、実行ファイルを書き出す、それだけです。	7
	3	とても単純で、魔法でも何でもありません。	7
	3	なぜリンカが難しく感じるかといえば、処理の結果できるファイルのフォーマットが驚くほど複雑で、そのままで解読することは難しいからでしょう。	7
	3	だからと言って、リンカ自体が複雑な処理をしているというわけではないのです。	7
	3		7
	3	それでは、リンカが、「defが2度以上定義されている」というメッセージを出すのはなぜでしょうか。	7
	3	プログラミング言語の中には、C、C++、Dすなどのように、「宣言」と「定義」の両方を行う、というものが数多くあります。	7
	3	「宣言」は、通常、以下のように、ヘッダファイルで行われます。	7
	3		7
	3	この宣言により、シンボルiiiへの外部参照が生成されることになります。	7
	3	一方、「定義」の場合は、実際にシンボルに対応する記憶領域が確保されます。	7
	3	定義は、通常は実装ファイルの中で、以下のように行われます。	7
	3		7
	3	この場合は、リンカが「iii が2度以上定義されている」というエラーメッセージを出すことになります。	7
	3		7
	3	定義は「1つでしかあり得ない」ものですが、一方で「絶対に1つは必要」なものです。	7
	3	もし出が宣言のみで、一度も定義されていなければ、リンカは「iii は未解決シンボルである」というエラーメッセージを出します。	7
	3		7
	3	実行ファイルが異常に大きくなる理由は、リンカがオプションで生成するマップファイルを見るとわかります。	7
	3	マップファイルは、実行ファイル中の全シンボルとそのアドレスの単なるリストです。	7
	3	マップファイルを見れば、どんなライブラリモジュールがリンクされているか、またそれぞれのモジュールのサイズはどれくらいかもわかります。	7
	3	つまり、実行ファイルのサイズが大きくなっている原因がどのモジュールにあるかがわかるわけです。	7
	3	時には「なぜこのライブラリモジュールがリンクされているのか理由がまったくわからない」というものが見つかることもあります。	7
	3	理由を知るには、そのモジュールをいったんライブラリから削除して、リンクをし直してみる、という方法が有効です。	7
	3	そうすれば、「シンボルが定義されていない」というエラーが出るでしょう。	7
	3	そのエラーを見れば、モジュールがどこで参照されているのかがわかるはずです。	7
	3		7
	3	リンカがメッセージを出した時、その原因がすぐにはわからないことも確かにあります。	7
	3	しかし、それでも、リンカが特に複雑な処理をしているわけではないということは常に念頭に置くべきでしょう。	7
	3	処理自体は簡単だけれども、その結果できるものが複雑で、詳しく検証するのがなかなか面倒ということなのです。	7
	3		7
	3		7
	3	ペアプログラミングと「フロー」	5
	3	Gudny Hauknes Kari Røssland Ann Katrin Gagnat	6
	3	何かに完全に没頭している時(夢中で何かをしていて、時間が経つのも忘れてしまっている時)それはきっと人間にとって幸せな状態です。	7
	3	その状態は「フロー状態」と呼ばれます。	7
	3	しかし、1つのプロジェクトに関わるチームのメンバー全員が同時にフロー状態になり、それが長く持続するというのは難しいものです。	7
	3	フロー状態はいとも簡単に壊れてしまうからです。	7
	3	たとえば誰かに関係のないことを話しかけられ、それに返事をしたりすれば、すぐに集中力は途切れます。	7
	3	少しでも集中力が削がれれば、もうフローは維持できません。	7
	3		7
	3	経験のある人なら知っているでしょうが、実はこのフロー状態の維持には「ペアプログラミング」が非常に役立つのです。	7
	3	まだペアプログラミングの経験がない人は、これから書くことを参考に、是非すぐに試してみてください。	7
	3	ただし、ペアプログラミングを成功させるためには、チームのメンバーが個々に努力するだけでなく、チーム全体としての取り組みも重要になります。	7
	3		7
	3	ペアプログラミングをするにあたってまず大切なことは、ペアを組むパートナーが自分より経験が浅い場合、忍耐強く接することです。	7
	3	自分より技術のあるパートナーと組む人は、気後れすることなく接するのが大事です。	7
	3	人はそれぞれ違っています。	7
	3	その違いを尊重するのです。	7
	3	自分や他のメンバーの長所、短所がどこにあるのか、それを注意深く見るようにしましょう。	7
	3	気をつけて見ていれば、他のメンバーから学べることは驚くほど多いはずです。	7
	3		7
	3	チーム全体としては、各メンバーの持つ技術や知識が、できるだけ多くのメンバーに広まるよう考えてペアプログラミングに取り組むことが重要です。	7
	3	各メンバーはペアを組んだ人と協力し合って作業を進めるわけですが、チームとしては、ペアを組むパートナーや、各人の担当するタスクが頻繁に変わるような体制作りをすべきでしょう。	7
	3	ペアのパートナーやタスクのローテーションに関して、皆の納得できるしっかりとしたルールを定めておくのです。	7
	3	何か問題が起きれば、一時ローテーションを止め、調整をするようにします。	7
	3	タスクを完了させることなく次のペアに引き渡しでも大丈夫です。	7
	3	タスクを中断して次のペアに渡し、ペアのパートナーも変えて別の仕事を始めるのはとても上手くいかないように思えますが、後述する理由により、意外と上手くいくものです。	7
	3		7
	3	ペアプログラミングはフロー状態の維持に役立つのですが、それは以下のような理由からです。	7
	3		7
	3	不慮の事態の影響を量小限に抑えることができる: 縁起でもない話ですが、仮に開発チームのメンバーの何人かが、ある日突然トラックに際かれたとします。	7
	3	何人のメンバーが入院したら、プロジェクトの続行が不可能になるでしょうか?この質問は「チームが特定のメンバーに過度に依存する体制になってはいないか」と問うているのですに知識や技術が一部のメンバーの独占になってはいないでしょうか、共有できているでしょうか。	7
	3	ペアプログラミングで、ペアのパートナーと担当するタスクをローテーションさせていれば、誰かが急にいなくなっても、その人が担当していたタスクを引き継げる人はおそらくいるでしょう。	7
	3	滞りなくタスクが引き継がれれば、チームの全体としてのフロー状態は維持されるはずです。	7
	3	 問題解決が容易: 何か問題に直面したとしても、ペアのパートナーに相談することができます。	7
	3	1人で悩むより、誰かに相談した方が解決する可能性は高いでしょう。	7
	3	また、担当するタスクはローテーションされていくので、あとで誰かが同じ問題に直面し、以前の解決策について検討することもあり得ます。	7
	3	最初の解決策が仮に最善のものでなかったとしても、あとでより良い解決策を別のペアが見つけるかもしれません。	7
	3	 統合がスムーズ: コーディングにおいては、他人の担当しているコードを呼び出すということがよく起きます。	7
	3	その場合、メソッドの名前や、ドキュメント、テストなどが、見てすぐに機能や内容のわかるものになっていると非常に助かります。	7
	3	もしそうなっていない場合でも、自分かペアのパートナーがそのコードを以前担当したことがあれば、機能や内容がすぐにわかり、簡単に呼び出せます。	7
	3	ペアのパートナーや担当するタスクをローテーションしていれば可能性は高まるでしょう。	7
	3	そのタイミングでペアのパートナーと相談し、ネーミング、ドキュメント、テストの改善を図ることもできます。	7
	3	 割り込みの膨響を輝和できる: 作業中には、誰かがやってきて質問をすることもあれば、電話が鳴ることもあります。	7
	3	メールの返事を急いで書かなくてはならないこともあれば、すぐにミーテイングへ出席しなくてはいけない場合もあります。	7
	3	そういう場合でも、ペアプログラミングをしていれば、パートナーに作業を引き継いでもらえます。	7
	3	作業を一時離れていても、その間にパートナーがフロー状態を維持していれば、自分もすぐにフロー状態に戻れます。	7
	3	 新人が早くプロジェクトに馴染む: 担当するタスクと、パートナーをローテーションしていれば、新人が入った場合でもすぐに色々な部分のコードとチームのメンバーに染むことができます。	7
	3		7
	3	フロー状態になれば生産性は驚くほど向上します。	7
	3	しかし、その状態は簡単に壊れます。	7
	3	自分をフロー状態にするため、またその状態を維持するために、あらゆる手段を講じましょう。	7
	3		7
	3		7
	3	テストは正確に、具体的に	5
	3	Kevlin Henney	6
	3	先にも書いたとおり、ユニットテストにおいては、実装コードの「偶然の仕様」への合致を確認するのではなく、コードの動きが本来の要求に合っているかを確認することが大切です。	7
	3	だからと言って、それを言い訳にテストが暖昧なものになるようでは因ります。	7
	3	テストはあくまで正確で厳密なものでなくてはなりません。	7
	3		7
	3	ここでは理解しやすいよう、あえて古典的な例をあげて説明してみましょう。	7
	3	ソート処理のコードをテストするという例です。	7
	3	今の時代に、業務の中でソートアルゴリズムの実装を求められるプログラマはあまりいないでしょう。	7
	3	しかし、ソートなら馴染み深く、ともかくどういう処理なのかを誰しもが知っている(少なくとも知っていると信じている)ので都合がいいのです。	7
	3	ただ、馴染みがあるだけに、自分の思い込みに気づきにくいというのも確かですが。	7
	3		7
	3	ソート処理のコードをテストする場合、「テストで何を確認するのか」とプログラマに尋ねたとすると、ほとんどが「ソート処理の結果、シーケンスの要素がソートされたものになっているかを確かめる」という類の返答になります。	7
	3	この答えは確かに正しいのですが、完全に正しい、とは言えません。	7
	3	「処理結果を正しいとみなす条件を、もう少し詳しく教えて欲しい」というと、多くのプログラマから「処理の以前と以後でシーケンスの長さが同じになっていること」という答えが返ってきます。	7
	3	これも正しいのですが、やはり十分に正しいとは言えません。	7
	3	たとえば、以下のようなシーケンスがあったとします。	7
	3		7
	3	これをソートした結果、以下のシーケンスが得られたとしましょう。	7
	3	もし、テスト結果を正しいとみなす条件が「シーケンスがソートされたものになっていること」「処理の以前と以後でシーケンスの長さが同じになっていること」であれば、この結果でも、条件を満たしていることになります。	7
	3		7
	3	いくら条件を満たすとは言っても、これで良いと思う人はまずいないでしょう。	7
	3	この例は、実際の開発プロジェクトで発生したエラー(幸い、製品のリリース前に発見できました)を基にしたものです。	7
	3	コードを書いている時、単純なタイプミスをしたのか、それとも何か勘違いをしたのか、ともかく結果的に配列のすべての要素を先頭の要素と同じにする、というコードを書いてしまっていたのです。	7
	3		7
	3	テスト結果を正しいとみなす条件としては、「結果としてできるシーケンスがソートされたものになっている」に加えて、「シーケンスが、ソート前と同じ値で構成されている」も必要で、しよう。	7
	3	これで、正しい動作と正しくない動作を適切に見分けることができます。	7
	3	「シーケンスの長さが元と同じ」という条件は、「同じ値で構成されている」という条件が満たされれば自動的に満たされるので、改めて設ける意味はありません。	7
	3		7
	3	ただし、条件を上のように記述しただけでは、良いテストはできません。	7
	3	良いテストというのは、まず読みやすく、理解しやすいものである必要があります。	7
	3	かつシンプルで、正しいか間違っているかが即わかるものでなくてはなりません。	7
	3	「シーケンスがソートされたものになっていて、ソート前とソート後の値の構成が同じ」ということをチェックするコードがすでにあれば別ですが、そうでない状態でテストコードを書こうとすると、テスト対象のコードより複雑なものになってしまう可能性が非常に高いでしょう。	7
	3	Tony Hoareはそれについて次のように言っています。	7
	3		7
	3	テストコードが複雑になると、誤りも起きやすくなります。	7
	3	複雑にならないようにするには、具体的な例を使うという方法が有効です。	7
	3	たとえば、以下のようなシーケンスがあったとします。	7
	3		7
	3	そして、これをソートすると、結果が次のようになるとします。	7
	3		7
	3	テストでは、これ以外の結果をすべて正しくない、とみなすのです。	7
	3	他のどのような結果も無効とします。	7
	3		7
	3	動きについて記述する時、具体的な例があれば、わかりやすく、暖昧さを残さずに記述できるのです。	7
	3	「空のコレクションに1つ項目を追加する」という処理の結果を、単に「コレクションが空になっていない」と表現しただけでは不十分です。	7
	3	「コレクションには項目が1つあり、それは追加された項目である」と表現する必要があります。	7
	3	こう表現すれば、「コレクションにもし2つ以上項目があれば、それはコレクションが空の場合と同様、無効な結果であり、処理が正しくなかったことになる」とわかります。	7
	3	また、「たとえ項目は1つでも、それが追加された項目と違っていれば、やはり結果は無効で、処理が正しくなかったことになる」ということもわかります。	7
	3	「テーブルに行を1つ追加する」という処理の結果は「テーブルが行1つ分、大きくなる」と表現しただけでは不十分です。	7
	3	「増えた行のキーを使用すれば、追加された行が取得できる」ということもつけ加える必要があるでしょう。	7
	3		7
	3	このように、動きについての記述は、ただ正確なだけでは不十分です。	7
	3	それに加え、誤解の余地のないものにしなくてはならないのです。	7
	3		7
	3		7
	3	ステートに注目する	5
	3	Niclas Nilsson	6
	3	「ステート(状態)」というものについて、世間の人は面白い感覚を持っているようです。	7
	3	今朝、私はコーヒーを淹れるのに必要なものを買うために、近所の店に寄って買い物をしました。	7
	3	私はカフェインがないと一日たりとも仕事はできないのです。	7
	3	私が好きなのはカフェラテなので、牛乳を買おうと思ったのですが、牛乳がどこにも見当たりません。	7
	3	そこで店員に尋ねました。	7
	3	すると、「すみません。	7
	3	牛乳は完全に売り切れてます」という答えが返ってきたのです。	7
	3		7
	3	プログラマから見れば、これは変な話です。	7
	3	売り切れは売り切れであり、それ以外ではあり得ません。	7
	3	「少し売り切れ」、「かなり売り切れ」などということはないのです。	7
	3	もしかすると店ではもう一週間も牛乳が品切れで、店員の言葉にはそれが込められていたのかもしれませんが、品切れが一週間だろうが1日だろうが、私にとって結果は同じです。	7
	3	カフェラテでなくエスプレッソで1日過ごすしかないということです。	7
	3		7
	3	もちろん、普段の生活では、ステートの扱いが厳密でなくて困ることはあまりありません。	7
	3	しかし問題なのは、プログラマの中にも、これと同じようにステートを厳密に扱わない人が意外にいるのです。	7
	3		7
	3	たとえば、クレジットカード決済のみを受けつけ、顧客に請求書は送らないというWebショップがあったとします。	7
	3	そして、そのショップのOrderクラスに次のようなメソッドがあったとします。	7
	3		7
	3	仕事をしていると、必要なチェックが抜けているコード、冗長なチェックをしているコードは頻繁に目にします。	7
	3	上の例は大したものではありませんが、キャンセルや払い戻しが絡んでくると、もっと複雑になるでしょう。	7
	3	ステートを適切に扱う必要性がさらに高まるからです。	7
	3	上の例の場合、注文のステートは次の3つに明確に分かれることになります。	7
	3		7
	3	ステートは非常に重要です。	7
	3	何か操作をしようとすれば、まず現在どのステートにいるかを確認する必要があります。	7
	3	その時々のステートによってできる操作とできない操作があるからです。	7
	3	しようとした操作が、そのステートではできないものであれば、ステートが変わるのを待つ必要があります。	7
	3	そうして、常にステートに合った操作だけが行われるようにすることで、オブジェクトを保護するわけです。	7
	3		7
	3	ステートに関しては、具体的にどういうことを注意すべきでしょうかの必要な処理を一つ一つ別のメソッドに分け、どれも必要な時だけ呼び出す、というのは、出発点としてはとても良いですが、あくまで出発点であり十分とは言えません。	7
	3	基本は、「ステートマシン」という考え方を理解することでしょう。	7
	3	そういえば学校でそういうことを習った覚えがあるけれど、もう何だか忘れてしまった、という人もいるでしょうが、そういう人もこれを機会に改めて勉強し直してください。	7
	3	さほど難しいものではありません。	7
	3	図を描くなどすれば、理解しやすくなるはずです。	7
	3	また、図があれば、他の人とステートマシンについて話をするのも簡単です。	7
	3	コードを書くときには、テスト駆動開発で個々の操作に適合するステート、適合しないステート、ステート間の遷移の適切さを確かめながら開発し、実行時に常にステートが正しく保たれるようにしましょう。	7
	3	Stateパターンについても学び、それが十分に理解できたら、「契約による設計 (Designby Contract)」などについても学ぶといいでしょう。	7
	3	そうした知識があれば、入力データをチェックし、ステートがそれに合ったものになっているかを確認するのに役立ちます。	7
	3	さらに、publicメソッドの処理開始時と終了時のオブジェクトのステートが妥当なものになっているかの確認などにも役立つはずです。	7
	3		7
	3	ステートが不適切になる時があるようなら、それはバグです。	7
	3	処理を中断しなければ、データが破壊されてしまう危険があります。	7
	3	ステートチェックのコードが多くて煩わしく感じられるなら、ツールを利用するか、コード生成、ウィーピング、アスペクト技術の使用等について検討するなどして、それが隠れるようにすればいいでしょう。	7
	3	どのようなアプローチをとるにしても、ステートに注目して考えれば、コードをよりシンプルに、そして堅牢にすることにつながります。	7
	3		7
	3		7
	3	命を吹き込む魔法	5
	3	森田 創	6
	3	あなたのプロジェクトにコードネームはありますか?製品名でも、契約書の題目でもなく、あなたのチームが使うコードネームです。	7
	3	コードネームがないならつけてみましょう。	7
	3	誰も文句はいいません。	7
	3		7
	3	製品名のような「正式な名前」があるのに、なぜコードネームが必要なのでしょうか。	7
	3	それは普段から口にする名前こそが私達プログラマにとって「本当の名前」だからです。	7
	3	契約上の名前だけを持つプロジェクトが「開発一課でやってるやつ」あるいは「A社向け」などその場限りの指示語で呼ばれるのを耳にしたことはありませんか?リリースの直前まで製品名が決まらなかったことは?呼び名もないプロジェクトやソフトウェアをどう愛せるというのでしょう。	7
	3	プロジェクトに指示語やラベルではない本当の名前を与えるのが、コードネームの役割です。	7
	3		7
	3	プロジェクトが始まったらコードネームを決めましょう。	7
	3	決めてどんどん使いましょう。	7
	3	Wikiのサイト名、ソースコードのレポジトリ名、メーリングリストなど、身近な識別子をコードネームで統一します。	7
	3	内部向け資料のフッタに埋めこむのも忘れずに。	7
	3	これだけで、チームのメンバーや関係者は自然とコードネームを口にしはじめます。	7
	3		7
	3	もう少し羽田を外したいなら、ソースコード上のパッケージ名や名前空間、サービスのURLなどにもコードネームを使うことができます。	7
	3	ただしエンドユーザや顧客の目にとまり、弁明を求められるかもしれません。	7
	3		7
	3	コードネームは命名の便宜だけに使うものではありません。	7
	3	チームをまとめるシンボルにもなります。	7
	3	コードネームを連想するアイコンを描き、プロジェクトのウェプサイトやツールにイ吏いましょう。	7
	3	コードネームとアイコンをあしらったTシャツを作り、リリース祝いに配りましょう。	7
	3	名前の由来を写真にとってWikiや扉に貼り付けましょう。	7
	3	コードネームにちなんだマスコットキャラクタを探し、エラーページやデバッグコンソールに忍ばせるのも一興です。	7
	3		7
	3	あるコードネームならではの仕掛けを探す楽しみもあります。	7
	3	たとえばコードネームが食べ物や飲み物なら、パーティーの定番メニューにしましょう。	7
	3	コードネームが地名なら、一度はチームで出かけましょう。	7
	3	コードネームが人名なら、伝記を読むのはどうでしょう。	7
	3		7
	3	さて、コードネームは毎日つきあうものですから、素敵な名前をつけたいものです。	7
	3		7
	3	名前の由来が具体的で、身近なものを選びましょう。	7
	3	コードネームの仕掛けで遊ぶときにも、よく知っている名前の方が連想が弾みます。	7
	3	造語も悪くはないですが、どちらかというと「公式な名前」向きです。	7
	3	衆日をひく強い個性は必ずしもコードネームに求められていません。	7
	3	不慣れな外国語から探した単語や、長い名前の略語も避けた方が良いでしょう。	7
	3	一目で意味のとれない名前は覚えられませんからね。	7
	3	読み方がわからず定着しそこねるコードネームは不幸です。	7
	3		7
	3	仲間が多く、連想のふくらむ名前を選びましょう。	7
	3	プロジェクトが成功すればバージョンアップがおこります。	7
	3	大きなプロジェクトにはサブプロジェクトがつきものです。	7
	3	関係するプロジェクト同士に連想しあう名前をつけると一体感がうまれます。	7
	3		7
	3	素敵なコードネームをつけることができたら、その名前を口にして、その名前を呼び、いつも何度も口にしましょう。	7
	3	コードネームはチームを結束する秘密の合言葉であり、プロジェクトを遊ぶための無害な円実であり、姿の見えないソフトウェアに命を吹き込む魔法なのです。	7
	3		7
	3		7
	3	ロールプレイングゲーム	5
	3	関 将俊	6
	3	ここでは私が実践している、ちょっと良いプログラマになるためのコツを紹介します。	7
	3	まるで「理想のプログラマ」のように仕事をするための簡単なアイデアです。	7
	3	チームでプログラミングするお仕事に就かれているみなさんが、このアイデアで昨日よりも気分よく過ごせるようになれば幸いです。	7
	3		7
	3	多くの達人が「理想のプログラマ」とはどういうものか、よいプログラマのあるべき姿、立ち振る舞いを説いてきました。	7
	3	おそらく、みなさんも達人たちが理想のプログラマについて書いた文章を読まれたのではないでしょうか。	7
	3	そして達人たちの示す理想のプログラマ像を想像してそんな人物になろうとしましたよね。	7
	3	みなさんは実際にそうなれたでしょうか。	7
	3	その振る舞いを実践するのはちょっと難しかったりしませんでしたか。	7
	3		7
	3	「理想のプログラマ」といった「理想の何か」になるために、本来の自分を変えて別な自分になる必要があります。	7
	3	しかし変身は痛みを伴うものです。	7
	3	本当に理想のプログラマになろうとすると、あなたの本来の性格や価値観、信条と衝突してしまうことも少なくないでしょう。	7
	3	私は本来「アーティスト」としてのプログラミングが大好きで、自己顕示欲を満たすために行動しています。	7
	3	あまり知られていない問題をちょっとおかしなやり方で解決して、自分の尊敬する人に自慢するためにプログラミングしたいのです。	7
	3	私は長い間「アーティスト」モードの自分と会社員モードの私のプログラミングを使い分けてきました。	7
	3	一時的に別のロールをこなしたり思考パターンを取り替えたりするときに「帽子をかぶる」と表現することがあります。	7
	3	私は「帽子」を使って本来の私と会社員の私のコンフリクトを回避してきました。	7
	3	この「帽子」の領域と時間を拡張して、いっそのこと「理想のプログラマ」を演じてしまうというのはどうでしょう。	7
	3	理想のプログラマを体験するロールプレイングゲームです。	7
	3		7
	3	会社でプログラミングしているあなたを例に考えてみましょう。	7
	3	あなたはお仕事中、9時から18時までの間だけあなたのチームの「理想のプログラマ」の役を演じます。	7
	3	自分の技量を超えたプログラミングを演技することはできませんが、より重要な立ち振る舞いについてなら演技できそうです。	7
	3	あなたの想像する「理想のプログラマ」だったら今この局面でどう振る舞うだろう、この問題に気づいたらどうするだろう、同僚のあの態度に対してどう発言するだろうと想像しながら「理想のプログラマ」を演じるわけです。	7
	3	本来のあなたなら気付いても放置していた問題も、理想のプログラマ役のあなたは見逃すこと無く適切に対応することでしょう。	7
	3	勤務 時間中は理想のプログラマのふりをする。	7
	3	それがあなたの仕事なのです。	7
	3		7
	3	ところで理想のプログラマ像はどこからやってくるのでしょうか。	7
	3	出発点は本に書いてあるような人物かもしれません。	7
	3	しかし、あなたが職場で演じなくてはならないのは「あなたのチームの」理想のプログラマです。	7
	3	「あなたのチームの理想のプログラマ」はあなたのチームで作らなくてはなりません。	7
	3	チームの価値観はチーム内でおこるさまざまなイベントとそれに対するメンバーの反応、つまりたくさんの状況とよい判断の集合で作られます。	7
	3	メンバー各人(あなたもその一人)がその判断が良い/悪い/気に入らないなど一つ一つに対しフィードバックを行うことで、徐々にチームの価値観が醸成されます。	7
	3		7
	3	つまりチームへの関心がチームの価値観を作り、そしてあなたのチームの理想のプログラマ像をあなたの心に浮かび上がらせるのです。	7
	3	仕事だから仕方なく「チームにフィードバックする」と思うと気も楽ですね。	7
	3		7
	3	お仕事中は淡々と理想のプログラマを演じてみましょう。	7
	3	本来の自分を変えるより、ずっと簡単です。	7
	3	迷ったら仕事だと思ってあきらめて演じてください。	7
	3	だって、仕事でしょ?。	7
	3		7
	3	ルーチンワークをフローのきっかけに	5
	3	宮川 達彦	6
	3	ソフトウェア・エンジニアやプログラマはよくアーティストに例えられます。	7
	3	ある人は2時間だけのコーディングで、他の人の8時間分の成果をあげることができます。	7
	3	また、コードの長さは必ずしもその品質やデザインの美しさ、メンテナンス性の高きには比例しません。	7
	3	あるプログラマが朝9時に出社し、夕方6時に退社するとしても、その問ランチをのぞいた8時間、つねにターミナルやエディタを開いてコーディングしつづける、というのはむしろ稀な部類でしょう。	7
	3		7
	3	周りの妨げがなくコーディングに没頭している状態を「フロー状態」と呼びますが、このフロー状態に何の苦労もなく突入できるエンジニアを本当の達人プログラマと呼ぶのかもしれません。	7
	3	何しろ、フローに入るための邪魔や誘惑が多すぎます。	7
	3	受信箱にたまった未読メール、RSSフィードリーダーにたまったニュース、頻繁にポップアップするメッセンジャーやIRCチャット。	7
	3	そして12時になれば同僚とのランチ、午後3時には多少の眠気とたたかうためのコーヒー。	7
	3		7
	3	こうした誘惑に打ち勝つて、ついにエディタやターミナルを開いても、そこからいきなりコードを書き始める、というのもなかなか難しいものです。	7
	3	どんな運動でも準備運動や助走が必要なように、コードを書くという(クリエイティブな!)作業の前にも、そのための準備が必要です。	7
	3	この準備はどんなものでもいいのですが、「ルーチンワーク」をこの準備として利用すると便利なことがあります。	7
	3		7
	3	2年ほど前の話ですが、私の参加するプロジェクトでは、常時2本以上の開発ブランチが定り、また2週間に1度はそれをマージしてプロダクション環境にリリースする、という開発形態をとっていました。	7
	3	それぞれのブランチで複数人が日々多数のコミットを行っており、2週間に1度だけのマージでは発生するコンフリクトの数が多すぎるという問題がありました。	7
	3	そこで、次回リリース用のプランチを用意し、開発プランチから毎日マージすることで、コンフリクトの影響を最小にし、また継続インテグレーションによるテストを容易にしよう、ということになりました。	7
	3		7
	3	半年ほど、私がそのマージの担当者となっていた時期がありました。	7
	3	その問、出社して最初にすることは、ターミナルを開き、開発用サーバにログインして各ブランチからリリースブランチへマージを行うという、いわば単純作業です。	7
	3	もちろんシェルスクリプトを書いてある程度の作業は自動化しましたが、コンフリクトが発生したときの確認や、最後にコミットしてレポジトリにプッシュする部分はターミナルで行います。	7
	3	はじめの数日間は、「こんなルーチンワーク、退屈だな。	7
	3	早く自分の担当がおわればいいけど」と考えていましたが、その作業を続けるうちに、それが毎朝、自分の環境でターミナルを開いて、次に来るべきコーディングへの準備になっていることに気づきました。	7
	3	非クリエイティブにも見えるルーチンワークで自分の体や思考パターンを慣らして、かっその作業をしている間はメールなどの誘惑からも自然とシャットアウトし、フロー状態にはいる助走ができているわけです。	7
	3		7
	3	現在ではその日々のマージ作業はバージョン管理ツールの変更や開発形態が変わったことにより、必要なくなりましたが、こうしたルーチンワークを1日の最初に行う余地を残しておくことは有用だと思っています。	7
	3	毎日のルーチン作業ではなくても、1日の終わりに、翌日最初に行うことを決めてメモしておく、とか、あるいはふと思いついた変更のアイディアをコードのコメントとして残しておく、とか。	7
	3	あえて一晩寝かせておくことで、そのアイデアがいいものであるのか、あるいはあまり筋が良くないものであるか、気づくこともあるかもしれません。	7
	3		7
	3	ルーチンワークで時間を無駄にするのはよくないことです。	7
	3	自動化することによって時間やコストを節約し、またマニュアル作業によるミスを減らすことも重要でしょう。	7
	3	ただ、ほんの少しだけ、その作業で手や頭を動かす余地を残しておくのも、プログラマがクリエイティブになる準備としては、悪くないのかもしれません。	7
	3		7
	3		7
	3	プログラマが持つべき3つのスキル	5
	3	吉岡 弘隆	6
	3	プログラマが持っておくべき基本的なスキルというのは何なのでしょうか。	7
	3	ここで言うスキルというのは、知識を知っている知っていないということではなく、ある作業を出来る出来ないという意味です。	7
	3		7
	3	プログラマが持っておくべきスキルというのはいろいろありますが、あえて3つあげるとすれば、(1)コードを読むスキル、(2)テストをするスキル、(3)デバッグをするスキル、だと考えます。	7
	3		7
	3	そして、このスキルは知識の獲得と違ってインターネットの情報を読むだけでは身につきません。	7
	3	実際に体を動かして試行錯誤をして、時には失敗をして獲得していかないといけないのです。	7
	3	残念ながら、それぞれについて体系的に記述した参考書もほとんどありません。	7
	3	大学でも教えてくれません。	7
	3	ソフトウェア開発の現場で経験を積むしかないのが現状です。	7
	3		7
	3	野球のルールを知っていたとしても、誰もが上手にヒットを打つことが出来ないのです。	7
	3	いいバッターになるには、正しいトレーニングをして、試合で経験を積むしかないのです。	7
	3		7
	3	それでは、どのようにして、それぞれのスキルを身につけていけばいいのでしょうか。	7
	3	理想的には、職場に師匠となる人をみつけてその人の弟子になることです。	7
	3	しかし、現実には、そのようなことはなかなか難しいかと思います。	7
	3	そこでオープンソースソフトウェア(OSS)です。	7
	3	定番のOSSには師匠となるべきカリスマプログラマがいます。	7
	3	開発メーリングリストを購読すれば、ソフトウェアのバグや新機能の仕様について議論していることを見聞きできます。	7
	3		7
	3	開発メーリングリストで議論されていることはリアルな問題です。	7
	3	難しい問題もあれば簡単な問題もあるでしょう。	7
	3	その中から興味深いと思う問題に取り組んでみたらいかがでしょう。	7
	3	簡単そうなバグを1 つ選んで試しにそれをデバッグしてみます。	7
	3	ひょっとしたら誰かが既にそのバグに対するパッチを書いているかもしれませんが、練習ですので気にしません。	7
	3		7
	3	開発環境を用意して、subversionやgitなどのレポジトリから最新版のソースコードをダウンロードします。	7
	3	コンパイル、ビルドします。	7
	3	そしてテスト環境を整えます。	7
	3	選んだ問題がバグの修正ならば、まず当該バグを再現するテストスクリプトなどを準備します。	7
	3		7
	3	デバッガなどを使って、期待する結果と実際の値の差分などを調査していきます。	7
	3	もし実際の値と期待する結果が異なるのであれば、なぜそのようになったかを実行を遡っていきます。	7
	3	当該コードの近辺をよく読んで理解していきます。	7
	3		7
	3	実際のバグを直すという練習は、コードを読むスキル、テストをするスキル、デバッグをするスキルをバランスよく訓練できます。	7
	3	オープンソースの製品でもあっても、仕事のソフトウェアであっても、プログラマとして必要なスキルを鍛えてくれます。	7
	3		7
	3	オープンソースの場合、見ず知らずの人とメールなどでやりとりする中で、徐々にコミュニティ独自の文化や習慣を理解します。	7
	3	そして、バグフィックスなどを通じてスキルを向上させコミュニケーションのいろはを習っていきます。	7
	3	いくつかのバグフィックスをしていけば、自分のスキルが向上するだけではなく、コミュニティにも受け入れられることでしょうす。	7
	3		7
	3	プログラマが持つべき3つのスキル、(1)コードを読むスキル、(2)テストをするスキル、(3)デバッグをするスキル、とその訓練の方法を紹介しました。	7
	3		7
	3		7
	3	快適な環境を追求する	5
	3	舘野 祐一	6
	3	あなたは1日のうち、一体どれぐらいの時間をコーディングに費やしますか?1時間の人もいるでしょうし、10時間の人もいるでしょう。	7
	3	ほほ毎日続けるとしたら、一生でどれぐらいの時間をコーディングすることでしょうか。	7
	3		7
	3	私たちはコーディングをしている時、コードを書く以外にも様々なことを行っています。	7
	3	エディタを操作する・ビルドする・テストを走らせる・ドキュメントを閲覧する・必要なライブラリをインストールする・キーボードを叩く・画面を見る・椅子に座る、などなど細かく挙げるときりがありません。	7
	3		7
	3	たとえばエディタを操作することを考えてみましょう。	7
	3	エディタ上であるメソッドが定義されているソースを開きたいため毎回毎回いちいちgrepを駆使して該当ファイルを見つけて開く、なんて経験ありませんか?エディタ自体に簡単に目的のソースを開ける機能があるかもしれませんし、探せば誰かが有効なプラグインを公開していて、より便利にエディタを扱えるようになるかもしれません。	7
	3		7
	3	たとえばテストを実行することを考えてみましょう。	7
	3	あなたのプロジェクトはすべてのテストを実行するのに20分かかります。	7
	3	あなたはこの時間を何に使いますか?同僚とチャットする・トイレに行く・ドキュメントを読む、ということはできますが結局は20分の待ち時間が発生します。	7
	3	しかしながらテスト自体をより高速に実行させる手法を調べて、並列にテストを実行できる環境を整えて待ち時間が半分になったとすると、残り半分の10分の時間をより有効に使えるでしょう。	7
	3		7
	3	たとえば画面を見ることを考えてみましょう。	7
	3	果たしてあなたの目に映っているコードが書かれた文字や配色は見やすいでしょうか?たとえば表示される文字でも、自分が見やすいと思うフォントに変更してみたり、最適なフォントサイズに変えてみると、今までデフォルトで表示されている画面より快適に見ることが出来るでしょう。	7
	3	端末の背景色が白?それなら黒に変えてみましょう。	7
	3	自分にあった見やすい色を探してみましょう。	7
	3		7
	3	このように身の回りの環境を改善することで、毎回の作業が効率よくなり、時間を有効に活用できるようになり、快適にコーディングすることが出来るようになります。	7
	3		7
	3	快適な環境を追求するにはちょっとした時間の投資が必要になりますが、この投資は決して無駄にはならないでしょう。	7
	3	プログラムをリファクタリングし、より抽象化され高速な、バグのないコードを生み出すことに集中することも大切なことです。	7
	3	新しい言語やプログラミング手法を取り入れ、プログラマとしてスキルアップすることももちろん大切なことです。	7
	3	ですが、ちょっと時間を割いて快適な環境づくりを行うことで、コーディングするための時間をより快適に過ごすことができるようになります。	7
	3	それは一生のうち、かなりの時間が快適になることを意味するのです。	7
	3		7
	3	さあ、あなたも快適な環境を作ることにどん欲になりましょう。	7
	3		7
	3		7
	3	見知らぬ人ともうまくやるには	5
	3	小飼 弾	6
	3	バグには2種類しかありません。	7
	3	1つは、出来るはずのことが出来ないこと。	7
	3	もう1つは、出来てはならないことが出来てしまうこと。	7
	3	そんなこと言われるまでもない?しかしプログラマという人種は前者には十分な注意を払っても、後者には前者ほど注意を払わない生き物のように思われます。	7
	3		7
	3	SQLインジ、エクションにCSRF…いわゆる脆弱性というのはすべて後者に属するバグで、しかも必ずサービスが始まってから顕在化します。	7
	3	こうした脆弱性が後を絶たないのは、プログラマが出来なかったことを出来るようにすることには一生懸命でも、そこで力つきてしまって、出来てはならないことが本当に出来ないかをチェックをするだけの余裕がないことの現れかもしれません。	7
	3		7
	3	これを防ぐには一体どうしたらよいのでしょうか?。	7
	3	私はLLEvalというWebサービスを提供しています。	7
	3	任意のコードを実行するというWebサービスで、類似サービスにはcodepadなどがあります。	7
	3	こうしたサービスはどうやって。	7
	3	のような「出来てはならない」ことを出来ないようにしているのでしょう?。	7
	3	結論から言うと、システムコールを監視し、実行されてはならないシステムコールを受け取ったら即座に実行を停止するという方、法を採っています。	7
	3	例えば上記のコードであればunlinkシステムコールが必ず発行されますが、これを許可しなければよいわけです。	7
	3		7
	3	しかしこれでうまく行くのも、アプリケーションプログラムが「何かするため」には、システムコールを経由しなければならないというOSの仕組みがあってこそです。	7
	3	古き佳きMS-DOSの頃ならさておき、現代的なOSはすべてそうなっています。	7
	3	1/0などの計算機資源にアクセスするには、システムコールというAPIを介するしかないのです。	7
	3		7
	3	ここに大いなるヒントがあります。	7
	3	出来てはならぬことを出来なくするには、「出来てはならぬことを禁じる」のではなく、はじめから「出来ていいことだけを出来るようにする」と考えるのです。	7
	3		7
	3	見知らぬ人とうまくやる一番のコツは、見知らぬことをしないこと。	7
	3		7
	3	誰に、いつ、なにを許可するのかというのは、プログラマに限らず人間社会の永遠の課題であり続けるでしょう。	7
	3	それでも「出来ていいことだけを出来るようにする」をデフォルトにするだけで、この課題は格段に楽になるはずです。	7
	3		7
	3		7
	3	不具合にテストを書いて立ち向かう	5
	3	和田 卓人	6
	3	テストを行っている品質保証チームや、実際にシステムを使つでいる不具合が報告されたとき、あなたはどう思いますか?悲しんだりよ恥ずかしいと思い、不具合修正にすぐに着手したいと気がはやるというのが人情というものです。	7
	3	しかし、焦っているときに行う作業はしばしば視野が狭く、1つの不具合修正が3つの新たな不具合を生んでしまうということになりがちです。	7
	3		7
	3	テスト駆動開発(TDD :Test Driven Development)とは、プログラマが自分の不安を克服し、自分が書くコードに自信を持ちながら一歩一歩進んでいくための手法です。	7
	3	しかし不具合の発生とは、端的に言えばこれまでの「自信」を揺らがせる事態です。	7
	3	テスト駆動開発者は不具合にどう立ち向かうのでしょうか?。	7
	3	やはりテストを書いて立ち向かつてゆくのです。	7
	3	私はテスト駆動開発を数年間実践してくる中で、心がけているひとつの「提」があります。	7
	3	それは、「不具合の修正時には必ず先に不具合を再現する自動テストを書いてから修正する」というものです。	7
	3	これはもちろん私の発案ではなく、XP(eXtreme Programming)やTDDの先達から学び、それを実践するうちに私にも身についてきたものです。	7
	3	不具合修正時のテストは、次のような手順で行います。	7
	3		7
	3	こう書くと面倒に感じるかもしれませんが、不具合修正時のテストには、さまざまなメリットがあります。	7
	3		7
	3	不具合が本当に自分の考えた原因で発生しているかが明らかになる: バグ修正は「当てもの」です。	7
	3	どんな原因で不具合が発生しているのかを、プログラマは推理しなくてはなりません。	7
	3	不具合再現のテストが落ちることを確認することで、「ここが原因だろうと考えて修正したら、全然違う場所が原因だった」というような事故を避けることができます。	7
	3	また、不具合修正に未着手のうちにテストが成功した場合、テストにバグがあるか、考えている不具合の原因が異なるのか、とにかく自分の理解がまだ浅いことを意味しています。	7
	3		7
	3	対象コードと対象領域に対する理解が深まる: 最小単位を探すという行為は原因を深く追い、考えることにつながります。	7
	3	不具合はなぜ発生したのでしょうか。	7
	3	対象領域の理解が浅かったのかもしれません、コードが読みにくかったのかも知れません。	7
	3	不具合修正は新機能の追加とは異なり、既存のコードに対する調査です。	7
	3	これは既存のコードと対象領域に対する理解を深める良い機会になります。	7
	3		7
	3	自分の弱点、気づきにくい点がわかる: 自分ではしっかりとテストを書いているつもりなのに不具合を世に出してしまったということは、自分の思い至らなかったテスト、視点があるということです。	7
	3	自分の弱点や気づきにくい点は、普段コードを書いているだけでは得られない視点であり、非常に貴重ですc また、不具合修正時のテストを書くときには、同様の過ちを犯している箇所は無いかを必ずチェックしましょう。	7
	3	プログラマも人間ですから、同じような過ちを犯している場合があるのです。	7
	3		7
	3	テストの堅牢さ、価値が上がる: 自動テストの利点は、いつでも同じように実行できることです。	7
	3	不具合修正を自動テストの形にすることで、不具合が本当に直ったか即座に確認できます。	7
	3	さらにその自動テストを残しておくことで、今後不具合が再発した場合でも、テストが落ちることによってすぐにわかるようになります。	7
	3	不具合を克服して立ち上がるたびに、テストコードの網羅性は上がり、既存コードに対する自信も深まります。	7
	3		7
	3	「テストを書いている時間は無い」と言われたり、不具合修正時にテストを書くことをひどく遠回りに感じることがあるかもしれません。	7
	3	しかし、患部の絞り込み、修正中の確認、他の部分への影響の確認、再発防止などを考えると、不具合修正にテストを書いて立ち向かうのは合理的で効率的な手法なのです。	7
	3	テストを友として自信を持ちながらコードを書く。	7
	3	それがテスト駆動開発を身につけたプログラマの仕事のやり方です。	7
	3		7
	3		7
	3	育ちのよいコード	5
	3	森田 創	6
	3	高凝集と疎結合が優れた設計の指標だと教わったとき、戸惑ったのを覚えています。	7
	3	あるコードがどのくらい指標を満たしているのか、私達は判断できるのでしょうか。	7
	3		7
	3	巨大な関数や相互依存など、凝集や結合のまずさを示す「匂い」があるのはたしかです。	7
	3	鼻をつまみたくなるソフトウェアは誰にも覚えがあるでしょう。	7
	3	けれど一見清潔なコードをみたときも、それが本当にうまい抽象なのか不安に思うことはありませんか。	7
	3		7
	3	そんな時は少し視点を変え、コードの生い立ちに目を向けましょう。	7
	3	コードのレポジトリをチェックアウトし、それまでにチェックインされた変更、パッチをよく調べるのです。	7
	3	そのパッチはひとかたまりの「+」行からできていましたか?つまりパッチ単位の変更がファイルをまたがず、1つのファイルの同じ場所にまとまっていましたか?。	7
	3	条件にあうパッチが多いなら、凝縮や結合の指標には期待が持てそうです。	7
	3	疎結合なコードは変更があちこちにまたがらないはずですし、高凝集なコードは変更が1箇所にまとまるはずです。	7
	3	そう考えると、このような「まとまりの良い」パッチで、育ったコードは冒頭の指標を満たすうまい設計だと考えて良いのではないでしょうか。	7
	3		7
	3	まとまりの良いパッチには、書き手にとっての利点もあります。	7
	3	レビューの負担が小さく、マージや取り消しも簡単なのです。	7
	3	変更のしやすきに多くを捧げてきたソフトウェア開発の歴史を振り返れば、優れた設計とまとまりの良いパッチの関係は自然なものに思えます。	7
	3	利便性のためだけでなく、設計の正しさを確かめる意味でも、私達はまとまりの良いパッチを書くよう心がけることができるでしょう。	7
	3		7
	3	さて。	7
	3	実際のコードがこう品行方正でないことを、私達は知っています。	7
	3	予期せぬ要望や小さな失敗を重ねるにつれて、健やかに育てたはずのコードにも「まとまりの悪い」パッチが顔を出しはじめます。	7
	3	野心あるコードが枠を破ろうとするのです。	7
	3		7
	3	先を急ぐ野心と慎重な設計を橋渡しするのがリファクタリングの役割です。	7
	3	リファクタリングを通じて設計を見直せば、先を急く野心が凝集や結合を損なうことはありません。	7
	3	ただし、リファクタリングはパッチにとって不都合なところがあります。	7
	3	名前の変更、クラスの引き上げといった構造上の変更は、一見「まとまりの悪い」パッチ、複数のファイルにまたがる小さな変更を生み出すからです。	7
	3		7
	3	リファクタリングを含むパッチはレビュアにとってのちょっとしたホラーですらあります。	7
	3	とはいえリファクタリングをしないコードに明るい未来はありません。	7
	3	まとまりの良いパッチとリファクタリング。	7
	3	2つの間で折り合いをつけたいところです。	7
	3		7
	3	折り合いをつける方法のひとつは、リファクタリングとそれ以外の変更を別のパッチとしてチェックインすることです。	7
	3	振舞いを変更しないリファクタリングの原則は、まとまりの悪さを和らげてくれます。	7
	3	読み手が振舞い自体の正しさを気にしなくて済むからです。	7
	3		7
	3	リファクタリングを独立したパッチに追い出せば、優れた設計を示す「まとまりの良い」パッチが残ります。	7
	3	将来に向けて考えをあらため、新たな一歩を踏み出すコード。	7
	3	野心を手なずけて立派なコードに育ったと、思わず目頭が熱くなります。	7
	3		7
	3		7
	3	Noといえることの大事さ	5
	3	宮川 達彦	6
	3	自分でつくったソフトウェアを公開し、利用してもらうことはとてもうれしいものです。	7
	3	利用しているユーザからのフィードバックに耳を傾けることはソフトウェアをよりよいものにしていくためにもとても重要なことです。	7
	3		7
	3	一方、ソフトウェアのデザインにおける究極の美しさはシンプルさにあると言われます。	7
	3	有名なUNIX哲学では”Write program that do one thing and do it well”(1つのことをうまくやるプログラムを書け)といわれるように、複数の機能をつめ込まず、単一の機能をもったプログラムを組み合わせて使うことが美とされます。	7
	3		7
	3	ここにギャップが生じます。	7
	3	ソフトウェアが人気になり、ユーザが増えるにつれ、「あの機能を追加してくれ」「ここの動作をオプションでOn/Offできるようにしてくれ」という要望が出てきます。	7
	3	実際にそうした機能やオプションが欲しいとおもっているのは、ごく一部であるにもかかわらず、声の大きいユーザからの要望を無視することができず、忠実に応えようとするあまり、あなたはそれをすべて実装してしまいます。	7
	3	ユーザからのフィードパックはうれしいものですからね。	7
	3	はじめて公開したソフトウェアで特におこりがちなことです。	7
	3		7
	3	こうしてあなたのソフトウェアは、ほとんどのユーザが使わないようなニッチな機能と、それを有効にするための複雑怪奇な設定画面または設定ファイルが必要になり、またそれによってメンテナンスがしづらく、バグのでやすいソフトウェアになってしまいました。	7
	3	こうしたソフトウェアはFeature Creep(creep: いつの間にか忍び寄る、からみつく)よばれ、ソフトウェアが破滅に向かう第一歩(あるいはもう手遅れ)の状態になっているといえます。	7
	3		7
	3	こうした悲劇を避けるポイントはただひとつ、そうした要望に「No」といえる勇気です。	7
	3	ソフトウェアのコアではないもの、他のソフトウェアと組み合わせて実装できるものに関しては、明確にNoといえることが、結果としてよいデザインやシンプルさを達成する原動力になります。	7
	3		7
	3	とはいえ、顧客からの要望で、Noということはできない、というケースも多々あるでしょう。	7
	3	そうした場合にも、ソフトウェア本体で実装するのではなく、本体をラップする形の拡張で実装したり、プラグインのようにコアのコードを変更することなく動作を変更できるようなデザインにする、というやり方も考えられます。	7
	3		7
	3	ビジネス上の理由で、そうしたこともできない、というのであれば、そこはそれとあきらめて、業務外でオープンソースのソフトウェアプロジェクトに参加するモチベーションにする、というのもありかもしれません:-)。	7
	3		7
	3	名前重要	5
	3	Matz	6
	3	ネイテイブ・アメリカンの信仰に「すべての人物・事物には真の名前があり、その名前を知るものはそれを支配することができる」というものがあるのだそうです。	7
	3	ですから、彼らは自分の真の名前を秘密にして、家族など本当に信頼できる人にしか打ち明けないのだそうです。	7
	3	そして、対外的にはあだ名を用意してそちらを使うということです。	7
	3	そういえばアニメ化もされたU・K・ル=グウィンの「ゲド戦記」でも同じ設定が用いられていましたね。	7
	3	「ゲド」というのは主人公の真の名前なので物語中にほとんど登場せず、物語の中では彼は一貫して「ハイタカ」と呼ばれていました。	7
	3		7
	3	さて、プログラミングの世界において、この信仰はある程度真実ではないかと感じることがたびたびあります。	7
	3	つまり、事物の名前には、理屈では説明しきれない不思議なパワーがあるような気がするのです。	7
	3		7
	3	たとえば、私が開発しているRubyも、名前のパワーを体現しているように思えます。	7
	3	1993年にRubyの開発を始めた時、Perlにあやかって宝石の名前を選んでRubyと命名しました。	7
	3	あまり深刻に考えず、宝石の名前の中から、短く、覚えやすく、美しい名前としてRubyを選んだだけでしたが、後にRubyが、6月の誕生石である真珠(パール)に続く、7月の誕生石であることに気がついた時、まさに適切な名前であると感じました。	7
	3	また、活字もそれぞれの大きさに応じて宝石の名前が付けられているのですが、パールは5ポイント、ルビーは5.5ポイントで並ん でいます。	7
	3	このルビーがふりがなの「ルビ」の語源になったのはまた別の話。	7
	3		7
	3	今、振り返って思うのは、もし私がRubyという名前を選ばなかったらきっと、現在のRubyの普及を見ることはなかっただろうということです。	7
	3	このRubyという名前にパワーがあったからこそ、Rubyの魅力が増加したのではないかと感じるのです。	7
	3	ただ単にRubyがプログラミング言語として優れているだけでなく、この名前の持つパワーによって、愛される存在となっているのではないかと感じるのです。	7
	3	この名前があればこそ、これまでの長い間Rubyを開発し続けるモチベーションが維持できたし、また多くのユーザがRubyという言語に関心をもってくだ さったのではないかと感じています。	7
	3		7
	3	そんなこともあって、私の設計上の座右の銘は「名前重要」です。	7
	3	あらゆる機能をデザインする時に、私はその名前にもっともこだわります。	7
	3	プログラマとしてのキャリアの中で、適切な名前をつけることができた機能は成功し、そうでない機能については後で後悔することが多かったように思うからです。	7
	3		7
	3	実際、Rubyに対する機能追加の要求に対しても、しばしば「要求は分かつた。	7
	3	あれば便利なのも理解できる。	7
	3	でも、名前が気に入らない。	7
	3	良い名前が決まったら採用する」として拒否したものも数限りなくあります。	7
	3	しかし、名前が気に入らなかったもので、取り入れなかったことを後で後悔したことはほとんどありません。	7
	3		7
	3	これはつまりこういうことなのではないかと思います。	7
	3	適切な名前をつけられると言うことは、その機能が正しく理解されて、設計されているということで、逆にふさわしい名前がつけられないということは、その機能が果たすべき役割を設計者自身も十分理解できていないということなのではないでしょうか。	7
	3	個人的には適切な名前をつけることができた機能については、その設計の8割が完成したと考えても言い過ぎでないことが多いように思います。	7
	3		7
	3	ソフトウェアの設計のアプローチとして、「まず名前から入る」というのは、あまり語られていない秘訣としてもっと広く知られてもよいように思います。	7
